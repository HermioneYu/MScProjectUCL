Returns a hashcode for this IP address.
Compares this object against the specified object. The result is true if and only if the argument is not null and it represents the same IP address as this object. Two instances of InetAddress represent the same IP address if the length of the byte arrays returned by getAddress is the same for both, and each of the array components is the same for the byte arrays.
Create an Inet6Address in the exact manner of InetAddress.getByAddress(String,byte[]) except that the IPv6 scope_id is set to the value corresponding to the given interface for the address type specified in addr. The call will fail with an UnknownHostException if the given interface does not have a numeric scope_id assigned for the given address type (eg. link-local or site-local). See here for a description of IPv6 scoped addresses.
Create an Inet6Address in the exact manner of InetAddress.getByAddress(String,byte[]) except that the IPv6 scope_id is set to the given numeric value. The scope_id is not checked to determine if it corresponds to any interface on the system. See here for a description of IPv6 scoped addresses.
Utility routine to check if the InetAddress is an IP multicast address. 11111111 at the start of the address identifies the address as being a multicast address.
Utility routine to check if the InetAddress in a wildcard address.
Utility routine to check if the InetAddress is a loopback address.
Utility routine to check if the InetAddress is an link local address.
Utility routine to check if the InetAddress is a site local address.
Utility routine to check if the multicast address has global scope.
Utility routine to check if the multicast address has node scope.
Utility routine to check if the multicast address has link scope.
Utility routine to check if the multicast address has site scope.
Utility routine to check if the multicast address has organization scope.
Returns the raw IP address of this InetAddress object. The result is in network byte order: the highest order byte of the address is in getAddress()[0].
Returns the numeric scopeId, if this instance is associated with an interface. If no scoped_id is set, the returned value is zero.
Returns the scoped interface, if this instance was created with with a scoped interface.
"Returns the IP address string in textual presentation. If the instance was created specifying a scope identifier then the scope id is appended to the IP address preceded by a ""%"" (per-cent) character. This can be either a numeric value or a string, depending on which was used to create the instance."
Returns a hashcode for this IP address.
Compares this object against the specified object. The result is true if and only if the argument is not null and it represents the same IP address as this object. Two instances of InetAddress represent the same IP address if the length of the byte arrays returned by getAddress is the same for both, and each of the array components is the same for the byte arrays.
Utility routine to check if the InetAddress is an IPv4 compatible IPv6 address.
Utility routine to check if the InetAddress is an IP multicast address.
Utility routine to check if the InetAddress in a wildcard address.
Utility routine to check if the InetAddress is a loopback address.
Utility routine to check if the InetAddress is an link local address.
Utility routine to check if the InetAddress is a site local address.
Utility routine to check if the multicast address has global scope.
Utility routine to check if the multicast address has node scope.
Utility routine to check if the multicast address has link scope.
Utility routine to check if the multicast address has site scope.
Utility routine to check if the multicast address has organization scope.
Test whether that address is reachable. Best effort is made by the implementation to try to reach the host, but firewalls and server configuration may block requests resulting in a unreachable status while some specific ports may be accessible. A typical implementation will use ICMP ECHO REQUESTs if the privilege can be obtained, otherwise it will try to establish a TCP connection on port 7 (Echo) of the destination host. The timeout value, in milliseconds, indicates the maximum amount of time the try should take. If the operation times out before getting an answer, the host is deemed unreachable. A negative value will result in an IllegalArgumentException being thrown.
Test whether that address is reachable. Best effort is made by the implementation to try to reach the host, but firewalls and server configuration may block requests resulting in a unreachable status while some specific ports may be accessible. A typical implementation will use ICMP ECHO REQUESTs if the privilege can be obtained, otherwise it will try to establish a TCP connection on port 7 (Echo) of the destination host. The network interface and ttl parameters let the caller specify which network interface the test will go through and the maximum number of hops the packets should go through. A negative value for the ttl will result in an IllegalArgumentException being thrown. The timeout value, in milliseconds, indicates the maximum amount of time the try should take. If the operation times out before getting an answer, the host is deemed unreachable. A negative value will result in an IllegalArgumentException being thrown.
Gets the host name for this IP address. If this InetAddress was created with a host name, this host name will be remembered and returned; otherwise, a reverse name lookup will be performed and the result will be returned based on the system configured name lookup service. If a lookup of the name service is required, call getCanonicalHostName. If there is a security manager, its checkConnect method is first called with the hostname and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, it will return the textual representation of the IP address.
Gets the fully qualified domain name for this IP address. Best effort method, meaning we may not be able to return the FQDN depending on the underlying system configuration. If there is a security manager, this method first calls its checkConnect method with the hostname and -1 as its arguments to see if the calling code is allowed to know the hostname for this IP address, i.e., to connect to the host. If the operation is not allowed, it will return the textual representation of the IP address.
Returns the raw IP address of this InetAddress object. The result is in network byte order: the highest order byte of the address is in getAddress()[0].
Returns the IP address string in textual presentation.
Returns a hashcode for this IP address.
Compares this object against the specified object. The result is true if and only if the argument is not null and it represents the same IP address as this object. Two instances of InetAddress represent the same IP address if the length of the byte arrays returned by getAddress is the same for both, and each of the array components is the same for the byte arrays.
Converts this IP address to a String. The string returned is of the form: hostname / literal IP address. If the host name is unresolved, no reverse name service lookup is performed. The hostname part will be represented by an empty string.
"Creates an InetAddress based on the provided host name and IP address. No name service is checked for the validity of the address. The host name can either be a machine name, such as ""java.sun.com"", or a textual representation of its IP address. No validity checking is done on the host name either. If addr specifies an IPv4 address an instance of Inet4Address will be returned; otherwise, an instance of Inet6Address will be returned. IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long"
"Determines the IP address of a host, given the host's name. The host name can either be a machine name, such as ""java.sun.com"", or a textual representation of its IP address. If a literal IP address is supplied, only the validity of the address format is checked. For host specified in literal IPv6 address, either the form defined in RFC 2732 or the literal IPv6 address format defined in RFC 2373 is accepted. IPv6 scoped addresses are also supported. See here for a description of IPv6 scoped addresses. If the host is null then an InetAddress representing an address of the loopback interface is returned. See RFC 3330 section 2 and RFC 2373 section 2.5.3."
"Given the name of a host, returns an array of its IP addresses, based on the configured name service on the system. The host name can either be a machine name, such as ""java.sun.com"", or a textual representation of its IP address. If a literal IP address is supplied, only the validity of the address format is checked. For host specified in literal IPv6 address, either the form defined in RFC 2732 or the literal IPv6 address format defined in RFC 2373 is accepted. A literal IPv6 address may also be qualified by appending a scoped zone identifier or scope_id. The syntax and usage of scope_ids is described here. If the host is null then an InetAddress representing an address of the loopback interface is returned. See RFC 3330 section 2 and RFC 2373 section 2.5.3. If there is a security manager and host is not null and host.length() is not equal to zero, the security manager's checkConnect method is called with the hostname and -1 as its arguments to see if the operation is allowed."
Returns the loopback address. The InetAddress returned will represent the IPv4 loopback address, 127.0.0.1, or the IPv6 loopback address, ::1. The IPv4 loopback address returned is only one of many in the form 127.*.*.*
Returns an InetAddress object given the raw IP address . The argument is in network byte order: the highest order byte of the address is in getAddress()[0]. This method doesn't block, i.e. no reverse name service lookup is performed. IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long
Returns the address of the local host. This is achieved by retrieving the name of the host from the system, then resolving that name into an InetAddress. Note: The resolved address may be cached for a short period of time. If there is a security manager, its checkConnect method is called with the local host name and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, an InetAddress representing the loopback address is returned.
Creates a socket address where the IP address is the wildcard address and the port number a specified value. A valid port value is between 0 and 65535. A port number of zero will let the system pick up an ephemeral port in a bind operation.
Creates a socket address from an IP address and a port number. A valid port value is between 0 and 65535. A port number of zero will let the system pick up an ephemeral port in a bind operation. A null address will assign the wildcard address.
Creates a socket address from a hostname and a port number. An attempt will be made to resolve the hostname into an InetAddress. If that attempt fails, the address will be flagged as unresolved. If there is a security manager, its checkConnect method is called with the host name as its argument to check the permission to resolve it. This could result in a SecurityException. A valid port value is between 0 and 65535. A port number of zero will let the system pick up an ephemeral port in a bind operation.
Creates an unresolved socket address from a hostname and a port number. No attempt will be made to resolve the hostname into an InetAddress. The address will be flagged as unresolved. A valid port value is between 0 and 65535. A port number of zero will let the system pick up an ephemeral port in a bind operation.
Gets the port number.
Gets the InetAddress.
Gets the hostname. Note: This method may trigger a name service reverse lookup if the address was created with a literal IP address.
Returns the hostname, or the String form of the address if it doesn't have a hostname (it was created using a literal). This has the benefit of not attempting a reverse lookup.
Checks whether the address has been resolved or not.
Constructs a string representation of this InetSocketAddress. This String is constructed by calling toString() on the InetAddress and concatenating the port number (with a colon). If the address is unresolved then the part before the colon will only contain the hostname.
"Compares this object against the specified object. The result is true if and only if the argument is not null and it represents the same address as this object. Two instances of InetSocketAddress represent the same address if both the InetAddresses (or hostnames if it is unresolved) and port numbers are equal. If both addresses are unresolved, then the hostname and the port number are compared. Note: Hostnames are case insensitive. e.g. ""FooBar"" and ""foobar"" are considered equal."
Returns a hashcode for this socket address.
Returns an InetAddress for this address.
Returns an InetAddress for the broadcast address for this InterfaceAddress. Only IPv4 networks have broadcast address therefore, in the case of an IPv6 network, null will be returned.
Returns the network prefix length for this address. This is also known as the subnet mask in the context of IPv4 addresses. Typical IPv4 values would be 8 (255.0.0.0), 16 (255.255.0.0) or 24 (255.255.255.0). Typical IPv6 values would be 128 (::1/128) or 10 (fe80::203:baff:fe27:1243/10)
Compares this object against the specified object. The result is true if and only if the argument is not null and it represents the same interface address as this object. Two instances of InterfaceAddress represent the same address if the InetAddress, the prefix length and the broadcast are the same for both.
Returns a hashcode for this Interface address.
Converts this Interface address to a String. The string returned is of the form: InetAddress / prefix length [ broadcast address ].
The connection to the JAR file URL, if the connection has been initiated. This should be set by connect.
Creates the new JarURLConnection to the specified URL.
Returns the URL for the Jar file for this connection.
Return the entry name for this connection. This method returns null if the JAR file URL corresponding to this connection points to a JAR file and not a JAR file entry.
Return the JAR file for this connection.
Returns the Manifest for this connection, or null if none.
Return the JAR entry object for this connection, if any. This method returns null if the JAR file URL corresponding to this connection points to a JAR file and not a JAR file entry.
Return the Attributes object for this connection if the URL for it points to a JAR file entry, null otherwise.
Returns the main Attributes for the JAR file for this connection.
Return the Certificate object for this connection if the URL for it points to a JAR file entry, null otherwise. This method can only be called once the connection has been completely verified by reading from the input stream until the end of the stream has been reached. Otherwise, this method will return null
Constructs a MalformedURLException with no detail message.
Constructs a MalformedURLException with the specified detail message.
Create a multicast socket. If there is a security manager, its checkListen method is first called with 0 as its argument to ensure the operation is allowed. This could result in a SecurityException. When the socket is created the DatagramSocket.setReuseAddress(boolean) method is called to enable the SO_REUSEADDR socket option.
Create a multicast socket and bind it to a specific port. If there is a security manager, its checkListen method is first called with the port argument as its argument to ensure the operation is allowed. This could result in a SecurityException. When the socket is created the DatagramSocket.setReuseAddress(boolean) method is called to enable the SO_REUSEADDR socket option.
Create a MulticastSocket bound to the specified socket address. Or, if the address is null, create an unbound socket. If there is a security manager, its checkListen method is first called with the SocketAddress port as its argument to ensure the operation is allowed. This could result in a SecurityException. When the socket is created the DatagramSocket.setReuseAddress(boolean) method is called to enable the SO_REUSEADDR socket option.
Set the default time-to-live for multicast packets sent out on this MulticastSocket in order to control the scope of the multicasts. The ttl is an unsigned 8-bit quantity, and so must be in the range 0 <= ttl <= 0xFF .
Set the default time-to-live for multicast packets sent out on this MulticastSocket in order to control the scope of the multicasts. The ttl must be in the range 0 <= ttl <= 255 or an IllegalArgumentException will be thrown. Multicast packets sent with a TTL of 0 are not transmitted on the network but may be delivered locally.
Get the default time-to-live for multicast packets sent out on the socket.
Get the default time-to-live for multicast packets sent out on the socket.
Joins a multicast group. Its behavior may be affected by setInterface or setNetworkInterface. If there is a security manager, this method first calls its checkMulticast method with the mcastaddr argument as its argument.
Leave a multicast group. Its behavior may be affected by setInterface or setNetworkInterface. If there is a security manager, this method first calls its checkMulticast method with the mcastaddr argument as its argument.
Joins the specified multicast group at the specified interface. If there is a security manager, this method first calls its checkMulticast method with the mcastaddr argument as its argument.
Leave a multicast group on a specified local interface. If there is a security manager, this method first calls its checkMulticast method with the mcastaddr argument as its argument.
Set the multicast network interface used by methods whose behavior would be affected by the value of the network interface. Useful for multihomed hosts.
Retrieve the address of the network interface used for multicast packets.
Specify the network interface for outgoing multicast datagrams sent on this socket.
Get the multicast network interface set.
Disable/Enable local loopback of multicast datagrams The option is used by the platform's networking code as a hint for setting whether multicast data will be looped back to the local socket. Because this option is a hint, applications that want to verify what loopback mode is set to should call getLoopbackMode()
Get the setting for local loopback of multicast datagrams.
Sends a datagram packet to the destination, with a TTL (time- to-live) other than the default for the socket. This method need only be used in instances where a particular TTL is desired; otherwise it is preferable to set a TTL once on the socket, and use that default TTL for all packets. This method does not alter the default TTL for the socket. Its behavior may be affected by setInterface. If there is a security manager, this method first performs some security checks. First, if p.getAddress().isMulticastAddress() is true, this method calls the security manager's checkMulticast method with p.getAddress() and ttl as its arguments. If the evaluation of that expression is false, this method instead calls the security manager's checkConnect method with arguments p.getAddress().getHostAddress() and p.getPort(). Each call to a security manager method could result in a SecurityException if the operation is not allowed.
"Creates a new NetPermission with the specified name. The name is the symbolic name of the NetPermission, such as ""setDefaultAuthenticator"", etc. An asterisk may appear at the end of the name, following a ""."", or by itself, to signify a wildcard match."
Creates a new NetPermission object with the specified name. The name is the symbolic name of the NetPermission, and the actions String is currently unused and should be null.
Get the name of this network interface.
"Convenience method to return an Enumeration with all or a subset of the InetAddresses bound to this network interface. If there is a security manager, its checkConnect method is called for each InetAddress. Only InetAddresses where the checkConnect doesn't throw a SecurityException will be returned in the Enumeration. However, if the caller has the NetPermission(""getNetworkInformation"") permission, then all InetAddresses are returned."
Get a List of all or a subset of the InterfaceAddresses of this network interface. If there is a security manager, its checkConnect method is called with the InetAddress for each InterfaceAddress. Only InterfaceAddresses where the checkConnect doesn't throw a SecurityException will be returned in the List.
Get an Enumeration with all the subinterfaces (also known as virtual interfaces) attached to this network interface. For instance eth0:1 will be a subinterface to eth0.
Returns the parent NetworkInterface of this interface if this is a subinterface, or null if it is a physical (non virtual) interface or has no parent.
Returns the index of this network interface. The index is an integer greater or equal to zero, or -1 for unknown. This is a system specific value and interfaces with the same name can have different indexes on different machines.
Get the display name of this network interface. A display name is a human readable String describing the network device.
Searches for the network interface with the specified name.
Get a network interface given its index.
Convenience method to search for a network interface that has the specified Internet Protocol (IP) address bound to it. If the specified IP address is bound to multiple network interfaces it is not defined which network interface is returned.
Returns all the interfaces on this machine. The Enumeration contains at least one element, possibly representing a loopback interface that only supports communication between entities on this machine. NOTE: can use getNetworkInterfaces()+getInetAddresses() to obtain all IP addresses for this node
Returns whether a network interface is up and running.
Returns whether a network interface is a loopback interface.
Returns whether a network interface is a point to point interface. A typical point to point interface would be a PPP connection through a modem.
Returns whether a network interface supports multicasting or not.
"Returns the hardware address (usually MAC) of the interface if it has one and if it can be accessed given the current privileges. If a security manager is set, then the caller must have the permission NetPermission(""getNetworkInformation"")."
Returns the Maximum Transmission Unit (MTU) of this interface.
Returns whether this interface is a virtual interface (also called subinterface). Virtual interfaces are, on some systems, interfaces created as a child of a physical interface and given different settings (like address or MTU). Usually the name of the interface will the name of the parent followed by a colon (:) and a number identifying the child since there can be several virtual interfaces attached to a single physical interface.
Compares this object against the specified object. The result is true if and only if the argument is not null and it represents the same NetworkInterface as this object. Two instances of NetworkInterface represent the same NetworkInterface if both name and addrs are the same for both.
Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by HashMap. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the Object.equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Javaâ„¢ programming language.)
"Returns a string representation of the object. In general, the toString method returns a string that ""textually represents"" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of: getClass().getName() + '@' + Integer.toHexString(hashCode())"
Constructs a new NoRouteToHostException with the specified detail message as to why the remote host cannot be reached. A detail message is a String that gives a specific description of this error.
Construct a new NoRouteToHostException with no detailed message.
Creates a new PasswordAuthentication object from the given user name and password. Note that the given user password is cloned before it is stored in the new PasswordAuthentication object.
Returns the user name.
Returns the user password. Note that this method returns a reference to the password. It is the caller's responsibility to zero out the password information after it is no longer needed.
Constructs a new PortUnreachableException with a detail message.
Construct a new PortUnreachableException with no detailed message.
Constructs a new ProtocolException with the specified detail message.
Constructs a new ProtocolException with no detail message.
Returns the name of the protocol family.
A proxy setting that represents a DIRECT connection, basically telling the protocol handler not to use any proxying. Used, for instance, to create sockets bypassing any other global proxy settings (like SOCKS): Socket s = new Socket(Proxy.NO_PROXY);
Creates an entry representing a PROXY connection. Certain combinations are illegal. For instance, for types Http, and Socks, a SocketAddress must be provided. Use the Proxy.NO_PROXY constant for representing a direct connection.
Returns the proxy type.
Returns the socket address of the proxy, or null if its a direct connection.
"Constructs a string representation of this Proxy. This String is constructed by calling toString() on its type and concatenating "" @ "" and the toString() result from its address if its type is not DIRECT."
Compares this object against the specified object. The result is true if and only if the argument is not null and it represents the same proxy as this object. Two instances of Proxy represent the same address if both the SocketAddresses and type are equal.
Returns a hashcode for this Proxy.
Represents a direct connection, or the absence of a proxy.
Represents proxy for high level protocols such as HTTP or FTP.
Represents a SOCKS (V4 or V5) proxy.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (Proxy.Type c : Proxy.Type.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Gets the system-wide proxy selector.
Sets (or unsets) the system-wide proxy selector. Note: non-standard protocol handlers may ignore this setting.
Selects all the applicable proxies based on the protocol to access the resource with and a destination address to access the resource at. The format of the URI is defined as follow: http URI for http connections https URI for https connections socket://host:port for tcp client sockets connections
Called to indicate that a connection could not be established to a proxy/socks server. An implementation of this method can temporarily remove the proxies or reorder the sequence of proxies returned by select(URI), using the address and the IOException caught when trying to connect.
Gets the system-wide response cache.
Sets (or unsets) the system-wide cache. Note: non-standard procotol handlers may ignore this setting.
Retrieve the cached response based on the requesting uri, request method and request headers. Typically this method is called by the protocol handler before it sends out the request to get the network resource. If a cached response is returned, that resource is used instead.
The protocol handler calls this method after a resource has been retrieved, and the ResponseCache must decide whether or not to store the resource in its cache. If the resource is to be cached, then put() must return a CacheRequest object which contains an OutputStream that the protocol handler will use to write the resource into the cache. If the resource is not to be cached, then put must return null.
Returns the cipher suite in use on the original connection that retrieved the network resource.
Returns the certificate chain that were sent to the server during handshaking of the original connection that retrieved the network resource. Note: This method is useful only when using certificate-based cipher suites.
Returns the server's certificate chain, which was established as part of defining the session in the original connection that retrieved the network resource, from cache. Note: This method can be used only when using certificate-based cipher suites; using it with non-certificate-based cipher suites, such as Kerberos, will throw an SSLPeerUnverifiedException.
Returns the server's principal which was established as part of defining the session during the original connection that retrieved the network resource.
Returns the principal that was sent to the server during handshaking in the original connection that retrieved the network resource.
Creates an unbound server socket.
"Creates a server socket, bound to the specified port. A port number of 0 means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling getLocalPort. The maximum queue length for incoming connection indications (a request to connect) is set to 50. If a connection indication arrives when the queue is full, the connection is refused. If the application has specified a server socket factory, that factory's createSocketImpl method is called to create the actual socket implementation. Otherwise a ""plain"" socket is created. If there is a security manager, its checkListen method is called with the port argument as its argument to ensure the operation is allowed. This could result in a SecurityException."
"Creates a server socket and binds it to the specified local port number, with the specified backlog. A port number of 0 means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling getLocalPort. The maximum queue length for incoming connection indications (a request to connect) is set to the backlog parameter. If a connection indication arrives when the queue is full, the connection is refused. If the application has specified a server socket factory, that factory's createSocketImpl method is called to create the actual socket implementation. Otherwise a ""plain"" socket is created. If there is a security manager, its checkListen method is called with the port argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The backlog argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than 0. If it is less than or equal to 0, then an implementation specific default will be used."
Create a server with the specified port, listen backlog, and local IP address to bind to. The bindAddr argument can be used on a multi-homed host for a ServerSocket that will only accept connect requests to one of its addresses. If bindAddr is null, it will default accepting connections on any/all local addresses. The port must be between 0 and 65535, inclusive. A port number of 0 means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling getLocalPort. If there is a security manager, this method calls its checkListen method with the port argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The backlog argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than 0. If it is less than or equal to 0, then an implementation specific default will be used.
Binds the ServerSocket to a specific address (IP address and port number). If the address is null, then the system will pick up an ephemeral port and a valid local address to bind the socket.
Binds the ServerSocket to a specific address (IP address and port number). If the address is null, then the system will pick up an ephemeral port and a valid local address to bind the socket. The backlog argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than 0. If it is less than or equal to 0, then an implementation specific default will be used.
Returns the local address of this server socket. If the socket was bound prior to being closed, then this method will continue to return the local address after the socket is closed. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, the loopback address is returned.
Returns the port number on which this socket is listening. If the socket was bound prior to being closed, then this method will continue to return the port number after the socket is closed.
Returns the address of the endpoint this socket is bound to. If the socket was bound prior to being closed, then this method will continue to return the address of the endpoint after the socket is closed. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port to which the socket is bound is returned.
Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. A new Socket s is created and, if there is a security manager, the security manager's checkAccept method is called with s.getInetAddress().getHostAddress() and s.getPort() as its arguments to ensure the operation is allowed. This could result in a SecurityException.
Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method an empty FooSocket. On return from implAccept the FooSocket will be connected to a client.
Closes this socket. Any thread currently blocked in accept() will throw a SocketException. If this socket has an associated channel then the channel is closed as well.
Returns the unique ServerSocketChannel object associated with this socket, if any. A server socket will have a channel if, and only if, the channel itself was created via the ServerSocketChannel.open method.
Returns the binding state of the ServerSocket.
Returns the closed state of the ServerSocket.
Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, a java.net.SocketTimeoutException is raised, though the ServerSocket is still valid. The option must be enabled prior to entering the blocking operation to have effect. The timeout must be > 0. A timeout of zero is interpreted as an infinite timeout.
Retrieve setting for SO_TIMEOUT. 0 returns implies that the option is disabled (i.e., timeout of infinity).
Enable/disable the SO_REUSEADDR socket option. When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the TIME_WAIT state or 2MSL wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required SocketAddress if there is a connection in the timeout state involving the socket address or port. Enabling SO_REUSEADDR prior to binding the socket using bind(SocketAddress) allows the socket to be bound even though a previous connection is in a timeout state. When a ServerSocket is created the initial setting of SO_REUSEADDR is not defined. Applications can use getReuseAddress() to determine the initial setting of SO_REUSEADDR. The behaviour when SO_REUSEADDR is enabled or disabled after a socket is bound (See isBound()) is not defined.
Tests if SO_REUSEADDR is enabled.
Returns the implementation address and implementation port of this socket as a String. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, an InetAddress representing the loopback address is returned as the implementation address.
Sets the server socket implementation factory for the application. The factory can be specified only once. When an application creates a new server socket, the socket implementation factory's createSocketImpl method is called to create the actual socket implementation. Passing null to the method is a no-op unless the factory was already set. If there is a security manager, this method first calls the security manager's checkSetFactory method to ensure the operation is allowed. This could result in a SecurityException.
Sets a default proposed value for the SO_RCVBUF option for sockets accepted from this ServerSocket. The value actually set in the accepted socket must be determined by calling Socket.getReceiveBufferSize() after the socket is returned by accept(). The value of SO_RCVBUF is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertized to the remote peer. It is possible to change the value subsequently, by calling Socket.setReceiveBufferSize(int). However, if the application wishes to allow a receive window larger than 64K bytes, as defined by RFC1323 then the proposed value must be set in the ServerSocket before it is bound to a local address. This implies, that the ServerSocket must be created with the no-argument constructor, then setReceiveBufferSize() must be called and lastly the ServerSocket is bound to an address by calling bind(). Failure to do this will not cause an error, and the buffer size may be set to the requested value but the TCP receive window in sockets accepted from this ServerSocket will be no larger than 64K bytes.
Gets the value of the SO_RCVBUF option for this ServerSocket, that is the proposed buffer size that will be used for Sockets accepted from this ServerSocket. Note, the value actually set in the accepted socket is determined by calling Socket.getReceiveBufferSize().
Sets performance preferences for this ServerSocket. Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values (1, 0, 0). If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values (0, 1, 2). Invoking this method after this socket has been bound will have no effect. This implies that in order to use this capability requires the socket to be created with the no-argument constructor.
Creates an unconnected socket, with the system-default type of SocketImpl.
"Creates an unconnected socket, specifying the type of proxy, if any, that should be used regardless of any other settings. If there is a security manager, its checkConnect method is called with the proxy host address and port number as its arguments. This could result in a SecurityException. Examples: Socket s = new Socket(Proxy.NO_PROXY); will create a plain socket ignoring any other proxy configuration. Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(""socks.mydom.com"", 1080))); will create a socket connecting through the specified SOCKS proxy server."
Creates an unconnected Socket with a user-specified SocketImpl.
"Creates a stream socket and connects it to the specified port number on the named host. If the specified host is null it is the equivalent of specifying the address as InetAddress.getByName(null). In other words, it is equivalent to specifying an address of the loopback interface. If the application has specified a server socket factory, that factory's createSocketImpl method is called to create the actual socket implementation. Otherwise a ""plain"" socket is created. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException."
"Creates a stream socket and connects it to the specified port number at the specified IP address. If the application has specified a socket factory, that factory's createSocketImpl method is called to create the actual socket implementation. Otherwise a ""plain"" socket is created. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException."
Creates a socket and connects it to the specified remote host on the specified remote port. The Socket will also bind() to the local address and port supplied. If the specified host is null it is the equivalent of specifying the address as InetAddress.getByName(null). In other words, it is equivalent to specifying an address of the loopback interface. A local port number of zero will let the system pick up a free port in the bind operation. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.
Creates a socket and connects it to the specified remote address on the specified remote port. The Socket will also bind() to the local address and port supplied. If the specified local address is null it is the equivalent of specifying the address as the AnyLocal address (see InetAddress.isAnyLocalAddress()). A local port number of zero will let the system pick up a free port in the bind operation. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.
"Creates a stream socket and connects it to the specified port number on the named host. If the specified host is null it is the equivalent of specifying the address as InetAddress.getByName(null). In other words, it is equivalent to specifying an address of the loopback interface. If the stream argument is true, this creates a stream socket. If the stream argument is false, it creates a datagram socket. If the application has specified a server socket factory, that factory's createSocketImpl method is called to create the actual socket implementation. Otherwise a ""plain"" socket is created. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException. If a UDP socket is used, TCP/IP related socket options will not apply."
"Creates a socket and connects it to the specified port number at the specified IP address. If the stream argument is true, this creates a stream socket. If the stream argument is false, it creates a datagram socket. If the application has specified a server socket factory, that factory's createSocketImpl method is called to create the actual socket implementation. Otherwise a ""plain"" socket is created. If there is a security manager, its checkConnect method is called with host.getHostAddress() and port as its arguments. This could result in a SecurityException. If UDP socket is used, TCP/IP related socket options will not apply."
Connects this socket to the server.
Connects this socket to the server with a specified timeout value. A timeout of zero is interpreted as an infinite timeout. The connection will then block until established or an error occurs.
Binds the socket to a local address. If the address is null, then the system will pick up an ephemeral port and a valid local address to bind the socket.
Returns the address to which the socket is connected. If the socket was connected prior to being closed, then this method will continue to return the connected address after the socket is closed.
Gets the local address to which the socket is bound. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, the loopback address is returned.
Returns the remote port number to which this socket is connected. If the socket was connected prior to being closed, then this method will continue to return the connected port number after the socket is closed.
Returns the local port number to which this socket is bound. If the socket was bound prior to being closed, then this method will continue to return the local port number after the socket is closed.
Returns the address of the endpoint this socket is connected to, or null if it is unconnected. If the socket was connected prior to being closed, then this method will continue to return the connected address after the socket is closed.
Returns the address of the endpoint this socket is bound to. If a socket bound to an endpoint represented by an InetSocketAddress is closed, then this method will continue to return an InetSocketAddress after the socket is closed. In that case the returned InetSocketAddress's address is the wildcard address and its port is the local port that it was bound to. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port to which this socket is bound is returned.
Returns the unique SocketChannel object associated with this socket, if any. A socket will have a channel if, and only if, the channel itself was created via the SocketChannel.open or ServerSocketChannel.accept methods.
Returns an input stream for this socket. If this socket has an associated channel then the resulting input stream delegates all of its operations to the channel. If the channel is in non-blocking mode then the input stream's read operations will throw an IllegalBlockingModeException. Under abnormal conditions the underlying connection may be broken by the remote host or the network software (for example a connection reset in the case of TCP connections). When a broken connection is detected by the network software the following applies to the returned input stream :- The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using read. If there are no bytes buffered on the socket, or all buffered bytes have been consumed by read, then all subsequent calls to read will throw an IOException. If there are no bytes buffered on the socket, and the socket has not been closed using close, then available will return 0. Closing the returned InputStream will close the associated socket.
Returns an output stream for this socket. If this socket has an associated channel then the resulting output stream delegates all of its operations to the channel. If the channel is in non-blocking mode then the output stream's write operations will throw an IllegalBlockingModeException. Closing the returned OutputStream will close the associated socket.
Enable/disable TCP_NODELAY (disable/enable Nagle's algorithm).
Tests if TCP_NODELAY is enabled.
Enable/disable SO_LINGER with the specified linger time in seconds. The maximum timeout value is platform specific. The setting only affects socket close.
Returns setting for SO_LINGER. -1 returns implies that the option is disabled. The setting only affects socket close.
Send one byte of urgent data on the socket. The byte to be sent is the lowest eight bits of the data parameter. The urgent byte is sent after any preceding writes to the socket OutputStream and before any future writes to the OutputStream.
Enable/disable SO_OOBINLINE (receipt of TCP urgent data) By default, this option is disabled and TCP urgent data received on a socket is silently discarded. If the user wishes to receive urgent data, then this option must be enabled. When enabled, urgent data is received inline with normal data. Note, only limited support is provided for handling incoming urgent data. In particular, no notification of incoming urgent data is provided and there is no capability to distinguish between normal data and urgent data unless provided by a higher level protocol.
Tests if SO_OOBINLINE is enabled.
Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a read() call on the InputStream associated with this Socket will block for only this amount of time. If the timeout expires, a java.net.SocketTimeoutException is raised, though the Socket is still valid. The option must be enabled prior to entering the blocking operation to have effect. The timeout must be > 0. A timeout of zero is interpreted as an infinite timeout.
Returns setting for SO_TIMEOUT. 0 returns implies that the option is disabled (i.e., timeout of infinity).
Sets the SO_SNDBUF option to the specified value for this Socket. The SO_SNDBUF option is used by the platform's networking code as a hint for the size to set the underlying network I/O buffers. Because SO_SNDBUF is a hint, applications that want to verify what size the buffers were set to should call getSendBufferSize().
Get value of the SO_SNDBUF option for this Socket, that is the buffer size used by the platform for output on this Socket.
Sets the SO_RCVBUF option to the specified value for this Socket. The SO_RCVBUF option is used by the platform's networking code as a hint for the size to set the underlying network I/O buffers. Increasing the receive buffer size can increase the performance of network I/O for high-volume connection, while decreasing it can help reduce the backlog of incoming data. Because SO_RCVBUF is a hint, applications that want to verify what size the buffers were set to should call getReceiveBufferSize(). The value of SO_RCVBUF is also used to set the TCP receive window that is advertized to the remote peer. Generally, the window size can be modified at any time when a socket is connected. However, if a receive window larger than 64K is required then this must be requested before the socket is connected to the remote peer. There are two cases to be aware of: For sockets accepted from a ServerSocket, this must be done by calling ServerSocket.setReceiveBufferSize(int) before the ServerSocket is bound to a local address. For client sockets, setReceiveBufferSize() must be called before connecting the socket to its remote peer.
Gets the value of the SO_RCVBUF option for this Socket, that is the buffer size used by the platform for input on this Socket.
Enable/disable SO_KEEPALIVE.
Tests if SO_KEEPALIVE is enabled.
Sets traffic class or type-of-service octet in the IP header for packets sent from this Socket. As the underlying network implementation may ignore this value applications should consider it a hint. The tc must be in the range 0 <= tc <= 255 or an IllegalArgumentException will be thrown. Notes: For Internet Protocol v4 the value consists of an integer, the least significant 8 bits of which represent the value of the TOS octet in IP packets sent by the socket. RFC 1349 defines the TOS values as follows: IPTOS_LOWCOST (0x02) IPTOS_RELIABILITY (0x04) IPTOS_THROUGHPUT (0x08) IPTOS_LOWDELAY (0x10) The last low order bit is always ignored as this corresponds to the MBZ (must be zero) bit. Setting bits in the precedence field may result in a SocketException indicating that the operation is not permitted. As RFC 1122 section 4.2.4.2 indicates, a compliant TCP implementation should, but is not required to, let application change the TOS field during the lifetime of a connection. So whether the type-of-service field can be changed after the TCP connection has been established depends on the implementation in the underlying platform. Applications should not assume that they can change the TOS field after the connection. For Internet Protocol v6 tc is the value that would be placed into the sin6_flowinfo field of the IP header.
Gets traffic class or type-of-service in the IP header for packets sent from this Socket As the underlying network implementation may ignore the traffic class or type-of-service set using setTrafficClass(int) this method may return a different value than was previously set using the setTrafficClass(int) method on this Socket.
Enable/disable the SO_REUSEADDR socket option. When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the TIME_WAIT state or 2MSL wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required SocketAddress if there is a connection in the timeout state involving the socket address or port. Enabling SO_REUSEADDR prior to binding the socket using bind(SocketAddress) allows the socket to be bound even though a previous connection is in a timeout state. When a Socket is created the initial setting of SO_REUSEADDR is disabled. The behaviour when SO_REUSEADDR is enabled or disabled after a socket is bound (See isBound()) is not defined.
Tests if SO_REUSEADDR is enabled.
Closes this socket. Any thread currently blocked in an I/O operation upon this socket will throw a SocketException. Once a socket has been closed, it is not available for further networking use (i.e. can't be reconnected or rebound). A new socket needs to be created. Closing this socket will also close the socket's InputStream and OutputStream. If this socket has an associated channel then the channel is closed as well.
"Places the input stream for this socket at ""end of stream"". Any data sent to the input stream side of the socket is acknowledged and then silently discarded. If you read from a socket input stream after invoking this method on the socket, the stream's available method will return 0, and its read methods will return -1 (end of stream)."
Disables the output stream for this socket. For a TCP socket, any previously written data will be sent followed by TCP's normal connection termination sequence. If you write to a socket output stream after invoking shutdownOutput() on the socket, the stream will throw an IOException.
Converts this socket to a String.
Returns the connection state of the socket. Note: Closing a socket doesn't clear its connection state, which means this method will return true for a closed socket (see isClosed()) if it was successfuly connected prior to being closed.
Returns the binding state of the socket. Note: Closing a socket doesn't clear its binding state, which means this method will return true for a closed socket (see isClosed()) if it was successfuly bound prior to being closed.
Returns the closed state of the socket.
Returns whether the read-half of the socket connection is closed.
Returns whether the write-half of the socket connection is closed.
Sets the client socket implementation factory for the application. The factory can be specified only once. When an application creates a new client socket, the socket implementation factory's createSocketImpl method is called to create the actual socket implementation. Passing null to the method is a no-op unless the factory was already set. If there is a security manager, this method first calls the security manager's checkSetFactory method to ensure the operation is allowed. This could result in a SecurityException.
Sets performance preferences for this socket. Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. Negative values represent a lower priority than positive values. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values (1, 0, 0). If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values (0, 1, 2). Invoking this method after this socket has been connected will have no effect.
Constructs a new SocketException with the specified detail message.
Constructs a new SocketException with no detail message.
The file descriptor object for this socket.
The IP address of the remote end of this socket.
The port number on the remote host to which this socket is connected.
The local port number to which this socket is connected.
Creates either a stream or a datagram socket.
Connects this socket to the specified port on the named host.
Connects this socket to the specified port number on the specified host.
Connects this socket to the specified port number on the specified host. A timeout of zero is interpreted as an infinite timeout. The connection will then block until established or an error occurs.
Binds this socket to the specified local IP address and port number.
Sets the maximum queue length for incoming connection indications (a request to connect) to the count argument. If a connection indication arrives when the queue is full, the connection is refused.
Accepts a connection.
Returns an input stream for this socket.
Returns an output stream for this socket.
Returns the number of bytes that can be read from this socket without blocking.
Closes this socket.
"Places the input stream for this socket at ""end of stream"". Any data sent to this socket is acknowledged and then silently discarded. If you read from a socket input stream after invoking this method on the socket, the stream's available method will return 0, and its read methods will return -1 (end of stream)."
Disables the output stream for this socket. For a TCP socket, any previously written data will be sent followed by TCP's normal connection termination sequence. If you write to a socket output stream after invoking shutdownOutput() on the socket, the stream will throw an IOException.
Returns the value of this socket's fd field.
Returns the value of this socket's address field.
Returns the value of this socket's port field.
Returns whether or not this SocketImpl supports sending urgent data. By default, false is returned unless the method is overridden in a sub-class
Send one byte of urgent data on the socket. The byte to be sent is the low eight bits of the parameter
Returns the value of this socket's localport field.
Returns the address and port of this socket as a String.
Sets performance preferences for this socket. Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. Negative values represent a lower priority than positive values. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values (1, 0, 0). If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values (0, 1, 2). By default, this method does nothing, unless it is overridden in a a sub-class.
Creates a new SocketImpl instance.
Returns the name of the socket option.
Returns the type of the socket option value.
Disable Nagle's algorithm for this connection. Written data to the network is not buffered pending acknowledgement of previously written data. Valid for TCP only: SocketImpl.
"Fetch the local address binding of a socket (this option cannot be ""set"" only ""gotten"", since sockets are bound at creation time, and so the locally bound address cannot be changed). The default local address of a socket is INADDR_ANY, meaning any local address on a multi-homed host. A multi-homed host can use this option to accept connections to only one of its addresses (in the case of a ServerSocket or DatagramSocket), or to specify its return address to the peer (for a Socket or DatagramSocket). The parameter of this option is an InetAddress. This option must be specified in the constructor. Valid for: SocketImpl, DatagramSocketImpl"
Sets SO_REUSEADDR for a socket. This is used only for MulticastSockets in java, and it is set by default for MulticastSockets. Valid for: DatagramSocketImpl
Sets SO_BROADCAST for a socket. This option enables and disables the ability of the process to send broadcast messages. It is supported for only datagram sockets and only on networks that support the concept of a broadcast message (e.g. Ethernet, token ring, etc.), and it is set by default for DatagramSockets.
Set which outgoing interface on which to send multicast packets. Useful on hosts with multiple network interfaces, where applications want to use other than the system default. Takes/returns an InetAddress. Valid for Multicast: DatagramSocketImpl
Same as above. This option is introduced so that the behaviour with IP_MULTICAST_IF will be kept the same as before, while this new option can support setting outgoing interfaces with either IPv4 and IPv6 addresses. NOTE: make sure there is no conflict with this
This option enables or disables local loopback of multicast datagrams. This option is enabled by default for Multicast Sockets.
This option sets the type-of-service or traffic class field in the IP header for a TCP or UDP socket.
Specify a linger-on-close timeout. This option disables/enables immediate return from a close() of a TCP Socket. Enabling this option with a non-zero Integer timeout means that a close() will block pending the transmission and acknowledgement of all data written to the peer, at which point the socket is closed gracefully. Upon reaching the linger timeout, the socket is closed forcefully, with a TCP RST. Enabling the option with a timeout of zero does a forceful close immediately. If the specified timeout value exceeds 65,535 it will be reduced to 65,535. Valid only for TCP: SocketImpl
Set a timeout on blocking Socket operations: ServerSocket.accept(); SocketInputStream.read(); DatagramSocket.receive(); The option must be set prior to entering a blocking operation to take effect. If the timeout expires and the operation would continue to block, java.io.InterruptedIOException is raised. The Socket is not closed in this case. Valid for all sockets: SocketImpl, DatagramSocketImpl
Set a hint the size of the underlying buffers used by the platform for outgoing network I/O. When used in set, this is a suggestion to the kernel from the application about the size of buffers to use for the data to be sent over the socket. When used in get, this must return the size of the buffer actually used by the platform when sending out data on this socket. Valid for all sockets: SocketImpl, DatagramSocketImpl
Set a hint the size of the underlying buffers used by the platform for incoming network I/O. When used in set, this is a suggestion to the kernel from the application about the size of buffers to use for the data to be received over the socket. When used in get, this must return the size of the buffer actually used by the platform when receiving in data on this socket. Valid for all sockets: SocketImpl, DatagramSocketImpl
When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours (NOTE: the actual value is implementation dependent), TCP automatically sends a keepalive probe to the peer. This probe is a TCP segment to which the peer must respond. One of three responses is expected: 1. The peer responds with the expected ACK. The application is not notified (since everything is OK). TCP will send another probe following another 2 hours of inactivity. 2. The peer responds with an RST, which tells the local TCP that the peer host has crashed and rebooted. The socket is closed. 3. There is no response from the peer. The socket is closed. The purpose of this option is to detect if the peer host crashes. Valid only for TCP socket: SocketImpl
When the OOBINLINE option is set, any TCP urgent data received on the socket will be received through the socket input stream. When the option is disabled (which is the default) urgent data is silently discarded.
"Enable/disable the option specified by optID. If the option is to be enabled, and it takes an option-specific ""value"", this is passed in value. The actual type of value is option-specific, and it is an error to pass something that isn't of the expected type: SocketImpl s; ... s.setOption(SO_LINGER, new Integer(10)); // OK - set SO_LINGER w/ timeout of 10 sec. s.setOption(SO_LINGER, new Double(10)); // ERROR - expects java.lang.Integer If the requested option is binary, it can be set using this method by a java.lang.Boolean: s.setOption(TCP_NODELAY, new Boolean(true)); // OK - enables TCP_NODELAY, a binary option Any option can be disabled using this method with a Boolean(false): s.setOption(TCP_NODELAY, new Boolean(false)); // OK - disables TCP_NODELAY s.setOption(SO_LINGER, new Boolean(false)); // OK - disables SO_LINGER For an option that has a notion of on and off, and requires a non-boolean parameter, setting its value to anything other than Boolean(false) implicitly enables it. Throws SocketException if the option is unrecognized, the socket is closed, or some low-level error occurred"
"Fetch the value of an option. Binary options will return java.lang.Boolean(true) if enabled, java.lang.Boolean(false) if disabled, e.g.: SocketImpl s; ... Boolean noDelay = (Boolean)(s.getOption(TCP_NODELAY)); if (noDelay.booleanValue()) { // true if TCP_NODELAY is enabled... ... } For options that take a particular type as a parameter, getOption(int) will return the parameter's value, else it will return java.lang.Boolean(false): Object o = s.getOption(SO_LINGER); if (o instanceof Integer) { System.out.print(""Linger time is "" + ((Integer)o).intValue()); } else { // the true type of o is java.lang.Boolean(false); }"
"Creates a new SocketPermission object with the specified actions. The host is expressed as a DNS name, or as a numerical IP address. Optionally, a port or a portrange may be supplied (separated from the DNS name or IP address by a colon). To specify the local machine, use ""localhost"" as the host. Also note: An empty host String ("""") is equivalent to ""localhost"". The actions parameter contains a comma-separated list of the actions granted for the specified host (and port(s)). Possible actions are ""connect"", ""listen"", ""accept"", ""resolve"", or any combination of those. ""resolve"" is automatically added when any of the other three are specified. Examples of SocketPermission instantiation are the following: nr = new SocketPermission(""www.catalog.com"", ""connect""); nr = new SocketPermission(""www.sun.com:80"", ""connect""); nr = new SocketPermission(""*.sun.com"", ""connect""); nr = new SocketPermission(""*.edu"", ""resolve""); nr = new SocketPermission(""204.160.241.0"", ""connect""); nr = new SocketPermission(""localhost:1024-65535"", ""listen""); nr = new SocketPermission(""204.160.241.0:1024-65535"", ""connect"");"
"Checks if this socket permission object ""implies"" the specified permission. More specifically, this method first ensures that all of the following are true (and returns false if any of them are not): p is an instanceof SocketPermission, p's actions are a proper subset of this object's actions, and p's port range is included in this port range. Note: port range is ignored when p only contains the action, 'resolve'. Then implies checks each of the following, in order, and for each returns true if the stated condition is true: If this object was initialized with a single IP address and one of p's IP addresses is equal to this object's IP address. If this object is a wildcard domain (such as *.sun.com), and p's canonical name (the name without any preceding *) ends with this object's canonical host name. For example, *.sun.com implies *.eng.sun.com. If this object was not initialized with a single IP address, and one of this object's IP addresses equals one of p's IP addresses. If this canonical name equals p's canonical name. If none of the above are true, implies returns false."
Checks two SocketPermission objects for equality.
Returns the hash code value for this object.
Returns the canonical string representation of the actions. Always returns present actions in the following order: connect, listen, accept, resolve.
Returns a new PermissionCollection object for storing SocketPermission objects. SocketPermission objects must be stored in a manner that allows them to be inserted into the collection in any order, but that also enables the PermissionCollection implies method to be implemented in an efficient (and consistent) manner.
Constructs a new SocketTimeoutException with a detail message.
Construct a new SocketTimeoutException with no detailed message.
Internet Protocol Version 4 (IPv4)
Internet Protocol Version 6 (IPv6)
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (StandardProtocolFamily c : StandardProtocolFamily.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Allow transmission of broadcast datagrams. The value of this socket option is a Boolean that represents whether the option is enabled or disabled. The option is specific to datagram-oriented sockets sending to IPv4 broadcast addresses. When the socket option is enabled then the socket can be used to send broadcast datagrams. The initial value of this socket option is FALSE. The socket option may be enabled or disabled at any time. Some operating systems may require that the Java virtual machine be started with implementation specific privileges to enable this option or send broadcast datagrams.
Keep connection alive. The value of this socket option is a Boolean that represents whether the option is enabled or disabled. When the SO_KEEPALIVE option is enabled the operating system may use a keep-alive mechanism to periodically probe the other end of a connection when the connection is otherwise idle. The exact semantics of the keep alive mechanism is system dependent and therefore unspecified. The initial value of this socket option is FALSE. The socket option may be enabled or disabled at any time.
The size of the socket send buffer. The value of this socket option is an Integer that is the size of the socket send buffer in bytes. The socket send buffer is an output buffer used by the networking implementation. It may need to be increased for high-volume connections. The value of the socket option is a hint to the implementation to size the buffer and the actual size may differ. The socket option can be queried to retrieve the actual size. For datagram-oriented sockets, the size of the send buffer may limit the size of the datagrams that may be sent by the socket. Whether datagrams larger than the buffer size are sent or discarded is system dependent. The initial/default size of the socket send buffer and the range of allowable values is system dependent although a negative size is not allowed. An attempt to set the socket send buffer to larger than its maximum size causes it to be set to its maximum size. An implementation allows this socket option to be set before the socket is bound or connected. Whether an implementation allows the socket send buffer to be changed after the socket is bound is system dependent.
The size of the socket receive buffer. The value of this socket option is an Integer that is the size of the socket receive buffer in bytes. The socket receive buffer is an input buffer used by the networking implementation. It may need to be increased for high-volume connections or decreased to limit the possible backlog of incoming data. The value of the socket option is a hint to the implementation to size the buffer and the actual size may differ. For datagram-oriented sockets, the size of the receive buffer may limit the size of the datagrams that can be received. Whether datagrams larger than the buffer size can be received is system dependent. Increasing the socket receive buffer may be important for cases where datagrams arrive in bursts faster than they can be processed. In the case of stream-oriented sockets and the TCP/IP protocol, the size of the socket receive buffer may be used when advertising the size of the TCP receive window to the remote peer. The initial/default size of the socket receive buffer and the range of allowable values is system dependent although a negative size is not allowed. An attempt to set the socket receive buffer to larger than its maximum size causes it to be set to its maximum size. An implementation allows this socket option to be set before the socket is bound or connected. Whether an implementation allows the socket receive buffer to be changed after the socket is bound is system dependent.
Re-use address. The value of this socket option is a Boolean that represents whether the option is enabled or disabled. The exact semantics of this socket option are socket type and system dependent. In the case of stream-oriented sockets, this socket option will usually determine whether the socket can be bound to a socket address when a previous connection involving that socket address is in the TIME_WAIT state. On implementations where the semantics differ, and the socket option is not required to be enabled in order to bind the socket when a previous connection is in this state, then the implementation may choose to ignore this option. For datagram-oriented sockets the socket option is used to allow multiple programs bind to the same address. This option should be enabled when the socket is to be used for Internet Protocol (IP) multicasting. An implementation allows this socket option to be set before the socket is bound or connected. Changing the value of this socket option after the socket is bound has no effect. The default value of this socket option is system dependent.
Linger on close if data is present. The value of this socket option is an Integer that controls the action taken when unsent data is queued on the socket and a method to close the socket is invoked. If the value of the socket option is zero or greater, then it represents a timeout value, in seconds, known as the linger interval. The linger interval is the timeout for the close method to block while the operating system attempts to transmit the unsent data or it decides that it is unable to transmit the data. If the value of the socket option is less than zero then the option is disabled. In that case the close method does not wait until unsent data is transmitted; if possible the operating system will transmit any unsent data before the connection is closed. This socket option is intended for use with sockets that are configured in blocking mode only. The behavior of the close method when this option is enabled on a non-blocking socket is not defined. The initial value of this socket option is a negative value, meaning that the option is disabled. The option may be enabled, or the linger interval changed, at any time. The maximum value of the linger interval is system dependent. Setting the linger interval to a value that is greater than its maximum value causes the linger interval to be set to its maximum value.
The Type of Service (ToS) octet in the Internet Protocol (IP) header. The value of this socket option is an Integer representing the value of the ToS octet in IP packets sent by sockets to an IPv4 socket. The interpretation of the ToS octet is network specific and is not defined by this class. Further information on the ToS octet can be found in RFC 1349 and RFC 2474. The value of the socket option is a hint. An implementation may ignore the value, or ignore specific values. The initial/default value of the TOS field in the ToS octet is implementation specific but will typically be 0. For datagram-oriented sockets the option may be configured at any time after the socket has been bound. The new value of the octet is used when sending subsequent datagrams. It is system dependent whether this option can be queried or changed prior to binding the socket. The behavior of this socket option on a stream-oriented socket, or an IPv6 socket, is not defined in this release.
The network interface for Internet Protocol (IP) multicast datagrams. The value of this socket option is a NetworkInterface that represents the outgoing interface for multicast datagrams sent by the datagram-oriented socket. For IPv6 sockets then it is system dependent whether setting this option also sets the outgoing interface for multicast datagrams sent to IPv4 addresses. The initial/default value of this socket option may be null to indicate that outgoing interface will be selected by the operating system, typically based on the network routing tables. An implementation allows this socket option to be set after the socket is bound. Whether the socket option can be queried or changed prior to binding the socket is system dependent.
The time-to-live for Internet Protocol (IP) multicast datagrams. The value of this socket option is an Integer in the range 0 <= value <= 255. It is used to control the scope of multicast datagrams sent by the datagram-oriented socket. In the case of an IPv4 socket the option is the time-to-live (TTL) on multicast datagrams sent by the socket. Datagrams with a TTL of zero are not transmitted on the network but may be delivered locally. In the case of an IPv6 socket the option is the hop limit which is number of hops that the datagram can pass through before expiring on the network. For IPv6 sockets it is system dependent whether the option also sets the time-to-live on multicast datagrams sent to IPv4 addresses. The initial/default value of the time-to-live setting is typically 1. An implementation allows this socket option to be set after the socket is bound. Whether the socket option can be queried or changed prior to binding the socket is system dependent.
Loopback for Internet Protocol (IP) multicast datagrams. The value of this socket option is a Boolean that controls the loopback of multicast datagrams. The value of the socket option represents if the option is enabled or disabled. The exact semantics of this socket options are system dependent. In particular, it is system dependent whether the loopback applies to multicast datagrams sent from the socket or received by the socket. For IPv6 sockets then it is system dependent whether the option also applies to multicast datagrams sent to IPv4 addresses. The initial/default value of this socket option is TRUE. An implementation allows this socket option to be set after the socket is bound. Whether the socket option can be queried or changed prior to binding the socket is system dependent.
Disable the Nagle algorithm. The value of this socket option is a Boolean that represents whether the option is enabled or disabled. The socket option is specific to stream-oriented sockets using the TCP/IP protocol. TCP/IP uses an algorithm known as The Nagle Algorithm to coalesce short segments and improve network efficiency. The default value of this socket option is FALSE. The socket option should only be enabled in cases where it is known that the coalescing impacts performance. The socket option may be enabled at any time. In other words, the Nagle Algorithm can be disabled. Once the option is enabled, it is system dependent whether it can be subsequently disabled. If it cannot, then invoking the setOption method to disable the option has no effect.
Constructs a new UnknownHostException with the specified detail message.
Constructs a new UnknownHostException with no detail message.
Constructs a new UnknownServiceException with no detail message.
Constructs a new UnknownServiceException with the specified detail message.
"Constructs a URI by parsing the given string. This constructor parses the given string exactly as specified by the grammar in RFC 2396, Appendix A, except for the following deviations: An empty authority component is permitted as long as it is followed by a non-empty path, a query component, or a fragment component. This allows the parsing of URIs such as ""file:///foo/bar"", which seems to be the intent of RFC 2396 although the grammar does not permit it. If the authority component is empty then the user-information, host, and port components are undefined. Empty relative paths are permitted; this seems to be the intent of RFC 2396 although the grammar does not permit it. The primary consequence of this deviation is that a standalone fragment such as ""#foo"" parses as a relative URI with an empty path and the given fragment, and can be usefully resolved against a base URI. IPv4 addresses in host components are parsed rigorously, as specified by RFC 2732: Each element of a dotted-quad address must contain no more than three decimal digits. Each element is further constrained to have a value no greater than 255. Hostnames in host components that comprise only a single domain label are permitted to start with an alphanum character. This seems to be the intent of RFC 2396 section 3.2.2 although the grammar does not permit it. The consequence of this deviation is that the authority component of a hierarchical URI such as s://123, will parse as a server-based authority. IPv6 addresses are permitted for the host component. An IPv6 address must be enclosed in square brackets ('[' and ']') as specified by RFC 2732. The IPv6 address itself must parse according to RFC 2373. IPv6 addresses are further constrained to describe no more than sixteen bytes of address information, a constraint implicit in RFC 2373 but not expressible in the grammar. Characters in the other category are permitted wherever RFC 2396 permits escaped octets, that is, in the user-information, path, query, and fragment components, as well as in the authority component if the authority is registry-based. This allows URIs to contain Unicode characters beyond those in the US-ASCII character set."
"Constructs a hierarchical URI from the given components. If a scheme is given then the path, if also given, must either be empty or begin with a slash character ('/'). Otherwise a component of the new URI may be left undefined by passing null for the corresponding parameter or, in the case of the port parameter, by passing -1. This constructor first builds a URI string from the given components according to the rules specified in RFC 2396, section 5.2, step 7: Initially, the result string is empty. If a scheme is given then it is appended to the result, followed by a colon character (':'). If user information, a host, or a port are given then the string ""//"" is appended. If user information is given then it is appended, followed by a commercial-at character ('@'). Any character not in the unreserved, punct, escaped, or other categories is quoted. If a host is given then it is appended. If the host is a literal IPv6 address but is not enclosed in square brackets ('[' and ']') then the square brackets are added. If a port number is given then a colon character (':') is appended, followed by the port number in decimal. If a path is given then it is appended. Any character not in the unreserved, punct, escaped, or other categories, and not equal to the slash character ('/') or the commercial-at character ('@'), is quoted. If a query is given then a question-mark character ('?') is appended, followed by the query. Any character that is not a legal URI character is quoted. Finally, if a fragment is given then a hash character ('#') is appended, followed by the fragment. Any character that is not a legal URI character is quoted. The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown."
"Constructs a hierarchical URI from the given components. If a scheme is given then the path, if also given, must either be empty or begin with a slash character ('/'). Otherwise a component of the new URI may be left undefined by passing null for the corresponding parameter. This constructor first builds a URI string from the given components according to the rules specified in RFC 2396, section 5.2, step 7: Initially, the result string is empty. If a scheme is given then it is appended to the result, followed by a colon character (':'). If an authority is given then the string ""//"" is appended, followed by the authority. If the authority contains a literal IPv6 address then the address must be enclosed in square brackets ('[' and ']'). Any character not in the unreserved, punct, escaped, or other categories, and not equal to the commercial-at character ('@'), is quoted. If a path is given then it is appended. Any character not in the unreserved, punct, escaped, or other categories, and not equal to the slash character ('/') or the commercial-at character ('@'), is quoted. If a query is given then a question-mark character ('?') is appended, followed by the query. Any character that is not a legal URI character is quoted. Finally, if a fragment is given then a hash character ('#') is appended, followed by the fragment. Any character that is not a legal URI character is quoted. The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown."
Constructs a hierarchical URI from the given components. A component may be left undefined by passing null. This convenience constructor works as if by invoking the seven-argument constructor as follows: new URI(scheme, null, host, -1, path, null, fragment);
Constructs a URI from the given components. A component may be left undefined by passing null. This constructor first builds a URI in string form using the given components as follows: Initially, the result string is empty. If a scheme is given then it is appended to the result, followed by a colon character (':'). If a scheme-specific part is given then it is appended. Any character that is not a legal URI character is quoted. Finally, if a fragment is given then a hash character ('#') is appended to the string, followed by the fragment. Any character that is not a legal URI character is quoted. The resulting URI string is then parsed in order to create the new URI instance as if by invoking the URI(String) constructor; this may cause a URISyntaxException to be thrown.
Creates a URI by parsing the given string. This convenience factory method works as if by invoking the URI(String) constructor; any URISyntaxException thrown by the constructor is caught and wrapped in a new IllegalArgumentException object, which is then thrown. This method is provided for use in situations where it is known that the given string is a legal URI, for example for URI constants declared within in a program, and so it would be considered a programming error for the string not to parse as such. The constructors, which throw URISyntaxException directly, should be used situations where a URI is being constructed from user input or from some other source that may be prone to errors.
"Attempts to parse this URI's authority component, if defined, into user-information, host, and port components. If this URI's authority component has already been recognized as being server-based then it will already have been parsed into user-information, host, and port components. In this case, or if this URI has no authority component, this method simply returns this URI. Otherwise this method attempts once more to parse the authority component into user-information, host, and port components, and throws an exception describing why the authority component could not be parsed in that way. This method is provided because the generic URI syntax specified in RFC 2396 cannot always distinguish a malformed server-based authority from a legitimate registry-based authority. It must therefore treat some instances of the former as instances of the latter. The authority component in the URI string ""//foo:bar"", for example, is not a legal server-based authority but it is legal as a registry-based authority. In many common situations, for example when working URIs that are known to be either URNs or URLs, the hierarchical URIs being used will always be server-based. They therefore must either be parsed as such or treated as an error. In these cases a statement such as URI u= new URI(str).parseServerAuthority(); can be used to ensure that u always refers to a URI that, if it has an authority component, has a server-based authority with proper user-information, host, and port components. Invoking this method also ensures that if the authority could not be parsed in that way then an appropriate diagnostic message can be issued based upon the exception that is thrown."
"Normalizes this URI's path. If this URI is opaque, or if its path is already in normal form, then this URI is returned. Otherwise a new URI is constructed that is identical to this URI except that its path is computed by normalizing this URI's path in a manner consistent with RFC 2396, section 5.2, step 6, sub-steps c through f; that is: All ""."" segments are removed. If a "".."" segment is preceded by a non-"".."" segment then both of these segments are removed. This step is repeated until it is no longer applicable. If the path is relative, and if its first segment contains a colon character (':'), then a ""."" segment is prepended. This prevents a relative URI with a path such as ""a:b/c/d"" from later being re-parsed as an opaque URI with a scheme of ""a"" and a scheme-specific part of ""b/c/d"". (Deviation from RFC 2396) A normalized path will begin with one or more "".."" segments if there were insufficient non-"".."" segments preceding them to allow their removal. A normalized path will begin with a ""."" segment if one was inserted by step 3 above. Otherwise, a normalized path will not contain any ""."" or "".."" segments."
"Resolves the given URI against this URI. If the given URI is already absolute, or if this URI is opaque, then the given URI is returned. If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as ""#foo"", to be usefully resolved against a base URI. Otherwise this method constructs a new hierarchical URI in a manner consistent with RFC 2396, section 5.2; that is: A new URI is constructed with this URI's scheme and the given URI's query and fragment components. If the given URI has an authority component then the new URI's authority and path are taken from the given URI. Otherwise the new URI's authority component is copied from this URI, and its path is computed as follows: If the given URI's path is absolute then the new URI's path is taken from the given URI. Otherwise the given URI's path is relative, and so the new URI's path is computed by resolving the path of the given URI against the path of this URI. This is done by concatenating all but the last segment of this URI's path, if any, with the given URI's path and then normalizing the result as if by invoking the normalize method. The result of this method is absolute if, and only if, either this URI is absolute or the given URI is absolute."
Constructs a new URI by parsing the given string and then resolving it against this URI. This convenience method works as if invoking it were equivalent to evaluating the expression resolve(URI.create(str)).
Relativizes the given URI against this URI. The relativization of the given URI against this URI is computed as follows: If either this URI or the given URI are opaque, or if the scheme and authority components of the two URIs are not identical, or if the path of this URI is not a prefix of the path of the given URI, then the given URI is returned. Otherwise a new relative hierarchical URI is constructed with query and fragment components taken from the given URI and with a path component computed by removing this URI's path from the beginning of the given URI's path.
Constructs a URL from this URI. This convenience method works as if invoking it were equivalent to evaluating the expression new URL(this.toString()) after first checking that this URI is absolute.
"Returns the scheme component of this URI. The scheme component of a URI, if defined, only contains characters in the alphanum category and in the string ""-.+"". A scheme always starts with an alpha character. The scheme component of a URI cannot contain escaped octets, hence this method does not perform any decoding."
Tells whether or not this URI is absolute. A URI is absolute if, and only if, it has a scheme component.
Tells whether or not this URI is opaque. A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character ('/'). An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined.
Returns the raw scheme-specific part of this URI. The scheme-specific part is never undefined, though it may be empty. The scheme-specific part of a URI only contains legal URI characters.
Returns the decoded scheme-specific part of this URI. The string returned by this method is equal to that returned by the getRawSchemeSpecificPart method except that all sequences of escaped octets are decoded.
Returns the raw authority component of this URI. The authority component of a URI, if defined, only contains the commercial-at character ('@') and characters in the unreserved, punct, escaped, and other categories. If the authority is server-based then it is further constrained to have valid user-information, host, and port components.
Returns the decoded authority component of this URI. The string returned by this method is equal to that returned by the getRawAuthority method except that all sequences of escaped octets are decoded.
Returns the raw user-information component of this URI. The user-information component of a URI, if defined, only contains characters in the unreserved, punct, escaped, and other categories.
Returns the decoded user-information component of this URI. The string returned by this method is equal to that returned by the getRawUserInfo method except that all sequences of escaped octets are decoded.
Returns the host component of this URI. The host component of a URI, if defined, will have one of the following forms: A domain name consisting of one or more labels separated by period characters ('.'), optionally followed by a period character. Each label consists of alphanum characters as well as hyphen characters ('-'), though hyphens never occur as the first or last characters in a label. The rightmost label of a domain name consisting of two or more labels, begins with an alpha character. A dotted-quad IPv4 address of the form digit+.digit+.digit+.digit+, where no digit sequence is longer than three characters and no sequence has a value larger than 255. An IPv6 address enclosed in square brackets ('[' and ']') and consisting of hexadecimal digits, colon characters (':'), and possibly an embedded IPv4 address. The full syntax of IPv6 addresses is specified in RFC 2373: IPv6 Addressing Architecture. The host component of a URI cannot contain escaped octets, hence this method does not perform any decoding.
Returns the port number of this URI. The port component of a URI, if defined, is a non-negative integer.
Returns the raw path component of this URI. The path component of a URI, if defined, only contains the slash character ('/'), the commercial-at character ('@'), and characters in the unreserved, punct, escaped, and other categories.
Returns the decoded path component of this URI. The string returned by this method is equal to that returned by the getRawPath method except that all sequences of escaped octets are decoded.
Returns the raw query component of this URI. The query component of a URI, if defined, only contains legal URI characters.
Returns the decoded query component of this URI. The string returned by this method is equal to that returned by the getRawQuery method except that all sequences of escaped octets are decoded.
Returns the raw fragment component of this URI. The fragment component of a URI, if defined, only contains legal URI characters.
Returns the decoded fragment component of this URI. The string returned by this method is equal to that returned by the getRawFragment method except that all sequences of escaped octets are decoded.
Tests this URI for equality with another object. If the given object is not a URI then this method immediately returns false. For two URIs to be considered equal requires that either both are opaque or both are hierarchical. Their schemes must either both be undefined or else be equal without regard to case. Their fragments must either both be undefined or else be equal. For two opaque URIs to be considered equal, their scheme-specific parts must be equal. For two hierarchical URIs to be considered equal, their paths must be equal and their queries must either both be undefined or else be equal. Their authorities must either both be undefined, or both be registry-based, or both be server-based. If their authorities are defined and are registry-based, then they must be equal. If their authorities are defined and are server-based, then their hosts must be equal without regard to case, their port numbers must be equal, and their user-information components must be equal. When testing the user-information, path, query, fragment, authority, or scheme-specific parts of two URIs for equality, the raw forms rather than the encoded forms of these components are compared and the hexadecimal digits of escaped octets are compared without regard to case. This method satisfies the general contract of the Object.equals method.
Returns a hash-code value for this URI. The hash code is based upon all of the URI's components, and satisfies the general contract of the Object.hashCode method.
Compares this URI to another object, which must be a URI. When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the String.compareTo method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms. The ordering of URIs is defined as follows: Two URIs with different schemes are ordered according the ordering of their schemes, without regard to case. A hierarchical URI is considered to be less than an opaque URI with an identical scheme. Two opaque URIs with identical schemes are ordered according to the ordering of their scheme-specific parts. Two opaque URIs with identical schemes and scheme-specific parts are ordered according to the ordering of their fragments. Two hierarchical URIs with identical schemes are ordered according to the ordering of their authority components: If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports. If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components. Finally, two hierarchical URIs with identical schemes and authority components are ordered according to the ordering of their paths; if their paths are identical then they are ordered according to the ordering of their queries; if the queries are identical then they are ordered according to the order of their fragments. This method satisfies the general contract of the Comparable.compareTo method.
Returns the content of this URI as a string. If this URI was created by invoking one of the constructors in this class then a string equivalent to the original input string, or to the string computed from the originally-given components, as appropriate, is returned. Otherwise this URI was created by normalization, resolution, or relativization, and so a string is constructed from this URI's components according to the rules specified in RFC 2396, section 5.2, step 7.
Returns the content of this URI as a US-ASCII string. If this URI does not contain any characters in the other category then an invocation of this method will return the same value as an invocation of the toString method. Otherwise this method works as if by invoking that method and then encoding the result.
Constructs an instance from the given input string, reason, and error index.
Constructs an instance from the given input string and reason. The resulting object will have an error index of -1.
Returns the input string.
Returns a string explaining why the input string could not be parsed.
Returns an index into the input string of the position at which the parse error occurred, or -1 if this position is not known.
"Returns a string describing the parse error. The resulting string consists of the reason string followed by a colon character (':'), a space, and the input string. If the error index is defined then the string "" at index "" followed by the index, in decimal, is inserted after the reason string and before the colon character."
Creates a URL object from the specified protocol, host, port number, and file. host can be expressed as a host name or a literal IP address. If IPv6 literal address is used, it should be enclosed in square brackets ('[' and ']'), as specified by RFC 2732; However, the literal IPv6 address format defined in RFC 2373: IP Version 6 Addressing Architecture is also accepted. Specifying a port number of -1 indicates that the URL should use the default port for the protocol. If this is the first URL object being created with the specified protocol, a stream protocol handler object, an instance of class URLStreamHandler, is created for that protocol: If the application has previously set up an instance of URLStreamHandlerFactory as the stream handler factory, then the createURLStreamHandler method of that instance is called with the protocol string as an argument to create the stream protocol handler. If no URLStreamHandlerFactory has yet been set up, or if the factory's createURLStreamHandler method returns null, then the constructor finds the value of the system property: java.protocol.handler.pkgs If the value of that system property is not null, it is interpreted as a list of packages separated by a vertical slash character '|'. The constructor tries to load the class named: <package>.<protocol>.Handler where <package> is replaced by the name of the package and <protocol> is replaced by the name of the protocol. If this class does not exist, or if the class exists but it is not a subclass of URLStreamHandler, then the next package in the list is tried. If the previous step fails to find a protocol handler, then the constructor tries to load from a system default package. <system default package>.<protocol>.Handler If this class does not exist, or if the class exists but it is not a subclass of URLStreamHandler, then a MalformedURLException is thrown. Protocol handlers for the following protocols are guaranteed to exist on the search path :- http, https, file, and jar Protocol handlers for additional protocols may also be available. No validation of the inputs is performed by this constructor.
Creates a URL from the specified protocol name, host name, and file name. The default port for the specified protocol is used. This method is equivalent to calling the four-argument constructor with the arguments being protocol, host, -1, and file. No validation of the inputs is performed by this constructor.
"Creates a URL object from the specified protocol, host, port number, file, and handler. Specifying a port number of -1 indicates that the URL should use the default port for the protocol. Specifying a handler of null indicates that the URL should use a default stream handler for the protocol, as outlined for: java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String) If the handler is not null and there is a security manager, the security manager's checkPermission method is called with a NetPermission(""specifyStreamHandler"") permission. This may result in a SecurityException. No validation of the inputs is performed by this constructor."
Creates a URL object from the String representation. This constructor is equivalent to a call to the two-argument constructor with a null first argument.
"Creates a URL by parsing the given spec within a specified context. The new URL is created from the given context URL and the spec argument as described in RFC2396 ""Uniform Resource Identifiers : Generic * Syntax"" : <scheme>://<authority><path>?<query>#<fragment> The reference is parsed into the scheme, authority, path, query and fragment parts. If the path component is empty and the scheme, authority, and query components are undefined, then the new URL is a reference to the current document. Otherwise, the fragment and query parts present in the spec are used in the new URL. If the scheme component is defined in the given spec and does not match the scheme of the context, then the new URL is created as an absolute URL based on the spec alone. Otherwise the scheme component is inherited from the context URL. If the authority component is present in the spec then the spec is treated as absolute and the spec authority and path will replace the context authority and path. If the authority component is absent in the spec then the authority of the new URL will be inherited from the context. If the spec's path component begins with a slash character ""/"" then the path is treated as absolute and the spec path replaces the context path. Otherwise, the path is treated as a relative path and is appended to the context path, as described in RFC2396. Also, in this case, the path is canonicalized through the removal of directory changes made by occurrences of "".."" and ""."". For a more detailed description of URL parsing, refer to RFC2396."
Creates a URL by parsing the given spec with the specified handler within a specified context. If the handler is null, the parsing occurs as with the two argument constructor.
Gets the query part of this URL.
Gets the path part of this URL.
Gets the userInfo part of this URL.
Gets the authority part of this URL.
Gets the port number of this URL.
Gets the default port number of the protocol associated with this URL. If the URL scheme or the URLStreamHandler for the URL do not define a default port number, then -1 is returned.
Gets the protocol name of this URL.
Gets the host name of this URL, if applicable. The format of the host conforms to RFC 2732, i.e. for a literal IPv6 address, this method will return the IPv6 address enclosed in square brackets ('[' and ']').
Gets the file name of this URL. The returned file portion will be the same as getPath(), plus the concatenation of the value of getQuery(), if any. If there is no query portion, this method and getPath() will return identical results.
"Gets the anchor (also known as the ""reference"") of this URL."
Compares this URL for equality with another object. If the given object is not a URL then this method immediately returns false. Two URL objects are equal if they have the same protocol, reference equivalent hosts, have the same port number on the host, and the same file and fragment of the file. Two hosts are considered equivalent if both host names can be resolved into the same IP addresses; else if either host name can't be resolved, the host names must be equal without regard to case; or both host names equal to null. Since hosts comparison requires name resolution, this operation is a blocking operation. Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP.
Creates an integer suitable for hash table indexing. The hash code is based upon all the URL components relevant for URL comparison. As such, this operation is a blocking operation.
Compares two URLs, excluding the fragment component. Returns true if this URL and the other argument are equal without taking the fragment component into consideration.
Constructs a string representation of this URL. The string is created by calling the toExternalForm method of the stream protocol handler for this object.
Constructs a string representation of this URL. The string is created by calling the toExternalForm method of the stream protocol handler for this object.
Returns a URI equivalent to this URL. This method functions in the same way as new URI (this.toString()). Note, any URL instance that complies with RFC 2396 can be converted to a URI. However, some URLs that are not strictly in compliance can not be converted to a URI.
Returns a URLConnection instance that represents a connection to the remote object referred to by the URL. A new instance of URLConnection is created every time when invoking the URLStreamHandler.openConnection(URL) method of the protocol handler for this URL. It should be noted that a URLConnection instance does not establish the actual network connection on creation. This will happen only when calling URLConnection.connect(). If for the URL's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.
Same as openConnection(), except that the connection will be made through the specified proxy; Protocol handlers that do not support proxing will ignore the proxy parameter and make a normal connection. Invoking this method preempts the system's default ProxySelector settings.
Opens a connection to this URL and returns an InputStream for reading from that connection. This method is a shorthand for: openConnection().getInputStream()
Gets the contents of this URL. This method is a shorthand for: openConnection().getContent()
Gets the contents of this URL. This method is a shorthand for: openConnection().getContent(Class[])
Sets an application's URLStreamHandlerFactory. This method can be called at most once in a given Java Virtual Machine. The URLStreamHandlerFactory instance is used to construct a stream protocol handler from a protocol name. If there is a security manager, this method first calls the security manager's checkSetFactory method to ensure the operation is allowed. This could result in a SecurityException.
Constructs a new URLClassLoader for the given URLs. The URLs will be searched in the order specified for classes and resources after first searching in the specified parent class loader. Any URL that ends with a '/' is assumed to refer to a directory. Otherwise, the URL is assumed to refer to a JAR file which will be downloaded and opened as needed. If there is a security manager, this method first calls the security manager's checkCreateClassLoader method to ensure creation of a class loader is allowed.
Constructs a new URLClassLoader for the specified URLs using the default delegation parent ClassLoader. The URLs will be searched in the order specified for classes and resources after first searching in the parent class loader. Any URL that ends with a '/' is assumed to refer to a directory. Otherwise, the URL is assumed to refer to a JAR file which will be downloaded and opened as needed. If there is a security manager, this method first calls the security manager's checkCreateClassLoader method to ensure creation of a class loader is allowed.
Constructs a new URLClassLoader for the specified URLs, parent class loader, and URLStreamHandlerFactory. The parent argument will be used as the parent class loader for delegation. The factory argument will be used as the stream handler factory to obtain protocol handlers when creating new jar URLs. If there is a security manager, this method first calls the security manager's checkCreateClassLoader method to ensure creation of a class loader is allowed.
Returns an input stream for reading the specified resource. If this loader is closed, then any resources opened by this method will be closed. The search order is described in the documentation for ClassLoader.getResource(String).
Closes this URLClassLoader, so that it can no longer be used to load new classes or resources that are defined by this loader. Classes and resources defined by any of this loader's parents in the delegation hierarchy are still accessible. Also, any classes or resources that are already loaded, are still accessible. In the case of jar: and file: URLs, it also closes any files that were opened by it. If another thread is loading a class when the close method is invoked, then the result of that load is undefined. The method makes a best effort attempt to close all opened files, by catching IOExceptions internally. Unchecked exceptions and errors are not caught. Calling close on an already closed loader has no effect.
Appends the specified URL to the list of URLs to search for classes and resources. If the URL specified is null or is already in the list of URLs, or if this loader is closed, then invoking this method has no effect.
Returns the search path of URLs for loading classes and resources. This includes the original list of URLs specified to the constructor, along with any URLs subsequently appended by the addURL() method.
Finds and loads the class with the specified name from the URL search path. Any URLs referring to JAR files are loaded and opened as needed until the class is found.
Defines a new package by name in this ClassLoader. The attributes contained in the specified Manifest will be used to obtain package version and sealing information. For sealed packages, the additional URL specifies the code source URL from which the package was loaded.
Finds the resource with the specified name on the URL search path.
Returns an Enumeration of URLs representing all of the resources on the URL search path having the specified name.
"Returns the permissions for the given codesource object. The implementation of this method first calls super.getPermissions and then adds permissions based on the URL of the codesource. If the protocol of this URL is ""jar"", then the permission granted is based on the permission that is required by the URL of the Jar file. If the protocol is ""file"" and there is an authority component, then permission to connect to and accept connections from that authority may be granted. If the protocol is ""file"" and the path specifies a file, then permission to read that file is granted. If protocol is ""file"" and the path is a directory, permission is granted to read all files and (recursively) all files and subdirectories contained in that directory. If the protocol is not ""file"", then permission to connect to and accept connections from the URL's host is granted."
Creates a new instance of URLClassLoader for the specified URLs and parent class loader. If a security manager is installed, the loadClass method of the URLClassLoader returned by this method will invoke the SecurityManager.checkPackageAccess method before loading the class.
Creates a new instance of URLClassLoader for the specified URLs and default parent class loader. If a security manager is installed, the loadClass method of the URLClassLoader returned by this method will invoke the SecurityManager.checkPackageAccess before loading the class.
The URL represents the remote object on the World Wide Web to which this connection is opened. The value of this field can be accessed by the getURL method. The default value of this variable is the value of the URL argument in the URLConnection constructor.
This variable is set by the setDoInput method. Its value is returned by the getDoInput method. A URL connection can be used for input and/or output. Setting the doInput flag to true indicates that the application intends to read data from the URL connection. The default value of this field is true.
This variable is set by the setDoOutput method. Its value is returned by the getDoOutput method. A URL connection can be used for input and/or output. Setting the doOutput flag to true indicates that the application intends to write data to the URL connection. The default value of this field is false.
If true, this URL is being examined in a context in which it makes sense to allow user interactions such as popping up an authentication dialog. If false, then no user interaction is allowed. The value of this field can be set by the setAllowUserInteraction method. Its value is returned by the getAllowUserInteraction method. Its default value is the value of the argument in the last invocation of the setDefaultAllowUserInteraction method.
If true, the protocol is allowed to use caching whenever it can. If false, the protocol must always try to get a fresh copy of the object. This field is set by the setUseCaches method. Its value is returned by the getUseCaches method. Its default value is the value given in the last invocation of the setDefaultUseCaches method.
Some protocols support skipping the fetching of the object unless the object has been modified more recently than a certain time. A nonzero value gives a time as the number of milliseconds since January 1, 1970, GMT. The object is fetched only if it has been modified more recently than that time. This variable is set by the setIfModifiedSince method. Its value is returned by the getIfModifiedSince method. The default value of this field is 0, indicating that the fetching must always occur.
If false, this connection object has not created a communications link to the specified URL. If true, the communications link has been established.
Constructs a URL connection to the specified URL. A connection to the object referenced by the URL is not created.
"Loads filename map (a mimetable) from a data file. It will first try to load the user-specific table, defined by ""content.types.user.table"" property. If that fails, it tries to load the default built-in table."
Sets the FileNameMap. If there is a security manager, this method first calls the security manager's checkSetFactory method to ensure the operation is allowed. This could result in a SecurityException.
Opens a communications link to the resource referenced by this URL, if such a connection has not already been established. If the connect method is called when the connection has already been opened (indicated by the connected field having the value true), the call is ignored. URLConnection objects go through two phases: first they are created, then they are connected. After being created, and before being connected, various options can be specified (e.g., doInput and UseCaches). After connecting, it is an error to try to set them. Operations that depend on being connected, like getContentLength, will implicitly perform the connection, if necessary.
Sets a specified timeout value, in milliseconds, to be used when opening a communications link to the resource referenced by this URLConnection. If the timeout expires before the connection can be established, a java.net.SocketTimeoutException is raised. A timeout of zero is interpreted as an infinite timeout. Some non-standard implementation of this method may ignore the specified timeout. To see the connect timeout set, please call getConnectTimeout().
Returns setting for connect timeout. 0 return implies that the option is disabled (i.e., timeout of infinity).
Sets the read timeout to a specified timeout, in milliseconds. A non-zero value specifies the timeout when reading from Input stream when a connection is established to a resource. If the timeout expires before there is data available for read, a java.net.SocketTimeoutException is raised. A timeout of zero is interpreted as an infinite timeout. Some non-standard implementation of this method ignores the specified timeout. To see the read timeout set, please call getReadTimeout().
Returns setting for read timeout. 0 return implies that the option is disabled (i.e., timeout of infinity).
Returns the value of this URLConnection's URL field.
Returns the value of the content-length header field. Note: getContentLengthLong() should be preferred over this method, since it returns a long instead and is therefore more portable.
Returns the value of the content-length header field as a long.
Returns the value of the content-type header field.
Returns the value of the content-encoding header field.
Returns the value of the expires header field.
Returns the value of the date header field.
Returns the value of the last-modified header field. The result is the number of milliseconds since January 1, 1970 GMT.
Returns the value of the named header field. If called on a connection that sets the same header multiple times with possibly different values, only the last value is returned.
Returns an unmodifiable Map of the header fields. The Map keys are Strings that represent the response-header field names. Each Map value is an unmodifiable List of Strings that represents the corresponding field values.
Returns the value of the named field parsed as a number. This form of getHeaderField exists because some connection types (e.g., http-ng) have pre-parsed headers. Classes for that connection type can override this method and short-circuit the parsing.
Returns the value of the named field parsed as a number. This form of getHeaderField exists because some connection types (e.g., http-ng) have pre-parsed headers. Classes for that connection type can override this method and short-circuit the parsing.
Returns the value of the named field parsed as date. The result is the number of milliseconds since January 1, 1970 GMT represented by the named field. This form of getHeaderField exists because some connection types (e.g., http-ng) have pre-parsed headers. Classes for that connection type can override this method and short-circuit the parsing.
Returns the key for the nth header field. It returns null if there are fewer than n+1 fields.
Returns the value for the nth header field. It returns null if there are fewer than n+1fields. This method can be used in conjunction with the getHeaderFieldKey method to iterate through all the headers in the message.
Retrieves the contents of this URL connection. This method first determines the content type of the object by calling the getContentType method. If this is the first time that the application has seen that specific content type, a content handler for that content type is created: If the application has set up a content handler factory instance using the setContentHandlerFactory method, the createContentHandler method of that instance is called with the content type as an argument; the result is a content handler for that content type. If no content handler factory has yet been set up, or if the factory's createContentHandler method returns null, then the application loads the class named: sun.net.www.content.<contentType> where <contentType> is formed by taking the content-type string, replacing all slash characters with a period ('.'), and all other non-alphanumeric characters with the underscore character '_'. The alphanumeric characters are specifically the 26 uppercase ASCII letters 'A' through 'Z', the 26 lowercase ASCII letters 'a' through 'z', and the 10 ASCII digits '0' through '9'. If the specified class does not exist, or is not a subclass of ContentHandler, then an UnknownServiceException is thrown.
Retrieves the contents of this URL connection.
Returns a permission object representing the permission necessary to make the connection represented by this object. This method returns null if no permission is required to make the connection. By default, this method returns java.security.AllPermission. Subclasses should override this method and return the permission that best represents the permission required to make a a connection to the URL. For example, a URLConnection representing a file: URL would return a java.io.FilePermission object. The permission returned may dependent upon the state of the connection. For example, the permission before connecting may be different from that after connecting. For example, an HTTP sever, say foo.com, may redirect the connection to a different host, say bar.com. Before connecting the permission returned by the connection will represent the permission needed to connect to foo.com, while the permission returned after connecting will be to bar.com. Permissions are generally used for two purposes: to protect caches of objects obtained through URLConnections, and to check the right of a recipient to learn about a particular URL. In the first case, the permission should be obtained after the object has been obtained. For example, in an HTTP connection, this will represent the permission to connect to the host from which the data was ultimately fetched. In the second case, the permission should be obtained and tested before connecting.
Returns an input stream that reads from this open connection. A SocketTimeoutException can be thrown when reading from the returned input stream if the read timeout expires before data is available for read.
Returns an output stream that writes to this connection.
Returns a String representation of this URL connection.
Sets the value of the doInput field for this URLConnection to the specified value. A URL connection can be used for input and/or output. Set the DoInput flag to true if you intend to use the URL connection for input, false if not. The default is true.
Returns the value of this URLConnection's doInput flag.
Sets the value of the doOutput field for this URLConnection to the specified value. A URL connection can be used for input and/or output. Set the DoOutput flag to true if you intend to use the URL connection for output, false if not. The default is false.
Returns the value of this URLConnection's doOutput flag.
Set the value of the allowUserInteraction field of this URLConnection.
Returns the value of the allowUserInteraction field for this object.
Sets the default value of the allowUserInteraction field for all future URLConnection objects to the specified value.
"Returns the default value of the allowUserInteraction field. Ths default is ""sticky"", being a part of the static state of all URLConnections. This flag applies to the next, and all following URLConnections that are created."
"Sets the value of the useCaches field of this URLConnection to the specified value. Some protocols do caching of documents. Occasionally, it is important to be able to ""tunnel through"" and ignore the caches (e.g., the ""reload"" button in a browser). If the UseCaches flag on a connection is true, the connection is allowed to use whatever caches it can. If false, caches are to be ignored. The default value comes from DefaultUseCaches, which defaults to true."
Returns the value of this URLConnection's useCaches field.
Sets the value of the ifModifiedSince field of this URLConnection to the specified value.
Returns the value of this object's ifModifiedSince field.
"Returns the default value of a URLConnection's useCaches flag. Ths default is ""sticky"", being a part of the static state of all URLConnections. This flag applies to the next, and all following URLConnections that are created."
Sets the default value of the useCaches field to the specified value.
Sets the general request property. If a property with the key already exists, overwrite its value with the new value. NOTE: HTTP requires all request properties which can legally have multiple instances with the same key to use a comma-separated list syntax which enables multiple properties to be appended into a single property.
Adds a general request property specified by a key-value pair. This method will not overwrite existing values associated with the same key.
Returns the value of the named general request property for this connection.
Returns an unmodifiable Map of general request properties for this connection. The Map keys are Strings that represent the request-header field names. Each Map value is a unmodifiable List of Strings that represents the corresponding field values.
Sets the default value of a general request property. When a URLConnection is created, it is initialized with these properties.
Returns the value of the default request property. Default request properties are set for every connection.
Sets the ContentHandlerFactory of an application. It can be called at most once by an application. The ContentHandlerFactory instance is used to construct a content handler from a content type If there is a security manager, this method first calls the security manager's checkSetFactory method to ensure the operation is allowed. This could result in a SecurityException.
"Tries to determine the content type of an object, based on the specified ""file"" component of a URL. This is a convenience method that can be used by subclasses that override the getContentType method."
Tries to determine the type of an input stream based on the characters at the beginning of the input stream. This method can be used by subclasses that override the getContentType method. Ideally, this routine would not be needed. But many http servers return the incorrect content type; in addition, there are many nonstandard extensions. Direct inspection of the bytes to determine the content type is often more accurate than believing the content type claimed by the http server.
"Decodes a x-www-form-urlencoded string. The platform's default encoding is used to determine what characters are represented by any consecutive sequences of the form ""%xy""."
"Decodes a application/x-www-form-urlencoded string using a specific encoding scheme. The supplied encoding is used to determine what characters are represented by any consecutive sequences of the form ""%xy"". Note: The World Wide Web Consortium Recommendation states that UTF-8 should be used. Not doing so may introduce incompatibilities."
Translates a string into x-www-form-urlencoded format. This method uses the platform's default encoding as the encoding scheme to obtain the bytes for unsafe characters.
Translates a string into application/x-www-form-urlencoded format using a specific encoding scheme. This method uses the supplied encoding scheme to obtain the bytes for unsafe characters. Note: The World Wide Web Consortium Recommendation states that UTF-8 should be used. Not doing so may introduce incompatibilities.
Creates a new URLPermission from a url string and which permits the given request methods and user-settable request headers. The name of the permission is the url string it was created with. Only the scheme, authority and path components of the url are used internally. Any fragment or query components are ignored. The permissions action string is as specified above.
"Creates a URLPermission with the given url string and unrestricted methods and request headers by invoking the two argument constructor as follows: URLPermission(url, ""*:*"")"
"Returns the normalized method list and request header list, in the form: ""method-names : header-names"" where method-names is the list of methods separated by commas and header-names is the list of permitted headers separated by commas. There is no white space in the returned String. If header-names is empty then the colon separator will not be present."
"Checks if this URLPermission implies the given permission. Specifically, the following checks are done as if in the following sequence: if 'p' is not an instance of URLPermission return false if any of p's methods are not in this's method list, and if this's method list is not equal to ""*"", then return false. if any of p's headers are not in this's request header list, and if this's request header list is not equal to ""*"", then return false. if this's url scheme is not equal to p's url scheme return false if the scheme specific part of this's url is '*' return true if the set of hosts defined by p's url hostrange is not a subset of this's url hostrange then return false. For example, ""*.foo.oracle.com"" is a subset of ""*.oracle.com"". ""foo.bar.oracle.com"" is not a subset of ""*.foo.oracle.com"" if the portrange defined by p's url is not a subset of the portrange defined by this's url then return false. if the path or paths specified by p's url are contained in the set of paths specified by this's url, then return true otherwise, return false Some examples of how paths are matched are shown below: Examples of Path Matching this's pathp's pathmatch /a/b/a/byes /a/b/*/a/b/cyes /a/b/*/a/b/c/dno /a/b/-/a/b/c/dyes /a/b/-/a/b/c/d/eyes /a/b/-/a/b/c/*yes /a/b/*/a/b/c/-no"
Returns true if, this.getActions().equals(p.getActions()) and p's url equals this's url. Returns false otherwise.
Returns a hashcode calculated from the hashcode of the actions String and the url string.
Opens a connection to the object referenced by the URL argument. This method should be overridden by a subclass. If for the handler's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.
Same as openConnection(URL), except that the connection will be made through the specified proxy; Protocol handlers that do not support proxying will ignore the proxy parameter and make a normal connection. Calling this method preempts the system's default ProxySelector settings.
Parses the string representation of a URL into a URL object. If there is any inherited context, then it has already been copied into the URL argument. The parseURL method of URLStreamHandler parses the string representation as if it were an http specification. Most URL protocol families have a similar parsing. A stream protocol handler for a protocol that has a different syntax must override this routine.
Returns the default port for a URL parsed by this handler. This method is meant to be overidden by handlers with default port numbers.
Provides the default equals calculation. May be overidden by handlers for other protocols that have different requirements for equals(). This method requires that none of its arguments is null. This is guaranteed by the fact that it is only called by java.net.URL class.
Provides the default hash calculation. May be overidden by handlers for other protocols that have different requirements for hashCode calculation.
Compare two urls to see whether they refer to the same file, i.e., having the same protocol, host, port, and path. This method requires that none of its arguments is null. This is guaranteed by the fact that it is only called indirectly by java.net.URL class.
Get the IP address of our host. An empty host field or a DNS failure will result in a null return.
Compares the host components of two URLs.
Converts a URL of a specific protocol to a String.
Sets the fields of the URL argument to the indicated values. Only classes derived from URLStreamHandler are able to use this method to set the values of the URL fields.
Sets the fields of the URL argument to the indicated values. Only classes derived from URLStreamHandler are able to use this method to set the values of the URL fields.
Creates a new URLStreamHandler instance with the specified protocol.
Returns this buffer's capacity.
Returns this buffer's position.
Sets this buffer's position. If the mark is defined and larger than the new position then it is discarded.
Returns this buffer's limit.
Sets this buffer's limit. If the position is larger than the new limit then it is set to the new limit. If the mark is defined and larger than the new limit then it is discarded.
Sets this buffer's mark at its position.
Resets this buffer's position to the previously-marked position. Invoking this method neither changes nor discards the mark's value.
Clears this buffer. The position is set to zero, the limit is set to the capacity, and the mark is discarded. Invoke this method before using a sequence of channel-read or put operations to fill this buffer. For example: buf.clear(); // Prepare buffer for reading in.read(buf); // Read data This method does not actually erase the data in the buffer, but it is named as if it did because it will most often be used in situations in which that might as well be the case.
Flips this buffer. The limit is set to the current position and then the position is set to zero. If the mark is defined then it is discarded. After a sequence of channel-read or put operations, invoke this method to prepare for a sequence of channel-write or relative get operations. For example: buf.put(magic); // Prepend header in.read(buf); // Read data into rest of buffer buf.flip(); // Flip buffer out.write(buf); // Write header + data to channel This method is often used in conjunction with the compact method when transferring data from one place to another.
Rewinds this buffer. The position is set to zero and the mark is discarded. Invoke this method before a sequence of channel-write or get operations, assuming that the limit has already been set appropriately. For example: out.write(buf); // Write remaining data buf.rewind(); // Rewind buffer buf.get(array); // Copy data into array
Returns the number of elements between the current position and the limit.
Tells whether there are any elements between the current position and the limit.
Tells whether or not this buffer is read-only.
Tells whether or not this buffer is backed by an accessible array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the array that backs this buffer (optional operation). This method is intended to allow array-backed buffers to be passed to native code more efficiently. Concrete subclasses provide more strongly-typed return values for this method. Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Tells whether or not this buffer is direct.
Constructs an instance of this class.
Constructs an instance of this class.
Allocates a new direct byte buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. Whether or not it has a backing array is unspecified.
Allocates a new byte buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
Wraps a byte array into a buffer. The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.
Wraps a byte array into a buffer. The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be array.length, its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset> will be zero.
Creates a new byte buffer whose content is a shared subsequence of this buffer's content. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new byte buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new, read-only byte buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.
Relative get method. Reads the byte at this buffer's current position, and then increments the position.
Relative put method (optional operation). Writes the given byte into this buffer at the current position, and then increments the position.
Absolute get method. Reads the byte at the given index.
Absolute put method (optional operation). Writes the given byte into this buffer at the given index.
Relative bulk get method. This method transfers bytes from this buffer into the given destination array. If there are fewer bytes remaining in the buffer than are required to satisfy the request, that is, if length > remaining(), then no bytes are transferred and a BufferUnderflowException is thrown. Otherwise, this method copies length bytes from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form src.get(dst, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst[i] = src.get(): except that it first checks that there are sufficient bytes in this buffer and it is potentially much more efficient.
Relative bulk get method. This method transfers bytes from this buffer into the given destination array. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation src.get(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers the bytes remaining in the given source buffer into this buffer. If there are more bytes remaining in the source buffer than in this buffer, that is, if src.remaining() > remaining(), then no bytes are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = src.remaining() bytes from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n. In other words, an invocation of this method of the form dst.put(src) has exactly the same effect as the loop while (src.hasRemaining()) dst.put(src.get()); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers bytes into this buffer from the given source array. If there are more bytes to be copied from the array than remain in this buffer, that is, if length > remaining(), then no bytes are transferred and a BufferOverflowException is thrown. Otherwise, this method copies length bytes from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form dst.put(src, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst.put(a[i]); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source byte array into this buffer. An invocation of this method of the form dst.put(a) behaves in exactly the same way as the invocation dst.put(a, 0, a.length)
Tells whether or not this buffer is backed by an accessible byte array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the byte array that backs this buffer (optional operation). Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Compacts this buffer (optional operation). The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = position() is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index limit() - 1 is copied to index n = limit() - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method. Invoke this method after writing data from a buffer in case the write was incomplete. The following loop, for example, copies bytes from one channel to another via the buffer buf: buf.clear(); // Prepare buffer for use while (in.read(buf) >= 0 || buf.position != 0) { buf.flip(); out.write(buf); buf.compact(); // In case of partial write }
Tells whether or not this byte buffer is direct.
Returns a string summarizing the state of this buffer.
Returns the current hash code of this buffer. The hash code of a byte buffer depends only upon its remaining elements; that is, upon the elements from position() up to, and including, the element at limit() - 1. Because buffer hash codes are content-dependent, it is inadvisable to use buffers as keys in hash maps or similar data structures unless it is known that their contents will not change.
Tells whether or not this buffer is equal to another object. Two byte buffers are equal if, and only if, They have the same element type, They have the same number of remaining elements, and The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. A byte buffer is not equal to any other type of object.
Compares this buffer to another. Two byte buffers are compared by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. Pairs of byte elements are compared as if by invoking Byte.compare(byte,byte). A byte buffer is not comparable to any other type of object.
Retrieves this buffer's byte order. The byte order is used when reading or writing multibyte values, and when creating buffers that are views of this byte buffer. The order of a newly-created byte buffer is always BIG_ENDIAN.
Modifies this buffer's byte order.
Relative get method for reading a char value. Reads the next two bytes at this buffer's current position, composing them into a char value according to the current byte order, and then increments the position by two.
Relative put method for writing a char value (optional operation). Writes two bytes containing the given char value, in the current byte order, into this buffer at the current position, and then increments the position by two.
Absolute get method for reading a char value. Reads two bytes at the given index, composing them into a char value according to the current byte order.
Absolute put method for writing a char value (optional operation). Writes two bytes containing the given char value, in the current byte order, into this buffer at the given index.
Creates a view of this byte buffer as a char buffer. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Relative get method for reading a short value. Reads the next two bytes at this buffer's current position, composing them into a short value according to the current byte order, and then increments the position by two.
Relative put method for writing a short value (optional operation). Writes two bytes containing the given short value, in the current byte order, into this buffer at the current position, and then increments the position by two.
Absolute get method for reading a short value. Reads two bytes at the given index, composing them into a short value according to the current byte order.
Absolute put method for writing a short value (optional operation). Writes two bytes containing the given short value, in the current byte order, into this buffer at the given index.
Creates a view of this byte buffer as a short buffer. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Relative get method for reading an int value. Reads the next four bytes at this buffer's current position, composing them into an int value according to the current byte order, and then increments the position by four.
Relative put method for writing an int value (optional operation). Writes four bytes containing the given int value, in the current byte order, into this buffer at the current position, and then increments the position by four.
Absolute get method for reading an int value. Reads four bytes at the given index, composing them into a int value according to the current byte order.
Absolute put method for writing an int value (optional operation). Writes four bytes containing the given int value, in the current byte order, into this buffer at the given index.
Creates a view of this byte buffer as an int buffer. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Relative get method for reading a long value. Reads the next eight bytes at this buffer's current position, composing them into a long value according to the current byte order, and then increments the position by eight.
Relative put method for writing a long value (optional operation). Writes eight bytes containing the given long value, in the current byte order, into this buffer at the current position, and then increments the position by eight.
Absolute get method for reading a long value. Reads eight bytes at the given index, composing them into a long value according to the current byte order.
Absolute put method for writing a long value (optional operation). Writes eight bytes containing the given long value, in the current byte order, into this buffer at the given index.
Creates a view of this byte buffer as a long buffer. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Relative get method for reading a float value. Reads the next four bytes at this buffer's current position, composing them into a float value according to the current byte order, and then increments the position by four.
Relative put method for writing a float value (optional operation). Writes four bytes containing the given float value, in the current byte order, into this buffer at the current position, and then increments the position by four.
Absolute get method for reading a float value. Reads four bytes at the given index, composing them into a float value according to the current byte order.
Absolute put method for writing a float value (optional operation). Writes four bytes containing the given float value, in the current byte order, into this buffer at the given index.
Creates a view of this byte buffer as a float buffer. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Relative get method for reading a double value. Reads the next eight bytes at this buffer's current position, composing them into a double value according to the current byte order, and then increments the position by eight.
Relative put method for writing a double value (optional operation). Writes eight bytes containing the given double value, in the current byte order, into this buffer at the current position, and then increments the position by eight.
Absolute get method for reading a double value. Reads eight bytes at the given index, composing them into a double value according to the current byte order.
Absolute put method for writing a double value (optional operation). Writes eight bytes containing the given double value, in the current byte order, into this buffer at the given index.
Creates a view of this byte buffer as a double buffer. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Constant denoting big-endian byte order. In this order, the bytes of a multibyte value are ordered from most significant to least significant.
Constant denoting little-endian byte order. In this order, the bytes of a multibyte value are ordered from least significant to most significant.
Retrieves the native byte order of the underlying platform. This method is defined so that performance-sensitive Java code can allocate direct buffers with the same byte order as the hardware. Native code libraries are often more efficient when such buffers are used.
"Constructs a string describing this object. This method returns the string ""BIG_ENDIAN"" for BIG_ENDIAN and ""LITTLE_ENDIAN"" for LITTLE_ENDIAN."
Allocates a new char buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
Wraps a char array into a buffer. The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.
Wraps a char array into a buffer. The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be array.length, its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset> will be zero.
Attempts to read characters into the specified character buffer. The buffer is used as a repository of characters as-is: the only changes made are the results of a put operation. No flipping or rewinding of the buffer is performed.
Wraps a character sequence into a buffer. The content of the new, read-only buffer will be the content of the given character sequence. The buffer's capacity will be csq.length(), its position will be start, its limit will be end, and its mark will be undefined.
Wraps a character sequence into a buffer. The content of the new, read-only buffer will be the content of the given character sequence. The new buffer's capacity and limit will be csq.length(), its position will be zero, and its mark will be undefined.
Creates a new char buffer whose content is a shared subsequence of this buffer's content. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of chars remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new char buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new, read-only char buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.
Relative get method. Reads the char at this buffer's current position, and then increments the position.
Relative put method (optional operation). Writes the given char into this buffer at the current position, and then increments the position.
Absolute get method. Reads the char at the given index.
Absolute put method (optional operation). Writes the given char into this buffer at the given index.
Relative bulk get method. This method transfers chars from this buffer into the given destination array. If there are fewer chars remaining in the buffer than are required to satisfy the request, that is, if length > remaining(), then no chars are transferred and a BufferUnderflowException is thrown. Otherwise, this method copies length chars from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form src.get(dst, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst[i] = src.get(): except that it first checks that there are sufficient chars in this buffer and it is potentially much more efficient.
Relative bulk get method. This method transfers chars from this buffer into the given destination array. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation src.get(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers the chars remaining in the given source buffer into this buffer. If there are more chars remaining in the source buffer than in this buffer, that is, if src.remaining() > remaining(), then no chars are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = src.remaining() chars from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n. In other words, an invocation of this method of the form dst.put(src) has exactly the same effect as the loop while (src.hasRemaining()) dst.put(src.get()); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers chars into this buffer from the given source array. If there are more chars to be copied from the array than remain in this buffer, that is, if length > remaining(), then no chars are transferred and a BufferOverflowException is thrown. Otherwise, this method copies length chars from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form dst.put(src, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst.put(a[i]); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source char array into this buffer. An invocation of this method of the form dst.put(a) behaves in exactly the same way as the invocation dst.put(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers chars from the given string into this buffer. If there are more chars to be copied from the string than remain in this buffer, that is, if end - start > remaining(), then no chars are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = end - start chars from the given string into this buffer, starting at the given start index and at the current position of this buffer. The position of this buffer is then incremented by n. In other words, an invocation of this method of the form dst.put(src, start, end) has exactly the same effect as the loop for (int i = start; i < end; i++) dst.put(src.charAt(i)); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source string into this buffer. An invocation of this method of the form dst.put(s) behaves in exactly the same way as the invocation dst.put(s, 0, s.length())
Tells whether or not this buffer is backed by an accessible char array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the char array that backs this buffer (optional operation). Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Compacts this buffer (optional operation). The chars between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the char at index p = position() is copied to index zero, the char at index p + 1 is copied to index one, and so forth until the char at index limit() - 1 is copied to index n = limit() - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer's position is set to the number of chars copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.
Tells whether or not this char buffer is direct.
Returns the current hash code of this buffer. The hash code of a char buffer depends only upon its remaining elements; that is, upon the elements from position() up to, and including, the element at limit() - 1. Because buffer hash codes are content-dependent, it is inadvisable to use buffers as keys in hash maps or similar data structures unless it is known that their contents will not change.
Tells whether or not this buffer is equal to another object. Two char buffers are equal if, and only if, They have the same element type, They have the same number of remaining elements, and The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. A char buffer is not equal to any other type of object.
Compares this buffer to another. Two char buffers are compared by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. Pairs of char elements are compared as if by invoking Character.compare(char,char). A char buffer is not comparable to any other type of object.
Returns a string containing the characters in this buffer. The first character of the resulting string will be the character at this buffer's position, while the last character will be the character at index limit() - 1. Invoking this method does not change the buffer's position.
Returns the length of this character buffer. When viewed as a character sequence, the length of a character buffer is simply the number of characters between the position (inclusive) and the limit (exclusive); that is, it is equivalent to remaining().
Reads the character at the given index relative to the current position.
Creates a new character buffer that represents the specified subsequence of this buffer, relative to the current position. The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be position() + start, and its limit will be position() + end. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Appends the specified character sequence to this buffer (optional operation). An invocation of this method of the form dst.append(csq) behaves in exactly the same way as the invocation dst.put(csq.toString()) Depending on the specification of toString for the character sequence csq, the entire sequence may not be appended. For instance, invoking the toString method of a character buffer will return a subsequence whose content depends upon the buffer's position and limit.
Appends a subsequence of the specified character sequence to this buffer (optional operation). An invocation of this method of the form dst.append(csq, start, end) when csq is not null, behaves in exactly the same way as the invocation dst.put(csq.subSequence(start, end).toString())
Appends the specified char to this buffer (optional operation). An invocation of this method of the form dst.append(c) behaves in exactly the same way as the invocation dst.put(c)
Retrieves this buffer's byte order. The byte order of a char buffer created by allocation or by wrapping an existing char array is the native order of the underlying hardware. The byte order of a char buffer created as a view of a byte buffer is that of the byte buffer at the moment that the view is created.
Returns a stream of int zero-extending the char values from this sequence. Any char which maps to a surrogate code point is passed through uninterpreted. If the sequence is mutated while the stream is being read, the result is undefined.
Allocates a new double buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
Wraps a double array into a buffer. The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.
Wraps a double array into a buffer. The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be array.length, its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset> will be zero.
Creates a new double buffer whose content is a shared subsequence of this buffer's content. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of doubles remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new double buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new, read-only double buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.
Relative get method. Reads the double at this buffer's current position, and then increments the position.
Relative put method (optional operation). Writes the given double into this buffer at the current position, and then increments the position.
Absolute get method. Reads the double at the given index.
Absolute put method (optional operation). Writes the given double into this buffer at the given index.
Relative bulk get method. This method transfers doubles from this buffer into the given destination array. If there are fewer doubles remaining in the buffer than are required to satisfy the request, that is, if length > remaining(), then no doubles are transferred and a BufferUnderflowException is thrown. Otherwise, this method copies length doubles from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form src.get(dst, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst[i] = src.get(): except that it first checks that there are sufficient doubles in this buffer and it is potentially much more efficient.
Relative bulk get method. This method transfers doubles from this buffer into the given destination array. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation src.get(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers the doubles remaining in the given source buffer into this buffer. If there are more doubles remaining in the source buffer than in this buffer, that is, if src.remaining() > remaining(), then no doubles are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = src.remaining() doubles from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n. In other words, an invocation of this method of the form dst.put(src) has exactly the same effect as the loop while (src.hasRemaining()) dst.put(src.get()); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers doubles into this buffer from the given source array. If there are more doubles to be copied from the array than remain in this buffer, that is, if length > remaining(), then no doubles are transferred and a BufferOverflowException is thrown. Otherwise, this method copies length doubles from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form dst.put(src, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst.put(a[i]); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source double array into this buffer. An invocation of this method of the form dst.put(a) behaves in exactly the same way as the invocation dst.put(a, 0, a.length)
Tells whether or not this buffer is backed by an accessible double array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the double array that backs this buffer (optional operation). Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Compacts this buffer (optional operation). The doubles between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the double at index p = position() is copied to index zero, the double at index p + 1 is copied to index one, and so forth until the double at index limit() - 1 is copied to index n = limit() - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer's position is set to the number of doubles copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.
Tells whether or not this double buffer is direct.
Returns a string summarizing the state of this buffer.
Returns the current hash code of this buffer. The hash code of a double buffer depends only upon its remaining elements; that is, upon the elements from position() up to, and including, the element at limit() - 1. Because buffer hash codes are content-dependent, it is inadvisable to use buffers as keys in hash maps or similar data structures unless it is known that their contents will not change.
Tells whether or not this buffer is equal to another object. Two double buffers are equal if, and only if, They have the same element type, They have the same number of remaining elements, and The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements a and b to be equal if (a == b) || (Double.isNaN(a) && Double.isNaN(b)). The values -0.0 and +0.0 are considered to be equal, unlike Double.equals(Object). A double buffer is not equal to any other type of object.
Compares this buffer to another. Two double buffers are compared by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. Pairs of double elements are compared as if by invoking Double.compare(double,double), except that -0.0 and 0.0 are considered to be equal. Double.NaN is considered by this method to be equal to itself and greater than all other double values (including Double.POSITIVE_INFINITY). A double buffer is not comparable to any other type of object.
Retrieves this buffer's byte order. The byte order of a double buffer created by allocation or by wrapping an existing double array is the native order of the underlying hardware. The byte order of a double buffer created as a view of a byte buffer is that of the byte buffer at the moment that the view is created.
Allocates a new float buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
Wraps a float array into a buffer. The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.
Wraps a float array into a buffer. The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be array.length, its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset> will be zero.
Creates a new float buffer whose content is a shared subsequence of this buffer's content. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of floats remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new float buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new, read-only float buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.
Relative get method. Reads the float at this buffer's current position, and then increments the position.
Relative put method (optional operation). Writes the given float into this buffer at the current position, and then increments the position.
Absolute get method. Reads the float at the given index.
Absolute put method (optional operation). Writes the given float into this buffer at the given index.
Relative bulk get method. This method transfers floats from this buffer into the given destination array. If there are fewer floats remaining in the buffer than are required to satisfy the request, that is, if length > remaining(), then no floats are transferred and a BufferUnderflowException is thrown. Otherwise, this method copies length floats from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form src.get(dst, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst[i] = src.get(): except that it first checks that there are sufficient floats in this buffer and it is potentially much more efficient.
Relative bulk get method. This method transfers floats from this buffer into the given destination array. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation src.get(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers the floats remaining in the given source buffer into this buffer. If there are more floats remaining in the source buffer than in this buffer, that is, if src.remaining() > remaining(), then no floats are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = src.remaining() floats from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n. In other words, an invocation of this method of the form dst.put(src) has exactly the same effect as the loop while (src.hasRemaining()) dst.put(src.get()); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers floats into this buffer from the given source array. If there are more floats to be copied from the array than remain in this buffer, that is, if length > remaining(), then no floats are transferred and a BufferOverflowException is thrown. Otherwise, this method copies length floats from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form dst.put(src, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst.put(a[i]); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source float array into this buffer. An invocation of this method of the form dst.put(a) behaves in exactly the same way as the invocation dst.put(a, 0, a.length)
Tells whether or not this buffer is backed by an accessible float array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the float array that backs this buffer (optional operation). Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Compacts this buffer (optional operation). The floats between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the float at index p = position() is copied to index zero, the float at index p + 1 is copied to index one, and so forth until the float at index limit() - 1 is copied to index n = limit() - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer's position is set to the number of floats copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.
Tells whether or not this float buffer is direct.
Returns a string summarizing the state of this buffer.
Returns the current hash code of this buffer. The hash code of a float buffer depends only upon its remaining elements; that is, upon the elements from position() up to, and including, the element at limit() - 1. Because buffer hash codes are content-dependent, it is inadvisable to use buffers as keys in hash maps or similar data structures unless it is known that their contents will not change.
Tells whether or not this buffer is equal to another object. Two float buffers are equal if, and only if, They have the same element type, They have the same number of remaining elements, and The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements a and b to be equal if (a == b) || (Float.isNaN(a) && Float.isNaN(b)). The values -0.0 and +0.0 are considered to be equal, unlike Float.equals(Object). A float buffer is not equal to any other type of object.
Compares this buffer to another. Two float buffers are compared by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. Pairs of float elements are compared as if by invoking Float.compare(float,float), except that -0.0 and 0.0 are considered to be equal. Float.NaN is considered by this method to be equal to itself and greater than all other float values (including Float.POSITIVE_INFINITY). A float buffer is not comparable to any other type of object.
Retrieves this buffer's byte order. The byte order of a float buffer created by allocation or by wrapping an existing float array is the native order of the underlying hardware. The byte order of a float buffer created as a view of a byte buffer is that of the byte buffer at the moment that the view is created.
Allocates a new int buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
Wraps an int array into a buffer. The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.
Wraps an int array into a buffer. The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be array.length, its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset> will be zero.
Creates a new int buffer whose content is a shared subsequence of this buffer's content. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of ints remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new int buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new, read-only int buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.
Relative get method. Reads the int at this buffer's current position, and then increments the position.
Relative put method (optional operation). Writes the given int into this buffer at the current position, and then increments the position.
Absolute get method. Reads the int at the given index.
Absolute put method (optional operation). Writes the given int into this buffer at the given index.
Relative bulk get method. This method transfers ints from this buffer into the given destination array. If there are fewer ints remaining in the buffer than are required to satisfy the request, that is, if length > remaining(), then no ints are transferred and a BufferUnderflowException is thrown. Otherwise, this method copies length ints from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form src.get(dst, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst[i] = src.get(): except that it first checks that there are sufficient ints in this buffer and it is potentially much more efficient.
Relative bulk get method. This method transfers ints from this buffer into the given destination array. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation src.get(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers the ints remaining in the given source buffer into this buffer. If there are more ints remaining in the source buffer than in this buffer, that is, if src.remaining() > remaining(), then no ints are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = src.remaining() ints from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n. In other words, an invocation of this method of the form dst.put(src) has exactly the same effect as the loop while (src.hasRemaining()) dst.put(src.get()); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers ints into this buffer from the given source array. If there are more ints to be copied from the array than remain in this buffer, that is, if length > remaining(), then no ints are transferred and a BufferOverflowException is thrown. Otherwise, this method copies length ints from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form dst.put(src, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst.put(a[i]); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source int array into this buffer. An invocation of this method of the form dst.put(a) behaves in exactly the same way as the invocation dst.put(a, 0, a.length)
Tells whether or not this buffer is backed by an accessible int array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the int array that backs this buffer (optional operation). Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Compacts this buffer (optional operation). The ints between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the int at index p = position() is copied to index zero, the int at index p + 1 is copied to index one, and so forth until the int at index limit() - 1 is copied to index n = limit() - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer's position is set to the number of ints copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.
Tells whether or not this int buffer is direct.
Returns a string summarizing the state of this buffer.
Returns the current hash code of this buffer. The hash code of a int buffer depends only upon its remaining elements; that is, upon the elements from position() up to, and including, the element at limit() - 1. Because buffer hash codes are content-dependent, it is inadvisable to use buffers as keys in hash maps or similar data structures unless it is known that their contents will not change.
Tells whether or not this buffer is equal to another object. Two int buffers are equal if, and only if, They have the same element type, They have the same number of remaining elements, and The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. A int buffer is not equal to any other type of object.
Compares this buffer to another. Two int buffers are compared by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. Pairs of int elements are compared as if by invoking Integer.compare(int,int). A int buffer is not comparable to any other type of object.
Retrieves this buffer's byte order. The byte order of an int buffer created by allocation or by wrapping an existing int array is the native order of the underlying hardware. The byte order of an int buffer created as a view of a byte buffer is that of the byte buffer at the moment that the view is created.
Constructs an instance of this class.
Allocates a new long buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
Wraps a long array into a buffer. The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.
Wraps a long array into a buffer. The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be array.length, its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset> will be zero.
Creates a new long buffer whose content is a shared subsequence of this buffer's content. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of longs remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new long buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new, read-only long buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.
Relative get method. Reads the long at this buffer's current position, and then increments the position.
Relative put method (optional operation). Writes the given long into this buffer at the current position, and then increments the position.
Absolute get method. Reads the long at the given index.
Absolute put method (optional operation). Writes the given long into this buffer at the given index.
Relative bulk get method. This method transfers longs from this buffer into the given destination array. If there are fewer longs remaining in the buffer than are required to satisfy the request, that is, if length > remaining(), then no longs are transferred and a BufferUnderflowException is thrown. Otherwise, this method copies length longs from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form src.get(dst, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst[i] = src.get(): except that it first checks that there are sufficient longs in this buffer and it is potentially much more efficient.
Relative bulk get method. This method transfers longs from this buffer into the given destination array. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation src.get(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers the longs remaining in the given source buffer into this buffer. If there are more longs remaining in the source buffer than in this buffer, that is, if src.remaining() > remaining(), then no longs are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = src.remaining() longs from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n. In other words, an invocation of this method of the form dst.put(src) has exactly the same effect as the loop while (src.hasRemaining()) dst.put(src.get()); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers longs into this buffer from the given source array. If there are more longs to be copied from the array than remain in this buffer, that is, if length > remaining(), then no longs are transferred and a BufferOverflowException is thrown. Otherwise, this method copies length longs from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form dst.put(src, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst.put(a[i]); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source long array into this buffer. An invocation of this method of the form dst.put(a) behaves in exactly the same way as the invocation dst.put(a, 0, a.length)
Tells whether or not this buffer is backed by an accessible long array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the long array that backs this buffer (optional operation). Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Compacts this buffer (optional operation). The longs between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the long at index p = position() is copied to index zero, the long at index p + 1 is copied to index one, and so forth until the long at index limit() - 1 is copied to index n = limit() - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer's position is set to the number of longs copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.
Tells whether or not this long buffer is direct.
Returns a string summarizing the state of this buffer.
Returns the current hash code of this buffer. The hash code of a long buffer depends only upon its remaining elements; that is, upon the elements from position() up to, and including, the element at limit() - 1. Because buffer hash codes are content-dependent, it is inadvisable to use buffers as keys in hash maps or similar data structures unless it is known that their contents will not change.
Tells whether or not this buffer is equal to another object. Two long buffers are equal if, and only if, They have the same element type, They have the same number of remaining elements, and The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. A long buffer is not equal to any other type of object.
Compares this buffer to another. Two long buffers are compared by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. Pairs of long elements are compared as if by invoking Long.compare(long,long). A long buffer is not comparable to any other type of object.
Retrieves this buffer's byte order. The byte order of a long buffer created by allocation or by wrapping an existing long array is the native order of the underlying hardware. The byte order of a long buffer created as a view of a byte buffer is that of the byte buffer at the moment that the view is created.
Tells whether or not this buffer's content is resident in physical memory. A return value of true implies that it is highly likely that all of the data in this buffer is resident in physical memory and may therefore be accessed without incurring any virtual-memory page faults or I/O operations. A return value of false does not necessarily imply that the buffer's content is not resident in physical memory. The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of the buffer's data by the time that an invocation of this method returns.
Loads this buffer's content into physical memory. This method makes a best effort to ensure that, when it returns, this buffer's content is resident in physical memory. Invoking this method may cause some number of page faults and I/O operations to occur.
Forces any changes made to this buffer's content to be written to the storage device containing the mapped file. If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device. If the file does not reside on a local device then no such guarantee is made. If this buffer was not mapped in read/write mode (FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.
Constructs an instance of this class.
Allocates a new short buffer. The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
Wraps a short array into a buffer. The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.
Wraps a short array into a buffer. The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be array.length, its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset> will be zero.
Creates a new short buffer whose content is a shared subsequence of this buffer's content. The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of shorts remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new short buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.
Creates a new, read-only short buffer that shares this buffer's content. The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent. The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.
Relative get method. Reads the short at this buffer's current position, and then increments the position.
Relative put method (optional operation). Writes the given short into this buffer at the current position, and then increments the position.
Absolute get method. Reads the short at the given index.
Absolute put method (optional operation). Writes the given short into this buffer at the given index.
Relative bulk get method. This method transfers shorts from this buffer into the given destination array. If there are fewer shorts remaining in the buffer than are required to satisfy the request, that is, if length > remaining(), then no shorts are transferred and a BufferUnderflowException is thrown. Otherwise, this method copies length shorts from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form src.get(dst, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst[i] = src.get(): except that it first checks that there are sufficient shorts in this buffer and it is potentially much more efficient.
Relative bulk get method. This method transfers shorts from this buffer into the given destination array. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation src.get(a, 0, a.length)
Relative bulk put method (optional operation). This method transfers the shorts remaining in the given source buffer into this buffer. If there are more shorts remaining in the source buffer than in this buffer, that is, if src.remaining() > remaining(), then no shorts are transferred and a BufferOverflowException is thrown. Otherwise, this method copies n = src.remaining() shorts from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n. In other words, an invocation of this method of the form dst.put(src) has exactly the same effect as the loop while (src.hasRemaining()) dst.put(src.get()); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers shorts into this buffer from the given source array. If there are more shorts to be copied from the array than remain in this buffer, that is, if length > remaining(), then no shorts are transferred and a BufferOverflowException is thrown. Otherwise, this method copies length shorts from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length. In other words, an invocation of this method of the form dst.put(src, off, len) has exactly the same effect as the loop for (int i = off; i < off + len; i++) dst.put(a[i]); except that it first checks that there is sufficient space in this buffer and it is potentially much more efficient.
Relative bulk put method (optional operation). This method transfers the entire content of the given source short array into this buffer. An invocation of this method of the form dst.put(a) behaves in exactly the same way as the invocation dst.put(a, 0, a.length)
Tells whether or not this buffer is backed by an accessible short array. If this method returns true then the array and arrayOffset methods may safely be invoked.
Returns the short array that backs this buffer (optional operation). Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa. Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). If this buffer is backed by an array then buffer position p corresponds to array index p + arrayOffset(). Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.
Compacts this buffer (optional operation). The shorts between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the short at index p = position() is copied to index zero, the short at index p + 1 is copied to index one, and so forth until the short at index limit() - 1 is copied to index n = limit() - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer's position is set to the number of shorts copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.
Tells whether or not this short buffer is direct.
Returns a string summarizing the state of this buffer.
Returns the current hash code of this buffer. The hash code of a short buffer depends only upon its remaining elements; that is, upon the elements from position() up to, and including, the element at limit() - 1. Because buffer hash codes are content-dependent, it is inadvisable to use buffers as keys in hash maps or similar data structures unless it is known that their contents will not change.
Tells whether or not this buffer is equal to another object. Two short buffers are equal if, and only if, They have the same element type, They have the same number of remaining elements, and The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. A short buffer is not equal to any other type of object.
Compares this buffer to another. Two short buffers are compared by comparing their sequences of remaining elements lexicographically, without regard to the starting position of each sequence within its corresponding buffer. Pairs of short elements are compared as if by invoking Short.compare(short,short). A short buffer is not comparable to any other type of object.
Retrieves this buffer's byte order. The byte order of a short buffer created by allocation or by wrapping an existing short array is the native order of the underlying hardware. The byte order of a short buffer created as a view of a byte buffer is that of the byte buffer at the moment that the view is created.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Reads a sequence of bytes from this channel into the given buffer. This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The handler parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream. The read operation may read up to r bytes from the channel, where r is the number of bytes remaining in the buffer, that is, dst.remaining() at the time that the read is attempted. Where r is 0, the read operation completes immediately with a result of 0 without initiating an I/O operation. Suppose that a byte sequence of length n is read, where 0 < n <= r. This byte sequence will be transferred into the buffer so that the first byte in the sequence is at index p and the last byte is at index p + n - 1, where p is the buffer's position at the moment the read is performed. Upon completion the buffer's position will be equal to p + n; its limit will not have changed. Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. This method may be invoked at any time. Some channel types may not allow more than one read to be outstanding at any given time. If a thread initiates a read operation before a previous read operation has completed then a ReadPendingException will be thrown.
Reads a sequence of bytes from this channel into the given buffer. This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The method behaves in exactly the same manner as the read(ByteBuffer,Object,CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future's get method returns the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream.
Writes a sequence of bytes to this channel from the given buffer. This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The handler parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. The write operation may write up to r bytes to the channel, where r is the number of bytes remaining in the buffer, that is, src.remaining() at the time that the write is attempted. Where r is 0, the write operation completes immediately with a result of 0 without initiating an I/O operation. Suppose that a byte sequence of length n is written, where 0 < n <= r. This byte sequence will be transferred from the buffer starting at index p, where p is the buffer's position at the moment the write is performed; the index of the last byte written will be p + n - 1. Upon completion the buffer's position will be equal to p + n; its limit will not have changed. Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. This method may be invoked at any time. Some channel types may not allow more than one write to be outstanding at any given time. If a thread initiates a write operation before a previous write operation has completed then a WritePendingException will be thrown.
Writes a sequence of bytes to this channel from the given buffer. This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The method behaves in exactly the same manner as the write(ByteBuffer,Object,CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future's get method returns the number of bytes written.
Closes this channel. Any outstanding asynchronous operations upon this channel will complete with the exception AsynchronousCloseException. After a channel is closed, further attempts to initiate asynchronous I/O operations complete immediately with cause ClosedChannelException. This method otherwise behaves exactly as specified by the Channel interface.
Initialize a new instance of this class.
Returns the provider that created this channel group.
Creates an asynchronous channel group with a fixed thread pool. The resulting asynchronous channel group reuses a fixed number of threads. At any point, at most nThreads threads will be active processing tasks that are submitted to handle I/O events and dispatch completion results for operations initiated on asynchronous channels in the group. The group is created by invoking the openAsynchronousChannelGroup(int,ThreadFactory) method of the system-wide default AsynchronousChannelProvider object.
Creates an asynchronous channel group with a given thread pool that creates new threads as needed. The executor parameter is an ExecutorService that creates new threads as needed to execute tasks that are submitted to handle I/O events and dispatch completion results for operations initiated on asynchronous channels in the group. It may reuse previously constructed threads when they are available. The initialSize parameter may be used by the implementation as a hint as to the initial number of tasks it may submit. For example, it may be used to indicate the initial number of threads that wait on I/O events. The executor is intended to be used exclusively by the resulting asynchronous channel group. Termination of the group results in the orderly shutdown of the executor service. Shutting down the executor service by other means results in unspecified behavior. The group is created by invoking the openAsynchronousChannelGroup(ExecutorService,int) method of the system-wide default AsynchronousChannelProvider object.
Creates an asynchronous channel group with a given thread pool. The executor parameter is an ExecutorService that executes tasks submitted to dispatch completion results for operations initiated on asynchronous channels in the group. Care should be taken when configuring the executor service. It should support direct handoff or unbounded queuing of submitted tasks, and the thread that invokes the execute method should never invoke the task directly. An implementation may mandate additional constraints. The executor is intended to be used exclusively by the resulting asynchronous channel group. Termination of the group results in the orderly shutdown of the executor service. Shutting down the executor service by other means results in unspecified behavior. The group is created by invoking the openAsynchronousChannelGroup(ExecutorService,int) method of the system-wide default AsynchronousChannelProvider object with an initialSize of 0.
Tells whether or not this asynchronous channel group is shutdown.
Tells whether or not this group has terminated. Where this method returns true, then the associated thread pool has also terminated.
Initiates an orderly shutdown of the group. This method marks the group as shutdown. Further attempts to construct channel that binds to this group will throw ShutdownChannelGroupException. The group terminates when all asynchronous channels in the group are closed, all actively executing completion handlers have run to completion, and all resources have been released. This method has no effect if the group is already shutdown.
Shuts down the group and closes all open channels in the group. In addition to the actions performed by the shutdown method, this method invokes the close method on all open channels in the group. This method does not attempt to stop or interrupt threads that are executing completion handlers. The group terminates when all actively executing completion handlers have run to completion and all resources have been released. This method may be invoked at any time. If some other thread has already invoked it, then another invocation will block until the first invocation is complete, after which it will return without effect.
Awaits termination of the group. This method blocks until the group has terminated, or the timeout occurs, or the current thread is interrupted, whichever happens first.
Constructs an instance of this class.
Initializes a new instance of this class.
Opens or creates a file for reading and/or writing, returning an asynchronous file channel to access the file. The options parameter determines how the file is opened. The READ and WRITE options determines if the file should be opened for reading and/or writing. If neither option is contained in the array then an existing file is opened for reading. In addition to READ and WRITE, the following options may be present: Option Description TRUNCATE_EXISTING When opening an existing file, the file is first truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading. CREATE_NEW If this option is present then a new file is created, failing if the file already exists. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading. CREATE If this option is present then an existing file is opened if it exists, otherwise a new file is created. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored if the CREATE_NEW option is also present or the file is opened only for reading. DELETE_ON_CLOSE When this option is present then the implementation makes a best effort attempt to delete the file when closed by the the close method. If the close method is not invoked then a best effort attempt is made to delete the file when the Java virtual machine terminates. SPARSE When creating a new file this option is a hint that the new file will be sparse. This option is ignored when not creating a new file. SYNC Requires that every update to the file's content or metadata be written synchronously to the underlying storage device. (see Synchronized I/O file integrity). DSYNC Requires that every update to the file's content be written synchronously to the underlying storage device. (see Synchronized I/O file integrity). An implementation may also support additional options. The executor parameter is the ExecutorService to which tasks are submitted to handle I/O events and dispatch completion results for operations initiated on resulting channel. The nature of these tasks is highly implementation specific and so care should be taken when configuring the Executor. Minimally it should support an unbounded work queue and should not run tasks on the caller thread of the execute method. Shutting down the executor service while the channel is open results in unspecified behavior. The attrs parameter is an optional array of file file-attributes to set atomically when creating the file. The new channel is created by invoking the newFileChannel method on the provider that created the Path.
Opens or creates a file for reading and/or writing, returning an asynchronous file channel to access the file. An invocation of this method behaves in exactly the same way as the invocation ch.open(file, opts, null, new FileAttribute<?>[0]); where opts is a Set containing the options specified to this method. The resulting channel is associated with default thread pool to which tasks are submitted to handle I/O events and dispatch to completion handlers that consume the result of asynchronous operations performed on the resulting channel.
Returns the current size of this channel's file.
Truncates this channel's file to the given size. If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified.
Forces any updates to this channel's file to be written to the storage device that contains it. If this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash. If the file does not reside on a local device then no such guarantee is made. The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file's content need be written to storage; passing true indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified. Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file's metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified. This method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class.
Acquires a lock on the given region of this channel's file. This method initiates an operation to acquire a lock on the given region of this channel's file. The handler parameter is a completion handler that is invoked when the lock is acquired (or the operation fails). The result passed to the completion handler is the resulting FileLock. The region specified by the position and size parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The two-argument lock(Object,CompletionHandler) method simply locks a region of size Long.MAX_VALUE. If a lock that overlaps the requested region is already held by this Java virtual machine, or this method has been invoked to lock an overlapping region and that operation has not completed, then this method throws OverlappingFileLockException. Some operating systems do not support a mechanism to acquire a file lock in an asynchronous manner. Consequently an implementation may acquire the file lock in a background thread or from a task executed by a thread in the associated thread pool. If there are many lock operations outstanding then it may consume threads in the Java virtual machine for indefinite periods. Some operating systems do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock. Whether the newly-acquired lock is shared or exclusive may be tested by invoking the resulting lock object's isShared method. File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.
Acquires an exclusive lock on this channel's file. This method initiates an operation to acquire a lock on the given region of this channel's file. The handler parameter is a completion handler that is invoked when the lock is acquired (or the operation fails). The result passed to the completion handler is the resulting FileLock. An invocation of this method of the form ch.lock(att,handler) behaves in exactly the same way as the invocation ch.lock(0L, Long.MAX_VALUE, false, att, handler)
Acquires a lock on the given region of this channel's file. This method initiates an operation to acquire a lock on the given region of this channel's file. The method behaves in exactly the same manner as the lock(long, long, boolean, Object, CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future's get method returns the FileLock on successful completion.
Acquires an exclusive lock on this channel's file. This method initiates an operation to acquire an exclusive lock on this channel's file. The method returns a Future representing the pending result of the operation. The Future's get method returns the FileLock on successful completion. An invocation of this method behaves in exactly the same way as the invocation ch.lock(0L, Long.MAX_VALUE, false)
Attempts to acquire a lock on the given region of this channel's file. This method does not block. An invocation always returns immediately, either having acquired a lock on the requested region or having failed to do so. If it fails to acquire a lock because an overlapping lock is held by another program then it returns null. If it fails to acquire a lock for any other reason then an appropriate exception is thrown.
Attempts to acquire an exclusive lock on this channel's file. An invocation of this method of the form ch.tryLock() behaves in exactly the same way as the invocation ch.tryLock(0L, Long.MAX_VALUE, false)
Reads a sequence of bytes from this channel into the given buffer, starting at the given file position. This method initiates the reading of a sequence of bytes from this channel into the given buffer, starting at the given file position. The result of the read is the number of bytes read or -1 if the given position is greater than or equal to the file's size at the time that the read is attempted. This method works in the same manner as the AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler) method, except that bytes are read starting at the given file position. If the given file position is greater than the file's size at the time that the read is attempted then no bytes are read.
Reads a sequence of bytes from this channel into the given buffer, starting at the given file position. This method initiates the reading of a sequence of bytes from this channel into the given buffer, starting at the given file position. This method returns a Future representing the pending result of the operation. The Future's get method returns the number of bytes read or -1 if the given position is greater than or equal to the file's size at the time that the read is attempted. This method works in the same manner as the AsynchronousByteChannel.read(ByteBuffer) method, except that bytes are read starting at the given file position. If the given file position is greater than the file's size at the time that the read is attempted then no bytes are read.
Writes a sequence of bytes to this channel from the given buffer, starting at the given file position. This method works in the same manner as the AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler) method, except that bytes are written starting at the given file position. If the given position is greater than the file's size, at the time that the write is attempted, then the file will be grown to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified.
Writes a sequence of bytes to this channel from the given buffer, starting at the given file position. This method initiates the writing of a sequence of bytes to this channel from the given buffer, starting at the given file position. The method returns a Future representing the pending result of the write operation. The Future's get method returns the number of bytes written. This method works in the same manner as the AsynchronousByteChannel.write(ByteBuffer) method, except that bytes are written starting at the given file position. If the given position is greater than the file's size, at the time that the write is attempted, then the file will be grown to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified.
Initializes a new instance of this class.
Returns the provider that created this channel.
Opens an asynchronous server-socket channel. The new channel is created by invoking the openAsynchronousServerSocketChannel method on the AsynchronousChannelProvider object that created the given group. If the group parameter is null then the resulting channel is created by the system-wide default provider, and bound to the default group.
Opens an asynchronous server-socket channel. This method returns an asynchronous server socket channel that is bound to the default group. This method is equivalent to evaluating the expression: open((AsynchronousChannelGroup)null);
Binds the channel's socket to a local address and configures the socket to listen for connections. An invocation of this method is equivalent to the following: bind(local, 0);
Binds the channel's socket to a local address and configures the socket to listen for connections. This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the associated channel is closed. The backlog parameter is the maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. If the backlog parameter has the value 0, or a negative value, then an implementation specific default is used.
Sets the value of a socket option.
Accepts a connection. This method initiates an asynchronous operation to accept a connection made to this channel's socket. The handler parameter is a completion handler that is invoked when a connection is accepted (or the operation fails). The result passed to the completion handler is the AsynchronousSocketChannel to the new connection. When a new connection is accepted then the resulting AsynchronousSocketChannel will be bound to the same AsynchronousChannelGroup as this channel. If the group is shutdown and a connection is accepted, then the connection is closed, and the operation completes with an IOException and cause ShutdownChannelGroupException. To allow for concurrent handling of new connections, the completion handler is not invoked directly by the initiating thread when a new connection is accepted immediately (see Threading). If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's checkAccept method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a SecurityException.
Accepts a connection. This method initiates an asynchronous operation to accept a connection made to this channel's socket. The method behaves in exactly the same manner as the accept(Object, CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future's get method returns the AsynchronousSocketChannel to the new connection on successful completion.
Returns the socket address that this channel's socket is bound to. Where the channel is bound to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port of the channel's socket is returned.
Initializes a new instance of this class.
Returns the provider that created this channel.
Opens an asynchronous socket channel. The new channel is created by invoking the openAsynchronousSocketChannel method on the AsynchronousChannelProvider that created the group. If the group parameter is null then the resulting channel is created by the system-wide default provider, and bound to the default group.
Opens an asynchronous socket channel. This method returns an asynchronous socket channel that is bound to the default group.This method is equivalent to evaluating the expression: open((AsynchronousChannelGroup)null);
Binds the channel's socket to a local address. This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. If the local parameter has the value null then the socket will be bound to an address that is assigned automatically.
Sets the value of a socket option.
Shutdown the connection for reading without closing the channel. Once shutdown for reading then further reads on the channel will return -1, the end-of-stream indication. If the input side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding read operation is system dependent and therefore not specified. The effect, if any, when there is data in the socket receive buffer that has not been read, or data arrives subsequently, is also system dependent.
Shutdown the connection for writing without closing the channel. Once shutdown for writing then further attempts to write to the channel will throw ClosedChannelException. If the output side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding write operation is system dependent and therefore not specified.
Returns the remote address to which this channel's socket is connected. Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress.
Connects this channel. This method initiates an operation to connect this channel. The handler parameter is a completion handler that is invoked when the connection is successfully established or connection cannot be established. If the connection cannot be established then the channel is closed. This method performs exactly the same security checks as the Socket class. That is, if a security manager has been installed then this method verifies that its checkConnect method permits connecting to the address and port number of the given remote endpoint.
Connects this channel. This method initiates an operation to connect this channel. This method behaves in exactly the same manner as the connect(SocketAddress, Object, CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future's get method returns null on successful completion.
Reads a sequence of bytes from this channel into the given buffer. This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The handler parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream. If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown. Otherwise this method works in the same manner as the AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler) method.
Reads a sequence of bytes from this channel into the given buffer. This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The handler parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream. The read operation may read up to r bytes from the channel, where r is the number of bytes remaining in the buffer, that is, dst.remaining() at the time that the read is attempted. Where r is 0, the read operation completes immediately with a result of 0 without initiating an I/O operation. Suppose that a byte sequence of length n is read, where 0 < n <= r. This byte sequence will be transferred into the buffer so that the first byte in the sequence is at index p and the last byte is at index p + n - 1, where p is the buffer's position at the moment the read is performed. Upon completion the buffer's position will be equal to p + n; its limit will not have changed. Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. This method may be invoked at any time. Some channel types may not allow more than one read to be outstanding at any given time. If a thread initiates a read operation before a previous read operation has completed then a ReadPendingException will be thrown.
Reads a sequence of bytes from this channel into the given buffer. This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The method behaves in exactly the same manner as the read(ByteBuffer,Object,CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future's get method returns the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream.
Reads a sequence of bytes from this channel into a subsequence of the given buffers. This operation, sometimes called a scattering read, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The handler parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or -1 if no bytes could be read because the channel has reached end-of-stream. This method initiates a read of up to r bytes from this channel, where r is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, dsts[offset].remaining() + dsts[offset+1].remaining() + ... + dsts[offset+length-1].remaining() at the moment that the read is attempted. Suppose that a byte sequence of length n is read, where 0 < n <= r. Up to the first dsts[offset].remaining() bytes of this sequence are transferred into buffer dsts[offset], up to the next dsts[offset+1].remaining() bytes are transferred into buffer dsts[offset+1], and so forth, until the entire byte sequence is transferred into the given buffers. As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.
Writes a sequence of bytes to this channel from the given buffer. This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The handler parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown. Otherwise this method works in the same manner as the AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler) method.
Writes a sequence of bytes to this channel from the given buffer. This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The handler parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. The write operation may write up to r bytes to the channel, where r is the number of bytes remaining in the buffer, that is, src.remaining() at the time that the write is attempted. Where r is 0, the write operation completes immediately with a result of 0 without initiating an I/O operation. Suppose that a byte sequence of length n is written, where 0 < n <= r. This byte sequence will be transferred from the buffer starting at index p, where p is the buffer's position at the moment the write is performed; the index of the last byte written will be p + n - 1. Upon completion the buffer's position will be equal to p + n; its limit will not have changed. Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. This method may be invoked at any time. Some channel types may not allow more than one write to be outstanding at any given time. If a thread initiates a write operation before a previous write operation has completed then a WritePendingException will be thrown.
Writes a sequence of bytes to this channel from the given buffer. This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The method behaves in exactly the same manner as the write(ByteBuffer,Object,CompletionHandler) method except that instead of specifying a completion handler, this method returns a Future representing the pending result. The Future's get method returns the number of bytes written.
Writes a sequence of bytes to this channel from a subsequence of the given buffers. This operation, sometimes called a gathering write, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The handler parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. This method initiates a write of up to r bytes to this channel, where r is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, srcs[offset].remaining() + srcs[offset+1].remaining() + ... + srcs[offset+length-1].remaining() at the moment that the write is attempted. Suppose that a byte sequence of length n is written, where 0 < n <= r. Up to the first srcs[offset].remaining() bytes of this sequence are written from buffer srcs[offset], up to the next srcs[offset+1].remaining() bytes are written from buffer srcs[offset+1], and so forth, until the entire byte sequence is written. As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception InterruptedByTimeoutException. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.
Returns the socket address that this channel's socket is bound to. Where the channel is bound to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port of the channel's socket is returned.
Constructs an instance of this class.
Tells whether or not this channel is open.
Closes this channel. After a channel is closed, any further attempt to invoke I/O operations upon it will cause a ClosedChannelException to be thrown. If this channel is already closed then invoking this method has no effect. This method may be invoked at any time. If some other thread has already invoked it, however, then another invocation will block until the first invocation is complete, after which it will return without effect.
Constructs a stream that reads bytes from the given channel. The read methods of the resulting stream will throw an IllegalBlockingModeException if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered, and it will not support the mark or reset methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.
Constructs a stream that writes bytes to the given channel. The write methods of the resulting stream will throw an IllegalBlockingModeException if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.
Constructs a stream that reads bytes from the given channel. The stream will not be buffered, and it will not support the mark or reset methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.
Constructs a stream that writes bytes to the given channel. The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.
Constructs a channel that reads bytes from the given stream. The resulting channel will not be buffered; it will simply redirect its I/O operations to the given stream. Closing the channel will in turn cause the stream to be closed.
Constructs a channel that writes bytes to the given stream. The resulting channel will not be buffered; it will simply redirect its I/O operations to the given stream. Closing the channel will in turn cause the stream to be closed.
Constructs a reader that decodes bytes from the given channel using the given decoder. The resulting stream will contain an internal input buffer of at least minBufferCap bytes. The stream's read methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an IllegalBlockingModeException will be thrown. The resulting stream will not otherwise be buffered, and it will not support the mark or reset methods. Closing the stream will in turn cause the channel to be closed.
Constructs a reader that decodes bytes from the given channel according to the named charset. An invocation of this method of the form Channels.newReader(ch, csname) behaves in exactly the same way as the expression Channels.newReader(ch, Charset.forName(csName) .newDecoder(), -1);
Constructs a writer that encodes characters using the given encoder and writes the resulting bytes to the given channel. The resulting stream will contain an internal output buffer of at least minBufferCap bytes. The stream's write methods will, as needed, flush the buffer by writing bytes to the underlying channel; if the channel is in non-blocking mode when bytes are to be written then an IllegalBlockingModeException will be thrown. The resulting stream will not otherwise be buffered. Closing the stream will in turn cause the channel to be closed.
Constructs a writer that encodes characters according to the named charset and writes the resulting bytes to the given channel. An invocation of this method of the form Channels.newWriter(ch, csname) behaves in exactly the same way as the expression Channels.newWriter(ch, Charset.forName(csName) .newEncoder(), -1);
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Invoked when an operation has completed.
Invoked when an operation fails.
Constructs an instance of this class.
Initializes a new instance of this class.
Opens a datagram channel. The new channel is created by invoking the openDatagramChannel method of the system-wide default SelectorProvider object. The channel will not be connected. The ProtocolFamily of the channel's socket is platform (and possibly configuration) dependent and therefore unspecified. The open allows the protocol family to be selected when opening a datagram channel, and should be used to open datagram channels that are intended for Internet Protocol multicasting.
Opens a datagram channel. The family parameter is used to specify the ProtocolFamily. If the datagram channel is to be used for IP multicasting then this should correspond to the address type of the multicast groups that this channel will join. The new channel is created by invoking the openDatagramChannel method of the system-wide default SelectorProvider object. The channel will not be connected.
Returns an operation set identifying this channel's supported operations. Datagram channels support reading and writing, so this method returns (SelectionKey.OP_READ | SelectionKey.OP_WRITE).
Binds the channel's socket to a local address. This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. If the local parameter has the value null then the socket will be bound to an address that is assigned automatically.
Sets the value of a socket option.
Retrieves a datagram socket associated with this channel. The returned object will not declare any public methods that are not declared in the DatagramSocket class.
Tells whether or not this channel's socket is connected.
Connects this channel's socket. The channel's socket is configured so that it only receives datagrams from, and sends datagrams to, the given remote peer address. Once connected, datagrams may not be received from or sent to any other address. A datagram socket remains connected until it is explicitly disconnected or until it is closed. This method performs exactly the same security checks as the connect method of the DatagramSocket class. That is, if a security manager has been installed then this method verifies that its checkAccept and checkConnect methods permit datagrams to be received from and sent to, respectively, the given remote address. This method may be invoked at any time. It will not have any effect on read or write operations that are already in progress at the moment that it is invoked. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if invoking the bind method with a parameter of null.
Disconnects this channel's socket. The channel's socket is configured so that it can receive datagrams from, and sends datagrams to, any remote address so long as the security manager, if installed, permits it. This method may be invoked at any time. It will not have any effect on read or write operations that are already in progress at the moment that it is invoked. If this channel's socket is not connected, or if the channel is closed, then invoking this method has no effect.
Returns the remote address to which this channel's socket is connected.
Receives a datagram via this channel. If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns null. The datagram is transferred into the given byte buffer starting at its current position, as if by a regular read operation. If there are fewer bytes remaining in the buffer than are required to hold the datagram then the remainder of the datagram is silently discarded. This method performs exactly the same security checks as the receive method of the DatagramSocket class. That is, if the socket is not connected to a specific remote address and a security manager has been installed then for each datagram received this method verifies that the source's address and port number are permitted by the security manager's checkAccept method. The overhead of this security check can be avoided by first connecting the socket via the connect method. This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if invoking the bind method with a parameter of null.
Sends a datagram via this channel. If this channel is in non-blocking mode and there is sufficient room in the underlying output buffer, or if this channel is in blocking mode and sufficient room becomes available, then the remaining bytes in the given buffer are transmitted as a single datagram to the given target address. The datagram is transferred from the byte buffer as if by a regular write operation. This method performs exactly the same security checks as the send method of the DatagramSocket class. That is, if the socket is not connected to a specific remote address and a security manager has been installed then for each datagram sent this method verifies that the target address and port number are permitted by the security manager's checkConnect method. The overhead of this security check can be avoided by first connecting the socket via the connect method. This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if by invoking the bind method with a parameter of null.
Reads a datagram from this channel. This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffer then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the ReadableByteChannel interface.
Reads a datagram from this channel. This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffers then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the ScatteringByteChannel interface.
Reads a datagram from this channel. This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffers then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the ScatteringByteChannel interface.
Writes a datagram to this channel. This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the WritableByteChannel interface.
Writes a datagram to this channel. This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the GatheringByteChannel interface.
Writes a datagram to this channel. This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the GatheringByteChannel interface.
Returns the socket address that this channel's socket is bound to. Where the channel is bound to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port of the channel's socket is returned.
Initializes a new instance of this class.
Opens or creates a file, returning a file channel to access the file. The options parameter determines how the file is opened. The READ and WRITE options determine if the file should be opened for reading and/or writing. If neither option (or the APPEND option) is contained in the array then the file is opened for reading. By default reading or writing commences at the beginning of the file. In the addition to READ and WRITE, the following options may be present: Option Description APPEND If this option is present then the file is opened for writing and each invocation of the channel's write method first advances the position to the end of the file and then writes the requested data. Whether the advancement of the position and the writing of the data are done in a single atomic operation is system-dependent and therefore unspecified. This option may not be used in conjunction with the READ or TRUNCATE_EXISTING options. TRUNCATE_EXISTING If this option is present then the existing file is truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading. CREATE_NEW If this option is present then a new file is created, failing if the file already exists. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading. CREATE If this option is present then an existing file is opened if it exists, otherwise a new file is created. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored if the CREATE_NEW option is also present or the file is opened only for reading. DELETE_ON_CLOSE When this option is present then the implementation makes a best effort attempt to delete the file when closed by the the close method. If the close method is not invoked then a best effort attempt is made to delete the file when the Java virtual machine terminates. SPARSE When creating a new file this option is a hint that the new file will be sparse. This option is ignored when not creating a new file. SYNC Requires that every update to the file's content or metadata be written synchronously to the underlying storage device. (see Synchronized I/O file integrity). DSYNC Requires that every update to the file's content be written synchronously to the underlying storage device. (see Synchronized I/O file integrity). An implementation may also support additional options. The attrs parameter is an optional array of file file-attributes to set atomically when creating the file. The new channel is created by invoking the newFileChannel method on the provider that created the Path.
Opens or creates a file, returning a file channel to access the file. An invocation of this method behaves in exactly the same way as the invocation fc.open(file, opts, new FileAttribute<?>[0]); where opts is a set of the options specified in the options array.
Reads a sequence of bytes from this channel into the given buffer. Bytes are read starting at this channel's current file position, and then the file position is updated with the number of bytes actually read. Otherwise this method behaves exactly as specified in the ReadableByteChannel interface.
Reads a sequence of bytes from this channel into a subsequence of the given buffers. Bytes are read starting at this channel's current file position, and then the file position is updated with the number of bytes actually read. Otherwise this method behaves exactly as specified in the ScatteringByteChannel interface.
Reads a sequence of bytes from this channel into the given buffers. Bytes are read starting at this channel's current file position, and then the file position is updated with the number of bytes actually read. Otherwise this method behaves exactly as specified in the ScatteringByteChannel interface.
Writes a sequence of bytes to this channel from the given buffer. Bytes are written starting at this channel's current file position unless the channel is in append mode, in which case the position is first advanced to the end of the file. The file is grown, if necessary, to accommodate the written bytes, and then the file position is updated with the number of bytes actually written. Otherwise this method behaves exactly as specified by the WritableByteChannel interface.
Writes a sequence of bytes to this channel from a subsequence of the given buffers. Bytes are written starting at this channel's current file position unless the channel is in append mode, in which case the position is first advanced to the end of the file. The file is grown, if necessary, to accommodate the written bytes, and then the file position is updated with the number of bytes actually written. Otherwise this method behaves exactly as specified in the GatheringByteChannel interface.
Writes a sequence of bytes to this channel from the given buffers. Bytes are written starting at this channel's current file position unless the channel is in append mode, in which case the position is first advanced to the end of the file. The file is grown, if necessary, to accommodate the written bytes, and then the file position is updated with the number of bytes actually written. Otherwise this method behaves exactly as specified in the GatheringByteChannel interface.
Returns this channel's file position.
Sets this channel's file position. Setting the position to a value that is greater than the file's current size is legal but does not change the size of the file. A later attempt to read bytes at such a position will immediately return an end-of-file indication. A later attempt to write bytes at such a position will cause the file to be grown to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified.
Returns the current size of this channel's file.
Truncates this channel's file to the given size. If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified. In either case, if this channel's file position is greater than the given size then it is set to that size.
Forces any updates to this channel's file to be written to the storage device that contains it. If this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash. If the file does not reside on a local device then no such guarantee is made. The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file's content need be written to storage; passing true indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified. Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file's metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified. This method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class. It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer's content to be written.
Transfers bytes from this channel's file to the given writable byte channel. An attempt is made to read up to count bytes starting at the given position in this channel's file and write them to the target channel. An invocation of this method may or may not transfer all of the requested bytes; whether or not it does so depends upon the natures and states of the channels. Fewer than the requested number of bytes are transferred if this channel's file contains fewer than count bytes starting at the given position, or if the target channel is non-blocking and it has fewer than count bytes free in its output buffer. This method does not modify this channel's position. If the given position is greater than the file's current size then no bytes are transferred. If the target channel has a position then bytes are written starting at that position and then the position is incremented by the number of bytes written. This method is potentially much more efficient than a simple loop that reads from this channel and writes to the target channel. Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them.
Transfers bytes into this channel's file from the given readable byte channel. An attempt is made to read up to count bytes from the source channel and write them to this channel's file starting at the given position. An invocation of this method may or may not transfer all of the requested bytes; whether or not it does so depends upon the natures and states of the channels. Fewer than the requested number of bytes will be transferred if the source channel has fewer than count bytes remaining, or if the source channel is non-blocking and has fewer than count bytes immediately available in its input buffer. This method does not modify this channel's position. If the given position is greater than the file's current size then no bytes are transferred. If the source channel has a position then bytes are read starting at that position and then the position is incremented by the number of bytes read. This method is potentially much more efficient than a simple loop that reads from the source channel and writes to this channel. Many operating systems can transfer bytes directly from the source channel into the filesystem cache without actually copying them.
Reads a sequence of bytes from this channel into the given buffer, starting at the given file position. This method works in the same manner as the read(ByteBuffer) method, except that bytes are read starting at the given file position rather than at the channel's current position. This method does not modify this channel's position. If the given position is greater than the file's current size then no bytes are read.
Writes a sequence of bytes to this channel from the given buffer, starting at the given file position. This method works in the same manner as the write(ByteBuffer) method, except that bytes are written starting at the given file position rather than at the channel's current position. This method does not modify this channel's position. If the given position is greater than the file's current size then the file will be grown to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified.
Maps a region of this channel's file directly into memory. A region of a file may be mapped into memory in one of three modes: Read-only: Any attempt to modify the resulting buffer will cause a ReadOnlyBufferException to be thrown. (MapMode.READ_ONLY) Read/write: Changes made to the resulting buffer will eventually be propagated to the file; they may or may not be made visible to other programs that have mapped the same file. (MapMode.READ_WRITE) Private: Changes made to the resulting buffer will not be propagated to the file and will not be visible to other programs that have mapped the same file; instead, they will cause private copies of the modified portions of the buffer to be created. (MapMode.PRIVATE) For a read-only mapping, this channel must have been opened for reading; for a read/write or private mapping, this channel must have been opened for both reading and writing. The mapped byte buffer returned by this method will have a position of zero and a limit and capacity of size; its mark will be undefined. The buffer and the mapping that it represents will remain valid until the buffer itself is garbage-collected. A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping. Many of the details of memory-mapped files are inherently dependent upon the underlying operating system and are therefore unspecified. The behavior of this method when the requested region is not completely contained within this channel's file is unspecified. Whether changes made to the content or size of the underlying file, by this program or another, are propagated to the buffer is unspecified. The rate at which changes to the buffer are propagated to the file is unspecified. For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory.
Acquires a lock on the given region of this channel's file. An invocation of this method will block until the region can be locked, this channel is closed, or the invoking thread is interrupted, whichever comes first. If this channel is closed by another thread during an invocation of this method then an AsynchronousCloseException will be thrown. If the invoking thread is interrupted while waiting to acquire the lock then its interrupt status will be set and a FileLockInterruptionException will be thrown. If the invoker's interrupt status is set when this method is invoked then that exception will be thrown immediately; the thread's interrupt status will not be changed. The region specified by the position and size parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument lock() method simply locks a region of size Long.MAX_VALUE. Some operating systems do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock. Whether the newly-acquired lock is shared or exclusive may be tested by invoking the resulting lock object's isShared method. File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.
Acquires an exclusive lock on this channel's file. An invocation of this method of the form fc.lock() behaves in exactly the same way as the invocation fc.lock(0L, Long.MAX_VALUE, false)
Attempts to acquire a lock on the given region of this channel's file. This method does not block. An invocation always returns immediately, either having acquired a lock on the requested region or having failed to do so. If it fails to acquire a lock because an overlapping lock is held by another program then it returns null. If it fails to acquire a lock for any other reason then an appropriate exception is thrown. The region specified by the position and size parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument tryLock() method simply locks a region of size Long.MAX_VALUE. Some operating systems do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock. Whether the newly-acquired lock is shared or exclusive may be tested by invoking the resulting lock object's isShared method. File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.
Attempts to acquire an exclusive lock on this channel's file. An invocation of this method of the form fc.tryLock() behaves in exactly the same way as the invocation fc.tryLock(0L, Long.MAX_VALUE, false)
Mode for a read-only mapping.
Mode for a read/write mapping.
Mode for a private (copy-on-write) mapping.
Returns a string describing this file-mapping mode.
Initializes a new instance of this class.
Initializes a new instance of this class.
Returns the file channel upon whose file this lock was acquired. This method has been superseded by the acquiredBy method.
Returns the channel upon whose file this lock was acquired.
Returns the position within the file of the first byte of the locked region. A locked region need not be contained within, or even overlap, the actual underlying file, so the value returned by this method may exceed the file's current size.
Returns the size of the locked region in bytes. A locked region need not be contained within, or even overlap, the actual underlying file, so the value returned by this method may exceed the file's current size.
Tells whether this lock is shared.
Tells whether or not this lock overlaps the given lock range.
Tells whether or not this lock is valid. A lock object remains valid until it is released or the associated file channel is closed, whichever comes first.
Releases this lock. If this lock object is valid then invoking this method releases the lock and renders the object invalid. If this lock object is invalid then invoking this method has no effect.
This method invokes the release() method. It was added to the class so that it could be used in conjunction with the automatic resource management block construct.
Returns a string describing the range, type, and validity of this lock.
Constructs an instance of this class.
Writes a sequence of bytes to this channel from a subsequence of the given buffers. An attempt is made to write up to r bytes to this channel, where r is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, srcs[offset].remaining() + srcs[offset+1].remaining() + ... + srcs[offset+length-1].remaining() at the moment that this method is invoked. Suppose that a byte sequence of length n is written, where 0 <= n <= r. Up to the first srcs[offset].remaining() bytes of this sequence are written from buffer srcs[offset], up to the next srcs[offset+1].remaining() bytes are written from buffer srcs[offset+1], and so forth, until the entire byte sequence is written. As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. Unless otherwise specified, a write operation will return only after writing all of the r requested bytes. Some types of channels, depending upon their state, may write only some of the bytes or possibly none at all. A socket channel in non-blocking mode, for example, cannot write any more bytes than are free in the socket's output buffer. This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Writes a sequence of bytes to this channel from the given buffers. An invocation of this method of the form c.write(srcs) behaves in exactly the same manner as the invocation c.write(srcs, 0, srcs.length);
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Closes this channel. Any thread currently blocked in an I/O operation upon this channel will receive an AsynchronousCloseException. This method otherwise behaves exactly as specified by the Channel interface.
Initializes a new instance of this class.
Tells whether or not this membership is valid. A multicast group membership is valid upon creation and remains valid until the membership is dropped by invoking the drop method, or the channel is closed.
Drop membership. If the membership key represents a membership to receive all datagrams then the membership is dropped and the channel will no longer receive any datagrams sent to the group. If the membership key is source-specific then the channel will no longer receive datagrams sent to the group from that source address. After membership is dropped it may still be possible to receive datagrams sent to the group. This can arise when datagrams are waiting to be received in the socket's receive buffer. After membership is dropped then the channel may join the group again in which case a new membership key is returned. Upon return, this membership object will be invalid. If the multicast group membership is already invalid then invoking this method has no effect. Once a multicast group membership is invalid, it remains invalid forever.
Block multicast datagrams from the given source address. If this membership key is not source-specific, and the underlying operating system supports source filtering, then this method blocks multicast datagrams from the given source address. If the given source address is already blocked then this method has no effect. After a source address is blocked it may still be possible to receive datagrams from that source. This can arise when datagrams are waiting to be received in the socket's receive buffer.
Unblock multicast datagrams from the given source address that was previously blocked using the block method.
Returns the channel for which this membership key was created. This method will continue to return the channel even after the membership becomes invalid.
Returns the multicast group for which this membership key was created. This method will continue to return the group even after the membership becomes invalid.
Returns the network interface for which this membership key was created. This method will continue to return the network interface even after the membership becomes invalid.
Returns the source address if this membership key is source-specific, or null if this membership is not source-specific.
Closes this channel. If the channel is a member of a multicast group then the membership is dropped. Upon return, the membership-key will be invalid. This method otherwise behaves exactly as specified by the Channel interface.
Joins a multicast group to begin receiving all datagrams sent to the group, returning a membership key. If this channel is currently a member of the group on the given interface to receive all datagrams then the membership key, representing that membership, is returned. Otherwise this channel joins the group and the resulting new membership key is returned. The resulting membership key is not source-specific. A multicast channel may join several multicast groups, including the same group on more than one interface. An implementation may impose a limit on the number of groups that may be joined at the same time.
Joins a multicast group to begin receiving datagrams sent to the group from a given source address. If this channel is currently a member of the group on the given interface to receive datagrams from the given source address then the membership key, representing that membership, is returned. Otherwise this channel joins the group and the resulting new membership key is returned. The resulting membership key is source-specific. Membership is cumulative and this method may be invoked again with the same group and interface to allow receiving datagrams sent by other source addresses to the group.
Binds the channel's socket to a local address. This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. If the local parameter has the value null then the socket will be bound to an address that is assigned automatically.
Returns the socket address that this channel's socket is bound to. Where the channel is bound to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress.
Sets the value of a socket option.
Returns the value of a socket option.
Returns a set of the socket options supported by this channel. This method will continue to return the set of options even after the channel has been closed.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Initializes a new instance of this class.
Returns this pipe's source channel.
Returns this pipe's sink channel.
Opens a pipe. The new pipe is created by invoking the openPipe method of the system-wide default SelectorProvider object.
Initializes a new instance of this class.
Returns an operation set identifying this channel's supported operations. Pipe-sink channels only support writing, so this method returns SelectionKey.OP_WRITE.
Constructs a new instance of this class.
Returns an operation set identifying this channel's supported operations. Pipe-source channels only support reading, so this method returns SelectionKey.OP_READ.
Reads a sequence of bytes from this channel into the given buffer. An attempt is made to read up to r bytes from the channel, where r is the number of bytes remaining in the buffer, that is, dst.remaining(), at the moment this method is invoked. Suppose that a byte sequence of length n is read, where 0 <= n <= r. This byte sequence will be transferred into the buffer so that the first byte in the sequence is at index p and the last byte is at index p + n - 1, where p is the buffer's position at the moment this method is invoked. Upon return the buffer's position will be equal to p + n; its limit will not have changed. A read operation might not fill the buffer, and in fact it might not read any bytes at all. Whether or not it does so depends upon the nature and state of the channel. A socket channel in non-blocking mode, for example, cannot read any more bytes than are immediately available from the socket's input buffer; similarly, a file channel cannot read any more bytes than remain in the file. It is guaranteed, however, that if a channel is in blocking mode and there is at least one byte remaining in the buffer then this method will block until at least one byte is read. This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Constructs an instance of this class.
Reads a sequence of bytes from this channel into a subsequence of the given buffers. An invocation of this method attempts to read up to r bytes from this channel, where r is the total number of bytes remaining the specified subsequence of the given buffer array, that is, dsts[offset].remaining() + dsts[offset+1].remaining() + ... + dsts[offset+length-1].remaining() at the moment that this method is invoked. Suppose that a byte sequence of length n is read, where 0 <= n <= r. Up to the first dsts[offset].remaining() bytes of this sequence are transferred into buffer dsts[offset], up to the next dsts[offset+1].remaining() bytes are transferred into buffer dsts[offset+1], and so forth, until the entire byte sequence is transferred into the given buffers. As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Reads a sequence of bytes from this channel into the given buffers. An invocation of this method of the form c.read(dsts) behaves in exactly the same manner as the invocation c.read(dsts, 0, dsts.length);
Reads a sequence of bytes from this channel into the given buffer. Bytes are read starting at this channel's current position, and then the position is updated with the number of bytes actually read. Otherwise this method behaves exactly as specified in the ReadableByteChannel interface.
Writes a sequence of bytes to this channel from the given buffer. Bytes are written starting at this channel's current position, unless the channel is connected to an entity such as a file that is opened with the APPEND option, in which case the position is first advanced to the end. The entity to which the channel is connected is grown, if necessary, to accommodate the written bytes, and then the position is updated with the number of bytes actually written. Otherwise this method behaves exactly as specified by the WritableByteChannel interface.
Returns this channel's position.
Sets this channel's position. Setting the position to a value that is greater than the current size is legal but does not change the size of the entity. A later attempt to read bytes at such a position will immediately return an end-of-file indication. A later attempt to write bytes at such a position will cause the entity to grow to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified. Setting the channel's position is not recommended when connected to an entity, typically a file, that is opened with the APPEND option. When opened for append, the position is first advanced to the end before writing.
Returns the current size of entity to which this channel is connected.
Truncates the entity, to which this channel is connected, to the given size. If the given size is less than the current size then the entity is truncated, discarding any bytes beyond the new end. If the given size is greater than or equal to the current size then the entity is not modified. In either case, if the current position is greater than the given size then it is set to that size. An implementation of this interface may prohibit truncation when connected to an entity, typically a file, opened with the APPEND option.
Initializes a new instance of this class.
Returns the provider that created this channel.
Returns an operation set identifying this channel's supported operations. The bits that are set in this integer value denote exactly the operations that are valid for this channel. This method always returns the same value for a given concrete channel class.
Tells whether or not this channel is currently registered with any selectors. A newly-created channel is not registered. Due to the inherent delay between key cancellation and channel deregistration, a channel may remain registered for some time after all of its keys have been cancelled. A channel may also remain registered for some time after it is closed.
Retrieves the key representing the channel's registration with the given selector.
Registers this channel with the given selector, returning a selection key. If this channel is currently registered with the given selector then the selection key representing that registration is returned. The key's interest set will have been changed to ops, as if by invoking the interestOps(int) method. If the att argument is not null then the key's attachment will have been set to that value. A CancelledKeyException will be thrown if the key has already been cancelled. Otherwise this channel has not yet been registered with the given selector, so it is registered and the resulting new key is returned. The key's initial interest set will be ops and its attachment will be att. This method may be invoked at any time. If this method is invoked while another invocation of this method or of the configureBlocking method is in progress then it will first block until the other operation is complete. This method will then synchronize on the selector's key set and therefore may block if invoked concurrently with another registration or selection operation involving the same selector. If this channel is closed while this operation is in progress then the key returned by this method will have been cancelled and will therefore be invalid.
Registers this channel with the given selector, returning a selection key. An invocation of this convenience method of the form sc.register(sel, ops) behaves in exactly the same way as the invocation sc.register(sel, ops, null)
Adjusts this channel's blocking mode. If this channel is registered with one or more selectors then an attempt to place it into blocking mode will cause an IllegalBlockingModeException to be thrown. This method may be invoked at any time. The new blocking mode will only affect I/O operations that are initiated after this method returns. For some implementations this may require blocking until all pending I/O operations are complete. If this method is invoked while another invocation of this method or of the register method is in progress then it will first block until the other operation is complete.
Tells whether or not every I/O operation on this channel will block until it completes. A newly-created channel is always in blocking mode. If this channel is closed then the value returned by this method is not specified.
Retrieves the object upon which the configureBlocking and register methods synchronize. This is often useful in the implementation of adaptors that require a specific blocking mode to be maintained for a short period of time.
Operation-set bit for read operations. Suppose that a selection key's interest set contains OP_READ at the start of a selection operation. If the selector detects that the corresponding channel is ready for reading, has reached end-of-stream, has been remotely shut down for further reading, or has an error pending, then it will add OP_READ to the key's ready-operation set and add the key to its selected-key set.
Operation-set bit for write operations. Suppose that a selection key's interest set contains OP_WRITE at the start of a selection operation. If the selector detects that the corresponding channel is ready for writing, has been remotely shut down for further writing, or has an error pending, then it will add OP_WRITE to the key's ready set and add the key to its selected-key set.
Operation-set bit for socket-connect operations. Suppose that a selection key's interest set contains OP_CONNECT at the start of a selection operation. If the selector detects that the corresponding socket channel is ready to complete its connection sequence, or has an error pending, then it will add OP_CONNECT to the key's ready set and add the key to its selected-key set.
Operation-set bit for socket-accept operations. Suppose that a selection key's interest set contains OP_ACCEPT at the start of a selection operation. If the selector detects that the corresponding server-socket channel is ready to accept another connection, or has an error pending, then it will add OP_ACCEPT to the key's ready set and add the key to its selected-key set.
Constructs an instance of this class.
Returns the channel for which this key was created. This method will continue to return the channel even after the key is cancelled.
Returns the selector for which this key was created. This method will continue to return the selector even after the key is cancelled.
Tells whether or not this key is valid. A key is valid upon creation and remains so until it is cancelled, its channel is closed, or its selector is closed.
Requests that the registration of this key's channel with its selector be cancelled. Upon return the key will be invalid and will have been added to its selector's cancelled-key set. The key will be removed from all of the selector's key sets during the next selection operation. If this key has already been cancelled then invoking this method has no effect. Once cancelled, a key remains forever invalid. This method may be invoked at any time. It synchronizes on the selector's cancelled-key set, and therefore may block briefly if invoked concurrently with a cancellation or selection operation involving the same selector.
Retrieves this key's interest set. It is guaranteed that the returned set will only contain operation bits that are valid for this key's channel. This method may be invoked at any time. Whether or not it blocks, and for how long, is implementation-dependent.
Sets this key's interest set to the given value. This method may be invoked at any time. Whether or not it blocks, and for how long, is implementation-dependent.
Retrieves this key's ready-operation set. It is guaranteed that the returned set will only contain operation bits that are valid for this key's channel.
Tests whether this key's channel is ready for reading. An invocation of this method of the form k.isReadable() behaves in exactly the same way as the expression k.readyOps() & OP_READ != 0 If this key's channel does not support read operations then this method always returns false.
Tests whether this key's channel is ready for writing. An invocation of this method of the form k.isWritable() behaves in exactly the same way as the expression k.readyOps() & OP_WRITE != 0 If this key's channel does not support write operations then this method always returns false.
Tests whether this key's channel has either finished, or failed to finish, its socket-connection operation. An invocation of this method of the form k.isConnectable() behaves in exactly the same way as the expression k.readyOps() & OP_CONNECT != 0 If this key's channel does not support socket-connect operations then this method always returns false.
Tests whether this key's channel is ready to accept a new socket connection. An invocation of this method of the form k.isAcceptable() behaves in exactly the same way as the expression k.readyOps() & OP_ACCEPT != 0 If this key's channel does not support socket-accept operations then this method always returns false.
Attaches the given object to this key. An attached object may later be retrieved via the attachment method. Only one object may be attached at a time; invoking this method causes any previous attachment to be discarded. The current attachment may be discarded by attaching null.
Retrieves the current attachment.
Initializes a new instance of this class.
Opens a selector. The new selector is created by invoking the openSelector method of the system-wide default SelectorProvider object.
Tells whether or not this selector is open.
Returns the provider that created this channel.
Returns this selector's key set. The key set is not directly modifiable. A key is removed only after it has been cancelled and its channel has been deregistered. Any attempt to modify the key set will cause an UnsupportedOperationException to be thrown. The key set is not thread-safe.
Returns this selector's selected-key set. Keys may be removed from, but not directly added to, the selected-key set. Any attempt to add an object to the key set will cause an UnsupportedOperationException to be thrown. The selected-key set is not thread-safe.
Selects a set of keys whose corresponding channels are ready for I/O operations. This method performs a non-blocking selection operation. If no channels have become selectable since the previous selection operation then this method immediately returns zero. Invoking this method clears the effect of any previous invocations of the wakeup method.
Selects a set of keys whose corresponding channels are ready for I/O operations. This method performs a blocking selection operation. It returns only after at least one channel is selected, this selector's wakeup method is invoked, the current thread is interrupted, or the given timeout period expires, whichever comes first. This method does not offer real-time guarantees: It schedules the timeout as if by invoking the Object.wait(long) method.
Selects a set of keys whose corresponding channels are ready for I/O operations. This method performs a blocking selection operation. It returns only after at least one channel is selected, this selector's wakeup method is invoked, or the current thread is interrupted, whichever comes first.
Causes the first selection operation that has not yet returned to return immediately. If another thread is currently blocked in an invocation of the select() or select(long) methods then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of one of these methods will return immediately unless the selectNow() method is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent invocations of the select() or select(long) methods will block as usual unless this method is invoked again in the meantime. Invoking this method more than once between two successive selection operations has the same effect as invoking it just once.
Closes this selector. If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's wakeup method. Any uncancelled keys still associated with this selector are invalidated, their channels are deregistered, and any other resources associated with this selector are released. If this selector is already closed then invoking this method has no effect. After a selector is closed, any further attempt to use it, except by invoking this method or the wakeup method, will cause a ClosedSelectorException to be thrown.
Initializes a new instance of this class.
Opens a server-socket channel. The new channel is created by invoking the openServerSocketChannel method of the system-wide default SelectorProvider object. The new channel's socket is initially unbound; it must be bound to a specific address via one of its socket's bind methods before connections can be accepted.
Returns an operation set identifying this channel's supported operations. Server-socket channels only support the accepting of new connections, so this method returns SelectionKey.OP_ACCEPT.
Binds the channel's socket to a local address and configures the socket to listen for connections. An invocation of this method is equivalent to the following: bind(local, 0);
Binds the channel's socket to a local address and configures the socket to listen for connections. This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. The backlog parameter is the maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. If the backlog parameter has the value 0, or a negative value, then an implementation specific default is used.
Sets the value of a socket option.
Retrieves a server socket associated with this channel. The returned object will not declare any public methods that are not declared in the ServerSocket class.
Accepts a connection made to this channel's socket. If this channel is in non-blocking mode then this method will immediately return null if there are no pending connections. Otherwise it will block indefinitely until a new connection is available or an I/O error occurs. The socket channel returned by this method, if any, will be in blocking mode regardless of the blocking mode of this channel. This method performs exactly the same security checks as the accept method of the ServerSocket class. That is, if a security manager has been installed then for each new connection this method verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's checkAccept method.
Returns the socket address that this channel's socket is bound to. Where the channel is bound to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port of the channel's socket is returned.
Constructs an instance of this class.
Initializes a new instance of this class.
Opens a socket channel. The new channel is created by invoking the openSocketChannel method of the system-wide default SelectorProvider object.
Opens a socket channel and connects it to a remote address. This convenience method works as if by invoking the open() method, invoking the connect method upon the resulting socket channel, passing it remote, and then returning that channel.
Returns an operation set identifying this channel's supported operations. Socket channels support connecting, reading, and writing, so this method returns (SelectionKey.OP_CONNECT | SelectionKey.OP_READ | SelectionKey.OP_WRITE).
Binds the channel's socket to a local address. This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. If the local parameter has the value null then the socket will be bound to an address that is assigned automatically.
Sets the value of a socket option.
Shutdown the connection for reading without closing the channel. Once shutdown for reading then further reads on the channel will return -1, the end-of-stream indication. If the input side of the connection is already shutdown then invoking this method has no effect.
Shutdown the connection for writing without closing the channel. Once shutdown for writing then further attempts to write to the channel will throw ClosedChannelException. If the output side of the connection is already shutdown then invoking this method has no effect.
Retrieves a socket associated with this channel. The returned object will not declare any public methods that are not declared in the Socket class.
Tells whether or not this channel's network socket is connected.
Tells whether or not a connection operation is in progress on this channel.
Connects this channel's socket. If this channel is in non-blocking mode then an invocation of this method initiates a non-blocking connection operation. If the connection is established immediately, as can happen with a local connection, then this method returns true. Otherwise this method returns false and the connection operation must later be completed by invoking the finishConnect method. If this channel is in blocking mode then an invocation of this method will block until the connection is established or an I/O error occurs. This method performs exactly the same security checks as the Socket class. That is, if a security manager has been installed then this method verifies that its checkConnect method permits connecting to the address and port number of the given remote endpoint. This method may be invoked at any time. If a read or write operation upon this channel is invoked while an invocation of this method is in progress then that operation will first block until this invocation is complete. If a connection attempt is initiated but fails, that is, if an invocation of this method throws a checked exception, then the channel will be closed.
Finishes the process of connecting a socket channel. A non-blocking connection operation is initiated by placing a socket channel in non-blocking mode and then invoking its connect method. Once the connection is established, or the attempt has failed, the socket channel will become connectable and this method may be invoked to complete the connection sequence. If the connection operation failed then invoking this method will cause an appropriate IOException to be thrown. If this channel is already connected then this method will not block and will immediately return true. If this channel is in non-blocking mode then this method will return false if the connection process is not yet complete. If this channel is in blocking mode then this method will block until the connection either completes or fails, and will always either return true or throw a checked exception describing the failure. This method may be invoked at any time. If a read or write operation upon this channel is invoked while an invocation of this method is in progress then that operation will first block until this invocation is complete. If a connection attempt fails, that is, if an invocation of this method throws a checked exception, then the channel will be closed.
Returns the remote address to which this channel's socket is connected. Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress.
Reads a sequence of bytes from this channel into the given buffer. An attempt is made to read up to r bytes from the channel, where r is the number of bytes remaining in the buffer, that is, dst.remaining(), at the moment this method is invoked. Suppose that a byte sequence of length n is read, where 0 <= n <= r. This byte sequence will be transferred into the buffer so that the first byte in the sequence is at index p and the last byte is at index p + n - 1, where p is the buffer's position at the moment this method is invoked. Upon return the buffer's position will be equal to p + n; its limit will not have changed. A read operation might not fill the buffer, and in fact it might not read any bytes at all. Whether or not it does so depends upon the nature and state of the channel. A socket channel in non-blocking mode, for example, cannot read any more bytes than are immediately available from the socket's input buffer; similarly, a file channel cannot read any more bytes than remain in the file. It is guaranteed, however, that if a channel is in blocking mode and there is at least one byte remaining in the buffer then this method will block until at least one byte is read. This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Reads a sequence of bytes from this channel into a subsequence of the given buffers. An invocation of this method attempts to read up to r bytes from this channel, where r is the total number of bytes remaining the specified subsequence of the given buffer array, that is, dsts[offset].remaining() + dsts[offset+1].remaining() + ... + dsts[offset+length-1].remaining() at the moment that this method is invoked. Suppose that a byte sequence of length n is read, where 0 <= n <= r. Up to the first dsts[offset].remaining() bytes of this sequence are transferred into buffer dsts[offset], up to the next dsts[offset+1].remaining() bytes are transferred into buffer dsts[offset+1], and so forth, until the entire byte sequence is transferred into the given buffers. As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Reads a sequence of bytes from this channel into the given buffers. An invocation of this method of the form c.read(dsts) behaves in exactly the same manner as the invocation c.read(dsts, 0, dsts.length);
Writes a sequence of bytes to this channel from the given buffer. An attempt is made to write up to r bytes to the channel, where r is the number of bytes remaining in the buffer, that is, src.remaining(), at the moment this method is invoked. Suppose that a byte sequence of length n is written, where 0 <= n <= r. This byte sequence will be transferred from the buffer starting at index p, where p is the buffer's position at the moment this method is invoked; the index of the last byte written will be p + n - 1. Upon return the buffer's position will be equal to p + n; its limit will not have changed. Unless otherwise specified, a write operation will return only after writing all of the r requested bytes. Some types of channels, depending upon their state, may write only some of the bytes or possibly none at all. A socket channel in non-blocking mode, for example, cannot write any more bytes than are free in the socket's output buffer. This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Writes a sequence of bytes to this channel from a subsequence of the given buffers. An attempt is made to write up to r bytes to this channel, where r is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, srcs[offset].remaining() + srcs[offset+1].remaining() + ... + srcs[offset+length-1].remaining() at the moment that this method is invoked. Suppose that a byte sequence of length n is written, where 0 <= n <= r. Up to the first srcs[offset].remaining() bytes of this sequence are written from buffer srcs[offset], up to the next srcs[offset+1].remaining() bytes are written from buffer srcs[offset+1], and so forth, until the entire byte sequence is written. As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. Unless otherwise specified, a write operation will return only after writing all of the r requested bytes. Some types of channels, depending upon their state, may write only some of the bytes or possibly none at all. A socket channel in non-blocking mode, for example, cannot write any more bytes than are free in the socket's output buffer. This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Writes a sequence of bytes to this channel from the given buffers. An invocation of this method of the form c.write(srcs) behaves in exactly the same manner as the invocation c.write(srcs, 0, srcs.length);
Returns the socket address that this channel's socket is bound to. Where the channel is bound to an Internet Protocol socket address then the return value from this method is of type InetSocketAddress. If there is a security manager set, its checkConnect method is called with the local address and -1 as its arguments to see if the operation is allowed. If the operation is not allowed, a SocketAddress representing the loopback address and the local port of the channel's socket is returned.
Constructs an instance of this class.
Constructs an instance of this class.
Writes a sequence of bytes to this channel from the given buffer. An attempt is made to write up to r bytes to the channel, where r is the number of bytes remaining in the buffer, that is, src.remaining(), at the moment this method is invoked. Suppose that a byte sequence of length n is written, where 0 <= n <= r. This byte sequence will be transferred from the buffer starting at index p, where p is the buffer's position at the moment this method is invoked; the index of the last byte written will be p + n - 1. Upon return the buffer's position will be equal to p + n; its limit will not have changed. Unless otherwise specified, a write operation will return only after writing all of the r requested bytes. Some types of channels, depending upon their state, may write only some of the bytes or possibly none at all. A socket channel in non-blocking mode, for example, cannot write any more bytes than are free in the socket's output buffer. This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
Constructs an instance of this class.
Initializes a new instance of this class.
Closes this channel. If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the implCloseChannel method in order to complete the close operation.
Closes this channel. This method is invoked by the close method in order to perform the actual work of closing the channel. This method is only invoked if the channel has not yet been closed, and it is never invoked more than once. An implementation of this method must arrange for any other thread that is blocked in an I/O operation upon this channel to return immediately, either by throwing an exception or by returning normally.
Tells whether or not this channel is open.
Marks the beginning of an I/O operation that might block indefinitely. This method should be invoked in tandem with the end method, using a try ... finally block as shown above, in order to implement asynchronous closing and interruption for this channel.
Marks the end of an I/O operation that might block indefinitely. This method should be invoked in tandem with the begin method, using a try ... finally block as shown above, in order to implement asynchronous closing and interruption for this channel.
Initializes a new instance of this class.
Returns the provider that created this channel.
Tells whether or not this channel is currently registered with any selectors. A newly-created channel is not registered. Due to the inherent delay between key cancellation and channel deregistration, a channel may remain registered for some time after all of its keys have been cancelled. A channel may also remain registered for some time after it is closed.
Retrieves the key representing the channel's registration with the given selector.
Registers this channel with the given selector, returning a selection key. This method first verifies that this channel is open and that the given initial interest set is valid. If this channel is already registered with the given selector then the selection key representing that registration is returned after setting its interest set to the given value. Otherwise this channel has not yet been registered with the given selector, so the register method of the selector is invoked while holding the appropriate locks. The resulting key is added to this channel's key set before being returned.
Closes this channel. This method, which is specified in the AbstractInterruptibleChannel class and is invoked by the close method, in turn invokes the implCloseSelectableChannel method in order to perform the actual work of closing this channel. It then cancels all of this channel's keys.
Closes this selectable channel. This method is invoked by the close method in order to perform the actual work of closing the channel. This method is only invoked if the channel has not yet been closed, and it is never invoked more than once. An implementation of this method must arrange for any other thread that is blocked in an I/O operation upon this channel to return immediately, either by throwing an exception or by returning normally.
Tells whether or not every I/O operation on this channel will block until it completes. A newly-created channel is always in blocking mode. If this channel is closed then the value returned by this method is not specified.
Retrieves the object upon which the configureBlocking and register methods synchronize. This is often useful in the implementation of adaptors that require a specific blocking mode to be maintained for a short period of time.
Adjusts this channel's blocking mode. If the given blocking mode is different from the current blocking mode then this method invokes the implConfigureBlocking method, while holding the appropriate locks, in order to change the mode.
Adjusts this channel's blocking mode. This method is invoked by the configureBlocking method in order to perform the actual work of changing the blocking mode. This method is only invoked if the new mode is different from the current mode.
Initializes a new instance of this class.
Tells whether or not this key is valid. A key is valid upon creation and remains so until it is cancelled, its channel is closed, or its selector is closed.
Cancels this key. If this key has not yet been cancelled then it is added to its selector's cancelled-key set while synchronized on that set.
Initializes a new instance of this class.
Closes this selector. If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the implCloseSelector method in order to complete the close operation.
Closes this selector. This method is invoked by the close method in order to perform the actual work of closing the selector. This method is only invoked if the selector has not yet been closed, and it is never invoked more than once. An implementation of this method must arrange for any other thread that is blocked in a selection operation upon this selector to return immediately as if by invoking the wakeup method.
