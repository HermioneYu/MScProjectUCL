Tells whether or not this selector is open.
Returns the provider that created this channel.
Retrieves this selector's cancelled-key set. This set should only be used while synchronized upon it.
Registers the given channel with this selector. This method is invoked by a channel's register method in order to perform the actual work of registering the channel with this selector.
Removes the given key from its channel's key set. This method must be invoked by the selector for each channel that it deregisters.
Marks the beginning of an I/O operation that might block indefinitely. This method should be invoked in tandem with the end method, using a try ... finally block as shown above, in order to implement interruption for this selector. Invoking this method arranges for the selector's wakeup method to be invoked if a thread's interrupt method is invoked while the thread is blocked in an I/O operation upon the selector.
Marks the end of an I/O operation that might block indefinitely. This method should be invoked in tandem with the begin method, using a try ... finally block as shown above, in order to implement interruption for this selector.
Initializes a new instance of this class.
Returns the system-wide default asynchronous channel provider for this invocation of the Java virtual machine. The first invocation of this method locates the default provider object as follows: If the system property java.nio.channels.spi.AsynchronousChannelProvider is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown. If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named java.nio.channels.spi.AsynchronousChannelProvider in the resource directory META-INF/services, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown. Finally, if no provider has been specified by any of the above means then the system-default provider class is instantiated and the result is returned. Subsequent invocations of this method return the provider that was returned by the first invocation.
Constructs a new asynchronous channel group with a fixed thread pool.
Constructs a new asynchronous channel group with the given thread pool.
Opens an asynchronous server-socket channel.
Opens an asynchronous socket channel.
Initializes a new instance of this class.
Returns the system-wide default selector provider for this invocation of the Java virtual machine. The first invocation of this method locates the default provider object as follows: If the system property java.nio.channels.spi.SelectorProvider is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown. If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named java.nio.channels.spi.SelectorProvider in the resource directory META-INF/services, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown. Finally, if no provider has been specified by any of the above means then the system-default provider class is instantiated and the result is returned. Subsequent invocations of this method return the provider that was returned by the first invocation.
Opens a datagram channel.
Opens a datagram channel.
Opens a pipe.
Opens a selector.
Opens a server-socket channel.
Opens a socket channel.
Returns the channel inherited from the entity that created this Java virtual machine. On many operating systems a process, such as a Java virtual machine, can be started in a manner that allows the process to inherit a channel from the entity that created the process. The manner in which this is done is system dependent, as are the possible entities to which the channel may be connected. For example, on UNIX systems, the Internet services daemon (inetd) is used to start programs to service requests when a request arrives on an associated network port. In this example, the process that is started, inherits a channel representing a network socket. In cases where the inherited channel represents a network socket then the Channel type returned by this method is determined as follows: If the inherited channel represents a stream-oriented connected socket then a SocketChannel is returned. The socket channel is, at least initially, in blocking mode, bound to a socket address, and connected to a peer. If the inherited channel represents a stream-oriented listening socket then a ServerSocketChannel is returned. The server-socket channel is, at least initially, in blocking mode, and bound to a socket address. If the inherited channel is a datagram-oriented socket then a DatagramChannel is returned. The datagram channel is, at least initially, in blocking mode, and bound to a socket address. In addition to the network-oriented channels described, this method may return other kinds of channels in the future. The first invocation of this method creates the channel that is returned. Subsequent invocations of this method return the same channel.
Constructs an instance of this class.
Initializes a new charset with the given canonical name and alias set.
Tells whether the named charset is supported.
Returns a charset object for the named charset.
Constructs a sorted map from canonical charset names to charset objects. The map returned by this method will have one entry for each charset for which support is available in the current Java virtual machine. If two or more supported charsets have the same canonical name then the resulting map will contain just one of them; which one it will contain is not specified. The invocation of this method, and the subsequent use of the resulting map, may cause time-consuming disk or network I/O operations to occur. This method is provided for applications that need to enumerate all of the available charsets, for example to allow user charset selection. This method is not used by the forName method, which instead employs an efficient incremental lookup algorithm. This method may return different results at different times if new charset providers are dynamically made available to the current Java virtual machine. In the absence of such changes, the charsets returned by this method are exactly those that can be retrieved via the forName method.
Returns the default charset of this Java virtual machine. The default charset is determined during virtual-machine startup and typically depends upon the locale and charset of the underlying operating system.
Returns this charset's canonical name.
Returns a set containing this charset's aliases.
Returns this charset's human-readable name for the default locale. The default implementation of this method simply returns this charset's canonical name. Concrete subclasses of this class may override this method in order to provide a localized display name.
Tells whether or not this charset is registered in the IANA Charset Registry.
Returns this charset's human-readable name for the given locale. The default implementation of this method simply returns this charset's canonical name. Concrete subclasses of this class may override this method in order to provide a localized display name.
Tells whether or not this charset contains the given charset. A charset C is said to contain a charset D if, and only if, every character representable in D is also representable in C. If this relationship holds then it is guaranteed that every string that can be encoded in D can also be encoded in C without performing any replacements. That C contains D does not imply that each character representable in C by a particular byte sequence is represented in D by the same byte sequence, although sometimes this is the case. Every charset contains itself. This method computes an approximation of the containment relation: If it returns true then the given charset is known to be contained by this charset; if it returns false, however, then it is not necessarily the case that the given charset is not contained in this charset.
Constructs a new decoder for this charset.
Constructs a new encoder for this charset.
Tells whether or not this charset supports encoding. Nearly all charsets support encoding. The primary exceptions are special-purpose auto-detect charsets whose decoders can determine which of several possible encoding schemes is in use by examining the input byte sequence. Such charsets do not support encoding because there is no way to determine which encoding should be used on output. Implementations of such charsets should override this method to return false.
Convenience method that decodes bytes in this charset into Unicode characters. An invocation of this method upon a charset cs returns the same result as the expression cs.newDecoder() .onMalformedInput(CodingErrorAction.REPLACE) .onUnmappableCharacter(CodingErrorAction.REPLACE) .decode(bb); except that it is potentially more efficient because it can cache decoders between successive invocations. This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement byte array. In order to detect such sequences, use the CharsetDecoder.decode(java.nio.ByteBuffer) method directly.
Convenience method that encodes Unicode characters into bytes in this charset. An invocation of this method upon a charset cs returns the same result as the expression cs.newEncoder() .onMalformedInput(CodingErrorAction.REPLACE) .onUnmappableCharacter(CodingErrorAction.REPLACE) .encode(bb); except that it is potentially more efficient because it can cache encoders between successive invocations. This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement string. In order to detect such sequences, use the CharsetEncoder.encode(java.nio.CharBuffer) method directly.
Convenience method that encodes a string into bytes in this charset. An invocation of this method upon a charset cs returns the same result as the expression cs.encode(CharBuffer.wrap(s));
Compares this charset to another. Charsets are ordered by their canonical names, without regard to case.
Computes a hashcode for this charset.
Tells whether or not this object is equal to another. Two charsets are equal if, and only if, they have the same canonical names. A charset is never equal to any other type of object.
Returns a string describing this charset.
"Initializes a new decoder. The new decoder will have the given chars-per-byte values and its replacement will be the string ""\uFFFD""."
Returns the charset that created this decoder.
Returns this decoder's replacement value.
Changes this decoder's replacement value. This method invokes the implReplaceWith method, passing the new replacement, after checking that the new replacement is acceptable.
Reports a change to this decoder's replacement value. The default implementation of this method does nothing. This method should be overridden by decoders that require notification of changes to the replacement.
Returns this decoder's current action for malformed-input errors.
Changes this decoder's action for malformed-input errors. This method invokes the implOnMalformedInput method, passing the new action.
Reports a change to this decoder's malformed-input action. The default implementation of this method does nothing. This method should be overridden by decoders that require notification of changes to the malformed-input action.
Returns this decoder's current action for unmappable-character errors.
Changes this decoder's action for unmappable-character errors. This method invokes the implOnUnmappableCharacter method, passing the new action.
Reports a change to this decoder's unmappable-character action. The default implementation of this method does nothing. This method should be overridden by decoders that require notification of changes to the unmappable-character action.
Returns the average number of characters that will be produced for each byte of input. This heuristic value may be used to estimate the size of the output buffer required for a given input sequence.
Returns the maximum number of characters that will be produced for each byte of input. This value may be used to compute the worst-case size of the output buffer required for a given input sequence.
Decodes as many bytes as possible from the given input buffer, writing the results to the given output buffer. The buffers are read from, and written to, starting at their current positions. At most in.remaining() bytes will be read and at most out.remaining() characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified. In addition to reading bytes from the input buffer and writing characters to the output buffer, this method returns a CoderResult object to describe its reason for termination: CoderResult.UNDERFLOW indicates that as much of the input buffer as possible has been decoded. If there is no further input then the invoker can proceed to the next step of the decoding operation. Otherwise this method should be invoked again with further input. CoderResult.OVERFLOW indicates that there is insufficient space in the output buffer to decode any more bytes. This method should be invoked again with an output buffer that has more remaining characters. This is typically done by draining any decoded characters from the output buffer. A malformed-input result indicates that a malformed-input error has been detected. The malformed bytes begin at the input buffer's (possibly incremented) position; the number of malformed bytes may be determined by invoking the result object's length method. This case applies only if the malformed action of this decoder is CodingErrorAction.REPORT; otherwise the malformed input will be ignored or replaced, as requested. An unmappable-character result indicates that an unmappable-character error has been detected. The bytes that decode the unmappable character begin at the input buffer's (possibly incremented) position; the number of such bytes may be determined by invoking the result object's length method. This case applies only if the unmappable action of this decoder is CodingErrorAction.REPORT; otherwise the unmappable character will be ignored or replaced, as requested. In any case, if this method is to be reinvoked in the same decoding operation then care should be taken to preserve any bytes remaining in the input buffer so that they are available to the next invocation. The endOfInput parameter advises this method as to whether the invoker can provide further input beyond that contained in the given input buffer. If there is a possibility of providing additional input then the invoker should pass false for this parameter; if there is no possibility of providing further input then the invoker should pass true. It is not erroneous, and in fact it is quite common, to pass false in one invocation and later discover that no further input was actually available. It is critical, however, that the final invocation of this method in a sequence of invocations always pass true so that any remaining undecoded input will be treated as being malformed. This method works by invoking the decodeLoop method, interpreting its results, handling error conditions, and reinvoking it as necessary.
Flushes this decoder. Some decoders maintain internal state and may need to write some final characters to the output buffer once the overall input sequence has been read. Any additional output is written to the output buffer beginning at its current position. At most out.remaining() characters will be written. The buffer's position will be advanced appropriately, but its mark and limit will not be modified. If this method completes successfully then it returns CoderResult.UNDERFLOW. If there is insufficient room in the output buffer then it returns CoderResult.OVERFLOW. If this happens then this method must be invoked again, with an output buffer that has more room, in order to complete the current decoding operation. If this decoder has already been flushed then invoking this method has no effect. This method invokes the implFlush method to perform the actual flushing operation.
Flushes this decoder. The default implementation of this method does nothing, and always returns CoderResult.UNDERFLOW. This method should be overridden by decoders that may need to write final characters to the output buffer once the entire input sequence has been read.
Resets this decoder, clearing any internal state. This method resets charset-independent state and also invokes the implReset method in order to perform any charset-specific reset actions.
Resets this decoder, clearing any charset-specific internal state. The default implementation of this method does nothing. This method should be overridden by decoders that maintain internal state.
Decodes one or more bytes into one or more characters. This method encapsulates the basic decoding loop, decoding as many bytes as possible until it either runs out of input, runs out of room in the output buffer, or encounters a decoding error. This method is invoked by the decode method, which handles result interpretation and error recovery. The buffers are read from, and written to, starting at their current positions. At most in.remaining() bytes will be read, and at most out.remaining() characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified. This method returns a CoderResult object to describe its reason for termination, in the same manner as the decode method. Most implementations of this method will handle decoding errors by returning an appropriate result object for interpretation by the decode method. An optimized implementation may instead examine the relevant error action and implement that action itself. An implementation of this method may perform arbitrary lookahead by returning CoderResult.UNDERFLOW until it receives sufficient input.
Convenience method that decodes the remaining content of a single input byte buffer into a newly-allocated character buffer. This method implements an entire decoding operation; that is, it resets this decoder, then it decodes the bytes in the given byte buffer, and finally it flushes this decoder. This method should therefore not be invoked if a decoding operation is already in progress.
Tells whether or not this decoder implements an auto-detecting charset. The default implementation of this method always returns false; it should be overridden by auto-detecting decoders to return true.
Tells whether or not this decoder has yet detected a charset (optional operation). If this decoder implements an auto-detecting charset then at a single point during a decoding operation this method may start returning true to indicate that a specific charset has been detected in the input byte sequence. Once this occurs, the detectedCharset method may be invoked to retrieve the detected charset. That this method returns false does not imply that no bytes have yet been decoded. Some auto-detecting decoders are capable of decoding some, or even all, of an input byte sequence without fixing on a particular charset. The default implementation of this method always throws an UnsupportedOperationException; it should be overridden by auto-detecting decoders to return true once the input charset has been determined.
Retrieves the charset that was detected by this decoder (optional operation). If this decoder implements an auto-detecting charset then this method returns the actual charset once it has been detected. After that point, this method returns the same value for the duration of the current decoding operation. If not enough input bytes have yet been read to determine the actual charset then this method throws an IllegalStateException. The default implementation of this method always throws an UnsupportedOperationException; it should be overridden by auto-detecting decoders to return the appropriate value.
Initializes a new encoder. The new encoder will have the given bytes-per-char and replacement values.
Initializes a new encoder. The new encoder will have the given bytes-per-char values and its replacement will be the byte array { (byte)'?' }.
Returns the charset that created this encoder.
Returns this encoder's replacement value.
Changes this encoder's replacement value. This method invokes the implReplaceWith method, passing the new replacement, after checking that the new replacement is acceptable.
Reports a change to this encoder's replacement value. The default implementation of this method does nothing. This method should be overridden by encoders that require notification of changes to the replacement.
Tells whether or not the given byte array is a legal replacement value for this encoder. A replacement is legal if, and only if, it is a legal sequence of bytes in this encoder's charset; that is, it must be possible to decode the replacement into one or more sixteen-bit Unicode characters. The default implementation of this method is not very efficient; it should generally be overridden to improve performance.
Returns this encoder's current action for malformed-input errors.
Changes this encoder's action for malformed-input errors. This method invokes the implOnMalformedInput method, passing the new action.
Reports a change to this encoder's malformed-input action. The default implementation of this method does nothing. This method should be overridden by encoders that require notification of changes to the malformed-input action.
Returns this encoder's current action for unmappable-character errors.
Changes this encoder's action for unmappable-character errors. This method invokes the implOnUnmappableCharacter method, passing the new action.
Reports a change to this encoder's unmappable-character action. The default implementation of this method does nothing. This method should be overridden by encoders that require notification of changes to the unmappable-character action.
Returns the average number of bytes that will be produced for each character of input. This heuristic value may be used to estimate the size of the output buffer required for a given input sequence.
Returns the maximum number of bytes that will be produced for each character of input. This value may be used to compute the worst-case size of the output buffer required for a given input sequence.
Encodes as many characters as possible from the given input buffer, writing the results to the given output buffer. The buffers are read from, and written to, starting at their current positions. At most in.remaining() characters will be read and at most out.remaining() bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified. In addition to reading characters from the input buffer and writing bytes to the output buffer, this method returns a CoderResult object to describe its reason for termination: CoderResult.UNDERFLOW indicates that as much of the input buffer as possible has been encoded. If there is no further input then the invoker can proceed to the next step of the encoding operation. Otherwise this method should be invoked again with further input. CoderResult.OVERFLOW indicates that there is insufficient space in the output buffer to encode any more characters. This method should be invoked again with an output buffer that has more remaining bytes. This is typically done by draining any encoded bytes from the output buffer. A malformed-input result indicates that a malformed-input error has been detected. The malformed characters begin at the input buffer's (possibly incremented) position; the number of malformed characters may be determined by invoking the result object's length method. This case applies only if the malformed action of this encoder is CodingErrorAction.REPORT; otherwise the malformed input will be ignored or replaced, as requested. An unmappable-character result indicates that an unmappable-character error has been detected. The characters that encode the unmappable character begin at the input buffer's (possibly incremented) position; the number of such characters may be determined by invoking the result object's length method. This case applies only if the unmappable action of this encoder is CodingErrorAction.REPORT; otherwise the unmappable character will be ignored or replaced, as requested. In any case, if this method is to be reinvoked in the same encoding operation then care should be taken to preserve any characters remaining in the input buffer so that they are available to the next invocation. The endOfInput parameter advises this method as to whether the invoker can provide further input beyond that contained in the given input buffer. If there is a possibility of providing additional input then the invoker should pass false for this parameter; if there is no possibility of providing further input then the invoker should pass true. It is not erroneous, and in fact it is quite common, to pass false in one invocation and later discover that no further input was actually available. It is critical, however, that the final invocation of this method in a sequence of invocations always pass true so that any remaining unencoded input will be treated as being malformed. This method works by invoking the encodeLoop method, interpreting its results, handling error conditions, and reinvoking it as necessary.
Flushes this encoder. Some encoders maintain internal state and may need to write some final bytes to the output buffer once the overall input sequence has been read. Any additional output is written to the output buffer beginning at its current position. At most out.remaining() bytes will be written. The buffer's position will be advanced appropriately, but its mark and limit will not be modified. If this method completes successfully then it returns CoderResult.UNDERFLOW. If there is insufficient room in the output buffer then it returns CoderResult.OVERFLOW. If this happens then this method must be invoked again, with an output buffer that has more room, in order to complete the current encoding operation. If this encoder has already been flushed then invoking this method has no effect. This method invokes the implFlush method to perform the actual flushing operation.
Flushes this encoder. The default implementation of this method does nothing, and always returns CoderResult.UNDERFLOW. This method should be overridden by encoders that may need to write final bytes to the output buffer once the entire input sequence has been read.
Resets this encoder, clearing any internal state. This method resets charset-independent state and also invokes the implReset method in order to perform any charset-specific reset actions.
Resets this encoder, clearing any charset-specific internal state. The default implementation of this method does nothing. This method should be overridden by encoders that maintain internal state.
Encodes one or more characters into one or more bytes. This method encapsulates the basic encoding loop, encoding as many characters as possible until it either runs out of input, runs out of room in the output buffer, or encounters an encoding error. This method is invoked by the encode method, which handles result interpretation and error recovery. The buffers are read from, and written to, starting at their current positions. At most in.remaining() characters will be read, and at most out.remaining() bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified. This method returns a CoderResult object to describe its reason for termination, in the same manner as the encode method. Most implementations of this method will handle encoding errors by returning an appropriate result object for interpretation by the encode method. An optimized implementation may instead examine the relevant error action and implement that action itself. An implementation of this method may perform arbitrary lookahead by returning CoderResult.UNDERFLOW until it receives sufficient input.
Convenience method that encodes the remaining content of a single input character buffer into a newly-allocated byte buffer. This method implements an entire encoding operation; that is, it resets this encoder, then it encodes the characters in the given character buffer, and finally it flushes this encoder. This method should therefore not be invoked if an encoding operation is already in progress.
Tells whether or not this encoder can encode the given character. This method returns false if the given character is a surrogate character; such characters can be interpreted only when they are members of a pair consisting of a high surrogate followed by a low surrogate. The canEncode(CharSequence) method may be used to test whether or not a character sequence can be encoded. This method may modify this encoder's state; it should therefore not be invoked if an encoding operation is already in progress. The default implementation of this method is not very efficient; it should generally be overridden to improve performance.
Tells whether or not this encoder can encode the given character sequence. If this method returns false for a particular character sequence then more information about why the sequence cannot be encoded may be obtained by performing a full encoding operation. This method may modify this encoder's state; it should therefore not be invoked if an encoding operation is already in progress. The default implementation of this method is not very efficient; it should generally be overridden to improve performance.
Initializes an instance of this class.
Result object indicating underflow, meaning that either the input buffer has been completely consumed or, if the input buffer is not yet empty, that additional input is required.
Result object indicating overflow, meaning that there is insufficient room in the output buffer.
Returns a string describing this coder result.
Tells whether or not this object describes an underflow condition.
Tells whether or not this object describes an overflow condition.
Tells whether or not this object describes an error condition.
Tells whether or not this object describes a malformed-input error.
Tells whether or not this object describes an unmappable-character error.
Returns the length of the erroneous input described by this object (optional operation).
Static factory method that returns the unique object describing a malformed-input error of the given length.
Static factory method that returns the unique result object describing an unmappable-character error of the given length.
Throws an exception appropriate to the result described by this object.
Action indicating that a coding error is to be handled by dropping the erroneous input and resuming the coding operation.
Action indicating that a coding error is to be handled by dropping the erroneous input, appending the coder's replacement value to the output buffer, and resuming the coding operation.
Action indicating that a coding error is to be reported, either by returning a CoderResult object or by throwing a CharacterCodingException, whichever is appropriate for the method implementing the coding process.
Returns a string describing this action.
Constructs an instance of this class.
Retrieves the illegal charset name.
Constructs an MalformedInputException with the given length.
Returns the length of the input.
Returns the message.
Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set
ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1
Eight-bit UCS Transformation Format
Sixteen-bit UCS Transformation Format, big-endian byte order
Sixteen-bit UCS Transformation Format, little-endian byte order
Sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order mark
Constructs an UnmappableCharacterException with the given length.
Returns the length of the input.
Returns the message.
Constructs an instance of this class.
Retrieves the name of the unsupported charset.
Initializes a new charset provider.
Creates an iterator that iterates over the charsets supported by this provider. This method is used in the implementation of the Charset.availableCharsets method.
Retrieves a charset for the given charset name.
Constructs an instance of this class.
Constructs an instance of this class.
Test read access.
Test write access.
Test execute access.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (AccessMode c : AccessMode.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Returns the cause of this exception.
Constructs an instance of this class.
Decides if the given directory entry should be accepted or filtered.
Returns the iterator associated with this DirectoryStream.
Constructs an instance of this class.
Constructs an instance of this class.
Opens a file, returning an input stream to read from the file. The stream will not be buffered, and is not required to support the mark or reset methods. The stream will be safe for access by multiple concurrent threads. Reading commences at the beginning of the file. Whether the returned stream is asynchronously closeable and/or interruptible is highly file system provider specific and therefore not specified. The options parameter determines how the file is opened. If no options are present then it is equivalent to opening the file with the READ option. In addition to the READ option, an implementation may also support additional implementation specific options.
Opens or creates a file, returning an output stream that may be used to write bytes to the file. The resulting stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Whether the returned stream is asynchronously closeable and/or interruptible is highly file system provider specific and therefore not specified. This method opens or creates a file in exactly the manner specified by the newByteChannel method with the exception that the READ option may not be present in the array of options. If no options are present then this method works as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing regular-file to a size of 0 if it exists. Usage Examples: Path path = ... // truncate and overwrite an existing file, or create the file if // it doesn't initially exist OutputStream out = Files.newOutputStream(path); // append to an existing file, fail if the file does not exist out = Files.newOutputStream(path, APPEND); // append to an existing file, create file if it doesn't initially exist out = Files.newOutputStream(path, CREATE, APPEND); // always create new file, failing if it already exists out = Files.newOutputStream(path, CREATE_NEW);
Opens or creates a file, returning a seekable byte channel to access the file. The options parameter determines how the file is opened. The READ and WRITE options determine if the file should be opened for reading and/or writing. If neither option (or the APPEND option) is present then the file is opened for reading. By default reading or writing commence at the beginning of the file. In the addition to READ and WRITE, the following options may be present: Option Description APPEND If this option is present then the file is opened for writing and each invocation of the channel's write method first advances the position to the end of the file and then writes the requested data. Whether the advancement of the position and the writing of the data are done in a single atomic operation is system-dependent and therefore unspecified. This option may not be used in conjunction with the READ or TRUNCATE_EXISTING options. TRUNCATE_EXISTING If this option is present then the existing file is truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading. CREATE_NEW If this option is present then a new file is created, failing if the file already exists or is a symbolic link. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading. CREATE If this option is present then an existing file is opened if it exists, otherwise a new file is created. This option is ignored if the CREATE_NEW option is also present or the file is opened only for reading. DELETE_ON_CLOSE When this option is present then the implementation makes a best effort attempt to delete the file when closed by the close method. If the close method is not invoked then a best effort attempt is made to delete the file when the Java virtual machine terminates. SPARSE When creating a new file this option is a hint that the new file will be sparse. This option is ignored when not creating a new file. SYNC Requires that every update to the file's content or metadata be written synchronously to the underlying storage device. (see Synchronized I/O file integrity). DSYNC Requires that every update to the file's content be written synchronously to the underlying storage device. (see Synchronized I/O file integrity). An implementation may also support additional implementation specific options. The attrs parameter is optional file-attributes to set atomically when a new file is created. In the case of the default provider, the returned seekable byte channel is a FileChannel. Usage Examples: Path path = ... // open file for reading ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ))); // open file for writing to the end of an existing file, creating // the file if it doesn't already exist WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND)); // create file with initial permissions, opening it for both reading and writing FileAttribute<Set<PosixFilePermission>> perms = ... SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);
Opens or creates a file, returning a seekable byte channel to access the file. This method opens or creates a file in exactly the manner specified by the newByteChannel method.
Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream's iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir. When not using the try-with-resources construct, then directory stream's close method should be invoked after iteration is completed so as to free any resources held for the open directory. When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.
"Opens a directory, returning a DirectoryStream to iterate over the entries in the directory. The elements returned by the directory stream's iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir. The entries returned by the iterator are filtered by matching the String representation of their file names against the given globbing pattern. For example, suppose we want to iterate over the files ending with "".java"" in a directory: Path dir = ... try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, ""*.java"")) { : } The globbing pattern is specified by the getPathMatcher method. When not using the try-with-resources construct, then directory stream's close method should be invoked after iteration is completed so as to free any resources held for the open directory. When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream."
Opens a directory, returning a DirectoryStream to iterate over the entries in the directory. The elements returned by the directory stream's iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir. The entries returned by the iterator are filtered by the given filter. When not using the try-with-resources construct, then directory stream's close method should be invoked after iteration is completed so as to free any resources held for the open directory. Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the hasNext or next method. Where an IOException is thrown, it results in the hasNext or next method throwing a DirectoryIteratorException with the IOException as the cause. When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream. Usage Example: Suppose we want to iterate over the files in a directory that are larger than 8K. DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() { public boolean accept(Path file) throws IOException { return (Files.size(file) > 8192L); } }; Path dir = ... try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, filter)) { : }
Creates a new and empty file, failing if the file already exists. The check for the existence of the file and the creation of the new file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the directory. The attrs parameter is optional file-attributes to set atomically when creating the file. Each attribute is identified by its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.
Creates a new directory. The check for the existence of the file and the creation of the directory if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the directory. The createDirectories method should be used where it is required to create all nonexistent parent directories first. The attrs parameter is optional file-attributes to set atomically when creating the directory. Each attribute is identified by its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.
Creates a directory by creating all nonexistent parent directories first. Unlike the createDirectory method, an exception is not thrown if the directory could not be created because it already exists. The attrs parameter is optional file-attributes to set atomically when creating the nonexistent directories. Each file attribute is identified by its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored. If this method fails, then it may do so after creating some, but not all, of the parent directories.
Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate its name. The resulting Path is associated with the same FileSystem as the given directory. The details as to how the name of the file is constructed is implementation dependent and therefore not specified. Where possible the prefix and suffix are used to construct candidate names in the same manner as the File.createTempFile(String,String,File) method. As with the File.createTempFile methods, this method is only part of a temporary-file facility. Where used as a work files, the resulting file may be opened using the DELETE_ON_CLOSE option so that the file is deleted when the appropriate close method is invoked. Alternatively, a shutdown-hook, or the File.deleteOnExit() mechanism may be used to delete the file automatically. The attrs parameter is optional file-attributes to set atomically when creating the file. Each attribute is identified by its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored. When no file attributes are specified, then the resulting file may have more restrictive access permissions to files created by the File.createTempFile(String,String,File) method.
Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name. The resulting Path is associated with the default FileSystem. This method works in exactly the manner specified by the createTempFile(Path,String,String,FileAttribute[]) method for the case that the dir parameter is the temporary-file directory.
Creates a new directory in the specified directory, using the given prefix to generate its name. The resulting Path is associated with the same FileSystem as the given directory. The details as to how the name of the directory is constructed is implementation dependent and therefore not specified. Where possible the prefix is used to construct candidate names. As with the createTempFile methods, this method is only part of a temporary-file facility. A shutdown-hook, or the File.deleteOnExit() mechanism may be used to delete the directory automatically. The attrs parameter is optional file-attributes to set atomically when creating the directory. Each attribute is identified by its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.
Creates a new directory in the default temporary-file directory, using the given prefix to generate its name. The resulting Path is associated with the default FileSystem. This method works in exactly the manner specified by createTempDirectory(Path,String,FileAttribute[]) method for the case that the dir parameter is the temporary-file directory.
Creates a symbolic link to a target (optional operation). The target parameter is the target of the link. It may be an absolute or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link. The attrs parameter is optional attributes to set atomically when creating the link. Each attribute is identified by its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored. Where symbolic links are supported, but the underlying FileStore does not support symbolic links, then this may fail with an IOException. Additionally, some operating systems may require that the Java virtual machine be started with implementation specific privileges to create symbolic links, in which case this method may throw IOException.
"Creates a new link (directory entry) for an existing file (optional operation). The link parameter locates the directory entry to create. The existing parameter is the path to an existing file. This method creates a new directory entry for the file so that it can be accessed using link as the path. On some file systems this is known as creating a ""hard link"". Whether the file attributes are maintained for the file or for each directory entry is file system specific and therefore not specified. Typically, a file system requires that all links (directory entries) for a file be on the same file system. Furthermore, on some platforms, the Java virtual machine may require to be started with implementation specific privileges to create hard links or to create links to directories."
Deletes a file. An implementation may require to examine the file to determine if the file is a directory. Consequently this method may not be atomic with respect to other file system operations. If the file is a symbolic link then the symbolic link itself, not the final target of the link, is deleted. If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the walkFileTree method to delete a directory and all entries in the directory, or an entire file-tree where required. On some operating systems it may not be possible to remove a file when it is open and in use by this Java virtual machine or other programs.
Deletes a file if it exists. As with the delete(Path) method, an implementation may need to examine the file to determine if the file is a directory. Consequently this method may not be atomic with respect to other file system operations. If the file is a symbolic link, then the symbolic link itself, not the final target of the link, is deleted. If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. On some operating systems it may not be possible to remove a file when it is open and in use by this Java virtual machine or other programs.
Copy a file to a target file. This method copies a file to the target file with the options parameter specifying how the copy is performed. By default, the copy fails if the target file already exists or is a symbolic link, except if the source and target are the same file, in which case the method completes without copying the file. File attributes are not required to be copied to the target file. If symbolic links are supported, and the file is a symbolic link, then the final target of the link is copied. If the file is a directory then it creates an empty directory in the target location (entries in the directory are not copied). This method can be used with the walkFileTree method to copy a directory and all entries in the directory, or an entire file-tree where required. The options parameter may include any of the following: Option Description REPLACE_EXISTING If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced. COPY_ATTRIBUTES Attempts to copy the file attributes associated with this file to the target file. The exact file attributes that are copied is platform and file system dependent and therefore unspecified. Minimally, the last-modified-time is copied to the target file if supported by both the source and target file stores. Copying of file timestamps may result in precision loss. NOFOLLOW_LINKS Symbolic links are not followed. If the file is a symbolic link, then the symbolic link itself, not the target of the link, is copied. It is implementation specific if file attributes can be copied to the new link. In other words, the COPY_ATTRIBUTES option may be ignored when copying a symbolic link. An implementation of this interface may support additional implementation specific options. Copying a file is not an atomic operation. If an IOException is thrown, then it is possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the REPLACE_EXISTING option is specified and the target file exists, then the target file is replaced. The check for the existence of the file and the creation of the new file may not be atomic with respect to other file system activities. Usage Example: Suppose we want to copy a file into a directory, giving it the same file name as the source file: Path source = ... Path newdir = ... Files.copy(source, newdir.resolve(source.getFileName());
"Move or rename a file to a target file. By default, this method attempts to move the file to the target file, failing if the target file exists except if the source and target are the same file, in which case this method has no effect. If the file is a symbolic link then the symbolic link itself, not the target of the link, is moved. This method may be invoked to move an empty directory. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. When invoked to move a directory that is not empty then the directory is moved if it does not require moving the entries in the directory. For example, renaming a directory on the same FileStore will usually not require moving the entries in the directory. When moving a directory requires that its entries be moved then this method fails (by throwing an IOException). To move a file tree may involve copying rather than moving directories and this can be done using the copy method in conjunction with the Files.walkFileTree utility method. The options parameter may include any of the following: Option Description REPLACE_EXISTING If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced. ATOMIC_MOVE The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an IOException. If the move cannot be performed as an atomic file system operation then AtomicMoveNotSupportedException is thrown. This can arise, for example, when the target location is on a different FileStore and would require that the file be copied, or target location is associated with a different provider to this object. An implementation of this interface may support additional implementation specific options. Moving a file will copy the last-modified-time to the target file if supported by both source and target file stores. Copying of file timestamps may result in precision loss. An implementation may also attempt to copy other file attributes but is not required to fail if the file attributes cannot be copied. When the move is performed as a non-atomic operation, and an IOException is thrown, then the state of the files is not defined. The original file and the target file may both exist, the target file may be incomplete or some of its file attributes may not been copied from the original file. Usage Examples: Suppose we want to rename a file to ""newname"", keeping the file in the same directory: Path source = ... Files.move(source, source.resolveSibling(""newname"")); Alternatively, suppose we want to move a file to new directory, keeping the same file name, and replacing any existing file of that name in the directory: Path source = ... Path newdir = ... Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);"
Reads the target of a symbolic link (optional operation). If the file system supports symbolic links then this method is used to read the target of the link, failing if the file is not a symbolic link. The target of the link need not exist. The returned Path object will be associated with the same file system as link.
Returns the FileStore representing the file store where a file is located. Once a reference to the FileStore is obtained it is implementation specific if operations on the returned FileStore, or FileStoreAttributeView objects obtained from it, continue to depend on the existence of the file. In particular the behavior is not defined for the case that the file is deleted or moved to a different file store.
Tests if two paths locate the same file. If both Path objects are equal then this method returns true without checking if the file exists. If the two Path objects are associated with different providers then this method returns false. Otherwise, this method checks if both Path objects locate the same file, and depending on the implementation, may require to open or access both files. If the file system and files remain static, then this method implements an equivalence relation for non-null Paths. It is reflexive: for Path f, isSameFile(f,f) should return true. It is symmetric: for two Paths f and g, isSameFile(f,g) will equal isSameFile(g,f). It is transitive: for three Paths f, g, and h, if isSameFile(f,g) returns true and isSameFile(g,h) returns true, then isSameFile(f,h) will return return true.
Tells whether or not a file is considered hidden. The exact definition of hidden is platform or provider dependent. On UNIX for example a file is considered to be hidden if its name begins with a period character ('.'). On Windows a file is considered hidden if it isn't a directory and the DOS hidden attribute is set. Depending on the implementation this method may require to access the file system to determine if the file is considered hidden.
Probes the content type of a file. This method uses the installed FileTypeDetector implementations to probe the given file to determine its content type. Each file type detector's probeContentType is invoked, in turn, to probe the file type. If the file is recognized then the content type is returned. If the file is not recognized by any of the installed file type detectors then a system-default file type detector is invoked to guess the content type. A given invocation of the Java virtual machine maintains a system-wide list of file type detectors. Installed file type detectors are loaded using the service-provider loading facility defined by the ServiceLoader class. Installed file type detectors are loaded using the system class loader. If the system class loader cannot be found then the extension class loader is used; If the extension class loader cannot be found then the bootstrap class loader is used. File type detectors are typically installed by placing them in a JAR file on the application class path or in the extension directory, the JAR file contains a provider-configuration file named java.nio.file.spi.FileTypeDetector in the resource directory META-INF/services, and the file lists one or more fully-qualified names of concrete subclass of FileTypeDetector that have a zero argument constructor. If the process of locating or instantiating the installed file type detectors fails then an unspecified error is thrown. The ordering that installed providers are located is implementation specific. The return value of this method is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies. The string is guaranteed to be parsable according to the grammar in the RFC.
Returns a file attribute view of a given type. A file attribute view provides a read-only or updatable view of a set of file attributes. This method is intended to be used where the file attribute view defines type-safe methods to read or update the file attributes. The type parameter is the type of the attribute view required and the method returns an instance of that type if supported. The BasicFileAttributeView type supports access to the basic attributes of a file. Invoking this method to select a file attribute view of that type will always return an instance of that class. The options array may be used to indicate how symbolic links are handled by the resulting file attribute view for the case that the file is a symbolic link. By default, symbolic links are followed. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. This option is ignored by implementations that do not support symbolic links. Usage Example: Suppose we want read or set a file's ACL, if supported: Path path = ... AclFileAttributeView view = Files.getFileAttributeView(path, AclFileAttributeView.class); if (view != null) { List<AclEntry> acl = view.getAcl(); : }
Reads a file's attributes as a bulk operation. The type parameter is the type of the attributes required and this method returns an instance of that type if supported. All implementations support a basic set of file attributes and so invoking this method with a type parameter of BasicFileAttributes.class will not throw UnsupportedOperationException. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. It is implementation specific if all file attributes are read as an atomic operation with respect to other file system operations. Usage Example: Suppose we want to read a file's attributes in bulk: Path path = ... BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class); Alternatively, suppose we want to read file's POSIX attributes without following symbolic links: PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);
"Sets the value of a file attribute. The attribute parameter identifies the attribute to be set and takes the form: [view-name:]attribute-name where square brackets [...] delineate an optional component and the character ':' stands for itself. view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to ""basic"", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. Usage Example: Suppose we want to set the DOS ""hidden"" attribute: Path path = ... Files.setAttribute(path, ""dos:hidden"", true);"
"Reads the value of a file attribute. The attribute parameter identifies the attribute to be read and takes the form: [view-name:]attribute-name where square brackets [...] delineate an optional component and the character ':' stands for itself. view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to ""basic"", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. Usage Example: Suppose we require the user ID of the file owner on a system that supports a ""unix"" view: Path path = ... int uid = (Integer)Files.getAttribute(path, ""unix:uid"");"
"Reads a set of file attributes as a bulk operation. The attributes parameter identifies the attributes to be read and takes the form: [view-name:]attribute-list where square brackets [...] delineate an optional component and the character ':' stands for itself. view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to ""basic"", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. The attribute-list component is a comma separated list of zero or more names of attributes to read. If the list contains the value ""*"" then all attributes are read. Attributes that are not supported are ignored and will not be present in the returned map. It is implementation specific if all attributes are read as an atomic operation with respect to other file system operations. The following examples demonstrate possible values for the attributes parameter: ""*"" Read all basic-file-attributes. ""size,lastModifiedTime,lastAccessTime"" Reads the file size, last modified time, and last access time attributes. ""posix:*"" Read all POSIX-file-attributes. ""posix:permissions,owner,size"" Reads the POSX file permissions, owner, and file size. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option NOFOLLOW_LINKS is present then symbolic links are not followed."
Returns a file's POSIX file permissions. The path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.
Sets a file's POSIX permissions. The path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.
Returns the owner of a file. The path parameter is associated with a file system that supports FileOwnerAttributeView. This file attribute view provides access to a file attribute that is the owner of the file.
"Updates the file owner. The path parameter is associated with a file system that supports FileOwnerAttributeView. This file attribute view provides access to a file attribute that is the owner of the file. Usage Example: Suppose we want to make ""joe"" the owner of a file: Path path = ... UserPrincipalLookupService lookupService = provider(path).getUserPrincipalLookupService(); UserPrincipal joe = lookupService.lookupPrincipalByName(""joe""); Files.setOwner(path, joe);"
Tests whether a file is a symbolic link. Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the readAttributes method and the file type tested with the BasicFileAttributes.isSymbolicLink() method.
Tests whether a file is a directory. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the readAttributes method and the file type tested with the BasicFileAttributes.isDirectory() method.
Tests whether a file is a regular file with opaque content. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the readAttributes method and the file type tested with the BasicFileAttributes.isRegularFile() method.
Returns a file's last modified time. The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.
Updates a file's last modified time attribute. The file time is converted to the epoch and precision supported by the file system. Converting from finer to coarser granularities result in precision loss. The behavior of this method when attempting to set the last modified time when it is not supported by the file system or is outside the range supported by the underlying file store is not defined. It may or not fail by throwing an IOException. Usage Example: Suppose we want to set the last modified time to the current time: Path path = ... FileTime now = FileTime.fromMillis(System.currentTimeMillis()); Files.setLastModifiedTime(path, now);
Returns the size of a file (in bytes). The size may differ from the actual size on the file system due to compression, support for sparse files, or other reasons. The size of files that are not regular files is implementation specific and therefore unspecified.
Tests whether a file exists. The options parameter may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. Note that the result of this method is immediately outdated. If this method indicates the file exists then there is no guarantee that a subsequence access will succeed. Care should be taken when using this method in security sensitive applications.
Tests whether the file located by this path does not exist. This method is intended for cases where it is required to take action when it can be confirmed that a file does not exist. The options parameter may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed. If the option NOFOLLOW_LINKS is present then symbolic links are not followed. Note that this method is not the complement of the exists method. Where it is not possible to determine if a file exists or not then both methods return false. As with the exists method, the result of this method is immediately outdated. If this method indicates the file does exist then there is no guarantee that a subsequence attempt to create the file will succeed. Care should be taken when using this method in security sensitive applications.
Tests whether a file is readable. This method checks that a file exists and that this Java virtual machine has appropriate privileges that would allow it open the file for reading. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. Consequently, this method may not be atomic with respect to other file system operations. Note that the result of this method is immediately outdated, there is no guarantee that a subsequent attempt to open the file for reading will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.
Tests whether a file is writable. This method checks that a file exists and that this Java virtual machine has appropriate privileges that would allow it open the file for writing. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. Consequently, this method may not be atomic with respect to other file system operations. Note that result of this method is immediately outdated, there is no guarantee that a subsequent attempt to open the file for writing will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.
Tests whether a file is executable. This method checks that a file exists and that this Java virtual machine has appropriate privileges to execute the file. The semantics may differ when checking access to a directory. For example, on UNIX systems, checking for execute access checks that the Java virtual machine has permission to search the directory in order to access file or subdirectories. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. Consequently, this method may not be atomic with respect to other file system operations. Note that the result of this method is immediately outdated, there is no guarantee that a subsequent attempt to execute the file will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.
Walks a file tree. This method walks a file tree rooted at a given starting file. The file tree traversal is depth-first with the given FileVisitor invoked for each file encountered. File tree traversal completes when all accessible files in the tree have been visited, or a visit method returns a result of TERMINATE. Where a visit method terminates due an IOException, an uncaught error, or runtime exception, then the traversal is terminated and the error or exception is propagated to the caller of this method. For each file encountered this method attempts to read its BasicFileAttributes. If the file is not a directory then the visitFile method is invoked with the file attributes. If the file attributes cannot be read, due to an I/O exception, then the visitFileFailed method is invoked with the I/O exception. Where the file is a directory, and the directory could not be opened, then the visitFileFailed method is invoked with the I/O exception, after which, the file tree walk continues, by default, at the next sibling of the directory. Where the directory is opened successfully, then the entries in the directory, and their descendants are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's postVisitDirectory method is invoked. The file tree walk then continues, by default, at the next sibling of the directory. By default, symbolic links are not automatically followed by this method. If the options parameter contains the FOLLOW_LINKS option then symbolic links are followed. When following links, and the attributes of the target cannot be read, then this method attempts to get the BasicFileAttributes of the link. If they can be read then the visitFile method is invoked with the attributes of the link (otherwise the visitFileFailed method is invoked as specified above). If the options parameter contains the FOLLOW_LINKS option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the file-key of directories, or if file keys are not available, by invoking the isSameFile method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the visitFileFailed method is invoked with an instance of FileSystemLoopException. The maxDepth parameter is the maximum number of levels of directories to visit. A value of 0 means that only the starting file is visited, unless denied by the security manager. A value of MAX_VALUE may be used to indicate that all levels should be visited. The visitFile method is invoked for all files, including directories, encountered at maxDepth, unless the basic file attributes cannot be read, in which case the visitFileFailed method is invoked. If a visitor returns a result of null then NullPointerException is thrown. When a security manager is installed and it denies access to a file (or directory), then it is ignored and the visitor is not invoked for that file (or directory).
Walks a file tree. This method works as if invoking it were equivalent to evaluating the expression: walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor) In other words, it does not follow symbolic links, and visits all levels of the file tree.
Opens a file for reading, returning a BufferedReader that may be used to read text from the file in an efficient manner. Bytes from the file are decoded into characters using the specified charset. Reading commences at the beginning of the file. The Reader methods that read from the file throw IOException if a malformed or unmappable byte sequence is read.
Opens a file for reading, returning a BufferedReader to read text from the file in an efficient manner. Bytes from the file are decoded into characters using the UTF-8 charset. This method works as if invoking it were equivalent to evaluating the expression: Files.newBufferedReader(path, StandardCharsets.UTF_8)
Opens or creates a file for writing, returning a BufferedWriter that may be used to write text to the file in an efficient manner. The options parameter specifies how the the file is created or opened. If no options are present then this method works as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing regular-file to a size of 0 if it exists. The Writer methods to write text throw IOException if the text cannot be encoded using the specified charset.
Opens or creates a file for writing, returning a BufferedWriter to write text to the file in an efficient manner. The text is encoded into bytes for writing using the UTF-8 charset. This method works as if invoking it were equivalent to evaluating the expression: Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)
"Copies all bytes from an input stream to a file. On return, the input stream will be at end of stream. By default, the copy fails if the target file already exists or is a symbolic link. If the REPLACE_EXISTING option is specified, and the target file already exists, then it is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link is replaced. In this release, the REPLACE_EXISTING option is the only option required to be supported by this method. Additional options may be supported in future releases. If an I/O error occurs reading from the input stream or writing to the file, then it may do so after the target file has been created and after some bytes have been read or written. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the input stream be promptly closed if an I/O error occurs. This method may block indefinitely reading from the input stream (or writing to the file). The behavior for the case that the input stream is asynchronously closed or the thread interrupted during the copy is highly input stream and file system provider specific and therefore not specified. Usage example: Suppose we want to capture a web page and save it to a file: Path path = ... URI u = URI.create(""http://java.sun.com/""); try (InputStream in = u.toURL().openStream()) { Files.copy(in, path); }"
Copies all bytes from a file to an output stream. If an I/O error occurs reading from the file or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the output stream may be in an inconsistent state. It is strongly recommended that the output stream be promptly closed if an I/O error occurs. This method may block indefinitely writing to the output stream (or reading from the file). The behavior for the case that the output stream is asynchronously closed or the thread interrupted during the copy is highly output stream and file system provider specific and therefore not specified. Note that if the given output stream is Flushable then its flush method may need to invoked after this method completes so as to flush any buffered output.
Reads all the bytes from a file. The method ensures that the file is closed when all bytes have been read or an I/O error, or other runtime exception, is thrown. Note that this method is intended for simple cases where it is convenient to read all bytes into a byte array. It is not intended for reading in large files.
Read all lines from a file. This method ensures that the file is closed when all bytes have been read or an I/O error, or other runtime exception, is thrown. Bytes from the file are decoded into characters using the specified charset. This method recognizes the following as line terminators: \u000D followed by \u000A, CARRIAGE RETURN followed by LINE FEED \u000A, LINE FEED \u000D, CARRIAGE RETURN Additional Unicode line terminators may be recognized in future releases. Note that this method is intended for simple cases where it is convenient to read all lines in a single operation. It is not intended for reading in large files.
Read all lines from a file. Bytes from the file are decoded into characters using the UTF-8 charset. This method works as if invoking it were equivalent to evaluating the expression: Files.readAllLines(path, StandardCharsets.UTF_8)
Writes bytes to a file. The options parameter specifies how the the file is created or opened. If no options are present then this method works as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing regular-file to a size of 0. All bytes in the byte array are written to the file. The method ensures that the file is closed when all bytes have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file. Usage example: By default the method creates a new file or overwrites an existing file. Suppose you instead want to append bytes to an existing file: Path path = ... byte[] bytes = ... Files.write(path, bytes, StandardOpenOption.APPEND);
Write lines of text to a file. Each line is a char sequence and is written to the file in sequence with each line terminated by the platform's line separator, as defined by the system property line.separator. Characters are encoded into bytes using the specified charset. The options parameter specifies how the the file is created or opened. If no options are present then this method works as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing regular-file to a size of 0. The method ensures that the file is closed when all lines have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file.
Write lines of text to a file. Characters are encoded into bytes using the UTF-8 charset. This method works as if invoking it were equivalent to evaluating the expression: Files.write(path, lines, StandardCharsets.UTF_8, options);
Return a lazily populated Stream, the elements of which are the entries in the directory. The listing is not recursive. The elements of the stream are Path objects that are obtained as if by resolving the name of the directory entry against dir. Some file systems maintain special links to the directory itself and the directory's parent directory. Entries representing these links are not included. The stream is weakly consistent. It is thread safe but does not freeze the directory while iterating, so it may (or may not) reflect updates to the directory that occur after returning from this method. The returned stream encapsulates a DirectoryStream. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's close method is invoked after the stream operations are completed. Operating on a closed stream behaves as if the end of stream has been reached. Due to read-ahead, one or more elements may be returned after the stream has been closed. If an IOException is thrown when accessing the directory after this method has returned, it is wrapped in an UncheckedIOException which will be thrown from the method that caused the access to take place.
Return a Stream that is lazily populated with Path by walking the file tree rooted at a given starting file. The file tree is traversed depth-first, the elements in the stream are Path objects that are obtained as if by resolving the relative path against start. The stream walks the file tree as elements are consumed. The Stream returned is guaranteed to have at least one element, the starting file itself. For each file visited, the stream attempts to read its BasicFileAttributes. If the file is a directory and can be opened successfully, entries in the directory, and their descendants will follow the directory in the stream as they are encountered. When all entries have been visited, then the directory is closed. The file tree walk then continues at the next sibling of the directory. The stream is weakly consistent. It does not freeze the file tree while iterating, so it may (or may not) reflect updates to the file tree that occur after returned from this method. By default, symbolic links are not automatically followed by this method. If the options parameter contains the FOLLOW_LINKS option then symbolic links are followed. When following links, and the attributes of the target cannot be read, then this method attempts to get the BasicFileAttributes of the link. If the options parameter contains the FOLLOW_LINKS option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the file-key of directories, or if file keys are not available, by invoking the isSameFile method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of FileSystemLoopException. The maxDepth parameter is the maximum number of levels of directories to visit. A value of 0 means that only the starting file is visited, unless denied by the security manager. A value of MAX_VALUE may be used to indicate that all levels should be visited. When a security manager is installed and it denies access to a file (or directory), then it is ignored and not included in the stream. The returned stream encapsulates one or more DirectoryStreams. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's close method is invoked after the stream operations are completed. Operating on a closed stream will result in an IllegalStateException. If an IOException is thrown when accessing the directory after this method has returned, it is wrapped in an UncheckedIOException which will be thrown from the method that caused the access to take place.
Return a Stream that is lazily populated with Path by walking the file tree rooted at a given starting file. The file tree is traversed depth-first, the elements in the stream are Path objects that are obtained as if by resolving the relative path against start. This method works as if invoking it were equivalent to evaluating the expression: walk(start, Integer.MAX_VALUE, options) In other words, it visits all levels of the file tree. The returned stream encapsulates one or more DirectoryStreams. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's close method is invoked after the stream operations are completed. Operating on a closed stream will result in an IllegalStateException.
Return a Stream that is lazily populated with Path by searching for files in a file tree rooted at a given starting file. This method walks the file tree in exactly the manner specified by the walk method. For each file encountered, the given BiPredicate is invoked with its Path and BasicFileAttributes. The Path object is obtained as if by resolving the relative path against start and is only included in the returned Stream if the BiPredicate returns true. Compare to calling filter on the Stream returned by walk method, this method may be more efficient by avoiding redundant retrieval of the BasicFileAttributes. The returned stream encapsulates one or more DirectoryStreams. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's close method is invoked after the stream operations are completed. Operating on a closed stream will result in an IllegalStateException. If an IOException is thrown when accessing the directory after returned from this method, it is wrapped in an UncheckedIOException which will be thrown from the method that caused the access to take place.
Read all lines from a file as a Stream. Unlike readAllLines, this method does not read all lines into a List, but instead populates lazily as the stream is consumed. Bytes from the file are decoded into characters using the specified charset and the same line terminators as specified by readAllLines are supported. After this method returns, then any subsequent I/O exception that occurs while reading from the file or when a malformed or unmappable byte sequence is read, is wrapped in an UncheckedIOException that will be thrown from the Stream method that caused the read to take place. In case an IOException is thrown when closing the file, it is also wrapped as an UncheckedIOException. The returned stream encapsulates a Reader. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's close method is invoked after the stream operations are completed.
Read all lines from a file as a Stream. Bytes from the file are decoded into characters using the UTF-8 charset. This method works as if invoking it were equivalent to evaluating the expression: Files.lines(path, StandardCharsets.UTF_8)
Initializes a new instance of this class.
Returns the name of this file store. The format of the name is highly implementation specific. It will typically be the name of the storage pool or volume. The string returned by this method may differ from the string returned by the toString method.
Returns the type of this file store. The format of the string returned by this method is highly implementation specific. It may indicate, for example, the format used or if the file store is local or remote.
Tells whether this file store is read-only. A file store is read-only if it does not support write operations or other changes to files. Any attempt to create a file, open an existing file for writing etc. causes an IOException to be thrown.
Returns the size, in bytes, of the file store.
Returns the number of bytes available to this Java virtual machine on the file store. The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of usable bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this Java virtual machine.
Returns the number of unallocated bytes in the file store. The returned number of unallocated bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine.
Tells whether or not this file store supports the file attributes identified by the given file attribute view. Invoking this method to test if the file store supports BasicFileAttributeView will always return true. In the case of the default provider, this method cannot guarantee to give the correct result when the file store is not a local storage device. The reasons for this are implementation specific and therefore unspecified.
"Tells whether or not this file store supports the file attributes identified by the given file attribute view. Invoking this method to test if the file store supports BasicFileAttributeView, identified by the name ""basic"" will always return true. In the case of the default provider, this method cannot guarantee to give the correct result when the file store is not a local storage device. The reasons for this are implementation specific and therefore unspecified."
Returns a FileStoreAttributeView of the given type. This method is intended to be used where the file store attribute view defines type-safe methods to read or update the file store attributes. The type parameter is the type of the attribute view required and the method returns an instance of that type if supported.
"Reads the value of a file store attribute. The attribute parameter identifies the attribute to be read and takes the form: view-name:attribute-name where the character ':' stands for itself. view-name is the name of a AttributeView that identifies a set of file attributes. attribute-name is the name of the attribute. Usage Example: Suppose we want to know if ZFS compression is enabled (assuming the ""zfs"" view is supported): boolean compression = (Boolean)fs.getAttribute(""zfs:compression"");"
Initializes a new instance of this class.
Returns the provider that created this file system.
Closes this file system. After a file system is closed then all subsequent access to the file system, either by methods defined by this class or on objects associated with this file system, throw ClosedFileSystemException. If the file system is already closed then invoking this method has no effect. Closing a file system will close all open channels, directory-streams, watch-service, and other closeable objects associated with this file system. The default file system cannot be closed.
Tells whether or not this file system is open. File systems created by the default provider are always open.
Tells whether or not this file system allows only read-only access to its file stores.
Returns the name separator, represented as a string. The name separator is used to separate names in a path string. An implementation may support multiple name separators in which case this method returns an implementation specific default name separator. This separator is used when creating path strings by invoking the toString() method. In the case of the default provider, this method returns the same separator as File.separator.
Returns an object to iterate over the paths of the root directories. A file system provides access to a file store that may be composed of a number of distinct file hierarchies, each with its own top-level root directory. Unless denied by the security manager, each element in the returned iterator corresponds to the root directory of a distinct file hierarchy. The order of the elements is not defined. The file hierarchies may change during the lifetime of the Java virtual machine. For example, in some implementations, the insertion of removable media may result in the creation of a new file hierarchy with its own top-level directory. When a security manager is installed, it is invoked to check access to the each root directory. If denied, the root directory is not returned by the iterator. In the case of the default provider, the SecurityManager.checkRead(String) method is invoked to check read access to each root directory. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.
"Returns an object to iterate over the underlying file stores. The elements of the returned iterator are the FileStores for this file system. The order of the elements is not defined and the file stores may change during the lifetime of the Java virtual machine. When an I/O error occurs, perhaps because a file store is not accessible, then it is not returned by the iterator. In the case of the default provider, and a security manager is installed, the security manager is invoked to check RuntimePermission(""getFileStoreAttributes""). If denied, then no file stores are returned by the iterator. In addition, the security manager's SecurityManager.checkRead(String) method is invoked to check read access to the file store's top-most directory. If denied, the file store is not returned by the iterator. It is system dependent if the permission checks are done when the iterator is obtained or during iteration. Usage Example: Suppose we want to print the space usage for all file stores: for (FileStore store: FileSystems.getDefault().getFileStores()) { long total = store.getTotalSpace() / 1024; long used = (store.getTotalSpace() - store.getUnallocatedSpace()) / 1024; long avail = store.getUsableSpace() / 1024; System.out.format(""%-20s %12d %12d %12d%n"", store, total, used, avail); }"
"Returns the set of the names of the file attribute views supported by this FileSystem. The BasicFileAttributeView is required to be supported and therefore the set contains at least one element, ""basic"". The supportsFileAttributeView(String) method may be used to test if an underlying FileStore supports the file attributes identified by a file attribute view."
"Converts a path string, or a sequence of strings that when joined form a path string, to a Path. If more does not specify any elements then the value of the first parameter is the path string to convert. If more specifies one or more elements then each non-empty string, including first, is considered to be a sequence of name elements (see Path) and is joined to form a path string. The details as to how the Strings are joined is provider specific but typically they will be joined using the name-separator as the separator. For example, if the name separator is ""/"" and getPath(""/foo"",""bar"",""gus"") is invoked, then the path string ""/foo/bar/gus"" is converted to a Path. A Path representing an empty path is returned if first is the empty string and more does not contain any non-empty strings. The parsing and conversion to a path object is inherently implementation dependent. In the simplest case, the path string is rejected, and InvalidPathException thrown, if the path string contains characters that cannot be converted to characters that are legal to the file store. For example, on UNIX systems, the NUL (\u0000) character is not allowed to be present in a path. An implementation may choose to reject path strings that contain names that are longer than those allowed by any file store, and where an implementation supports a complex path syntax, it may choose to reject path strings that are badly formed. In the case of the default provider, path strings are parsed based on the definition of paths at the platform or virtual file system level. For example, an operating system may not allow specific characters to be present in a file name, but a specific underlying file store may impose different or additional restrictions on the set of legal characters. This method throws InvalidPathException when the path string cannot be converted to a path. Where possible, and where applicable, the exception is created with an index value indicating the first position in the path parameter that caused the path string to be rejected."
"Returns a PathMatcher that performs match operations on the String representation of Path objects by interpreting a given pattern. The syntaxAndPattern parameter identifies the syntax and the pattern and takes the form: syntax:pattern where ':' stands for itself. A FileSystem implementation supports the ""glob"" and ""regex"" syntaxes, and may support others. The value of the syntax component is compared without regard to case. When the syntax is ""glob"" then the String representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example: *.java Matches a path that represents a file name ending in .java *.* Matches file names containing a dot *.{java,class} Matches file names ending with .java or .class foo.? Matches file names starting with foo. and a single character extension /home/*/* Matches /home/gus/data on UNIX platforms /home/** Matches /home/gus and /home/gus/data on UNIX platforms C:\\* Matches C:\foo and C:\bar on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be ""C:\\\\*"") The following rules are used to interpret glob patterns: The * character matches zero or more characters of a name component without crossing directory boundaries. The ** characters matches zero or more characters crossing directory boundaries. The ? character matches exactly one character of a name component. The backslash character (\) is used to escape characters that would otherwise be interpreted as special characters. The expression \\ matches a single backslash and ""\{"" matches a left brace for example. The [ ] characters are a bracket expression that match a single character of a name component out of a set of characters. For example, [abc] matches ""a"", ""b"", or ""c"". The hyphen (-) may be used to specify a range so [a-z] specifies a range that matches from ""a"" to ""z"" (inclusive). These forms can be mixed so [abce-g] matches ""a"", ""b"", ""c"", ""e"", ""f"" or ""g"". If the character after the [ is a ! then it is used for negation so [!a-c] matches any character except ""a"", ""b"", or ""c"". Within a bracket expression the *, ? and \ characters match themselves. The (-) character matches itself if it is the first character within the brackets, or the first character after the ! if negating. The { } characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The "","" character is used to separate the subpatterns. Groups cannot be nested. Leading period/dot characters in file name are treated as regular characters in match operations. For example, the ""*"" glob pattern matches file name "".login"". The Files.isHidden(java.nio.file.Path) method may be used to test whether a file is considered hidden. All other characters match themselves in an implementation dependent manner. This includes characters representing any name-separators. The matching of root components is highly implementation-dependent and is not specified. When the syntax is ""regex"" then the pattern component is a regular expression as defined by the Pattern class. For both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified."
"Returns the UserPrincipalLookupService for this file system (optional operation). The resulting lookup service may be used to lookup user or group names. Usage Example: Suppose we want to make ""joe"" the owner of a file: UserPrincipalLookupService lookupService = FileSystems.getDefault().getUserPrincipalLookupService(); Files.setOwner(path, lookupService.lookupPrincipalByName(""joe""));"
Constructs a new WatchService (optional operation). This method constructs a new watch service that may be used to watch registered objects for changes and events.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class. This constructor should be used when an operation involving one file fails and there isn't any additional information to explain the reason.
Constructs an instance of this class. This constructor should be used when an operation involving two files fails, or there is additional information to explain the reason.
Returns the file used to create this exception.
Returns the other file used to create this exception.
Returns the string explaining why the file system operation failed.
Returns the detail message string.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
"Returns the default FileSystem. The default file system creates objects that provide access to the file systems accessible to the Java virtual machine. The working directory of the file system is the current user directory, named by the system property user.dir. This allows for interoperability with the java.io.File class. The first invocation of any of the methods defined by this class locates the default provider object. Where the system property java.nio.file.spi.DefaultFileSystemProvider is not defined then the default provider is a system-default provider that is invoked to create the default file system. If the system property java.nio.file.spi.DefaultFileSystemProvider is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme ""file"". Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is FileSystemProvider. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to ""file"" then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be ""file"". The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its getFileSystem method is invoked with the URI ""file:///"" to get a reference to the default file system. Subsequent invocations of this method return the file system that was returned by the first invocation."
Returns a reference to an existing FileSystem. This method iterates over the installed providers to locate the provider that is identified by the URI scheme of the given URI. URI schemes are compared without regard to case. The exact form of the URI is highly provider dependent. If found, the provider's getFileSystem method is invoked to obtain a reference to the FileSystem. Once a file system created by this provider is closed it is provider-dependent if this method returns a reference to the closed file system or throws FileSystemNotFoundException. If the provider allows a new file system to be created with the same URI as a file system it previously created then this method throws the exception if invoked after the file system is closed (and before a new instance is created by the newFileSystem method). If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the default file system, no permission check is required.
"Constructs a new file system that is identified by a URI This method iterates over the installed providers to locate the provider that is identified by the URI scheme of the given URI. URI schemes are compared without regard to case. The exact form of the URI is highly provider dependent. If found, the provider's newFileSystem(URI,Map) method is invoked to construct the new file system. Once a file system is closed it is provider-dependent if the provider allows a new file system to be created with the same URI as a file system it previously created. Usage Example: Suppose there is a provider identified by the scheme ""memory"" installed: Map<String,String> env = new HashMap<>(); env.put(""capacity"", ""16G""); env.put(""blockSize"", ""4k""); FileSystem fs = FileSystems.newFileSystem(URI.create(""memory:///?name=logfs""), env);"
Constructs a new file system that is identified by a URI This method first attempts to locate an installed provider in exactly the same manner as the newFileSystem(URI,Map) method. If none of the installed providers support the URI scheme then an attempt is made to locate the provider using the given class loader. If a provider supporting the URI scheme is located then its newFileSystem(URI,Map) is invoked to construct the new file system.
Constructs a new FileSystem to access the contents of a file as a file system. This method makes use of specialized providers that create pseudo file systems where the contents of one or more files is treated as a file system. This method iterates over the installed providers. It invokes, in turn, each provider's newFileSystem(Path,Map) method with an empty map. If a provider returns a file system then the iteration terminates and the file system is returned. If none of the installed providers return a FileSystem then an attempt is made to locate the provider using the given class loader. If a provider returns a file system then the lookup terminates and the file system is returned.
Follow symbolic links.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (FileVisitOption c : FileVisitOption.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Invoked for a directory before entries in the directory are visited. If this method returns CONTINUE, then entries in the directory are visited. If this method returns SKIP_SUBTREE or SKIP_SIBLINGS then entries in the directory (and any descendants) will not be visited.
Invoked for a file in a directory.
Invoked for a file that could not be visited. This method is invoked if the file's attributes could not be read, the file is a directory that could not be opened, and other reasons.
Invoked for a directory after entries in the directory, and all of their descendants, have been visited. This method is also invoked when iteration of the directory completes prematurely (by a visitFile method returning SKIP_SIBLINGS, or an I/O error when iterating over the directory).
Continue. When returned from a preVisitDirectory method then the entries in the directory should also be visited.
Terminate.
Continue without visiting the entries in this directory. This result is only meaningful when returned from the preVisitDirectory method; otherwise this result type is the same as returning CONTINUE.
Continue without visiting the siblings of this file or directory. If returned from the preVisitDirectory method then the entries in the directory are also skipped and the postVisitDirectory method is not invoked.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (FileVisitResult c : FileVisitResult.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Constructs an instance from the given input string, reason, and error index.
Constructs an instance from the given input string and reason. The resulting object will have an error index of -1.
Returns the input string.
Returns a string explaining why the input string was rejected.
Returns an index into the input string of the position at which the error occurred, or -1 if this position is not known.
"Returns a string describing the error. The resulting string consists of the reason string followed by a colon character (':'), a space, and the input string. If the error index is defined then the string "" at index "" followed by the index, in decimal, is inserted after the reason string and before the colon character."
Do not follow symbolic links.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (LinkOption c : LinkOption.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Constructs a LinkPermission with the specified name.
Constructs a LinkPermission with the specified name.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Returns the file system that created this object.
Tells whether or not this path is absolute. An absolute path is complete in that it doesn't need to be combined with other path information in order to locate a file.
Returns the root component of this path as a Path object, or null if this path does not have a root component.
Returns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.
"Returns the parent path, or null if this path does not have a parent. The parent of this path object consists of this path's root component, if any, and each element in the path except for the farthest from the root in the directory hierarchy. This method does not access the file system; the path or its parent may not exist. Furthermore, this method does not eliminate special names such as ""."" and "".."" that may be used in some implementations. On UNIX for example, the parent of ""/a/b/c"" is ""/a/b"", and the parent of ""x/y/."" is ""x/y"". This method may be used with the normalize method, to eliminate redundant names, for cases where shell-like navigation is required. If this path has one or more elements, and no root component, then this method is equivalent to evaluating the expression: subpath(0, getNameCount()-1);"
Returns the number of name elements in the path.
Returns a name element of this path as a Path object. The index parameter is the index of the name element to return. The element that is closest to the root in the directory hierarchy has index 0. The element that is farthest from the root has index count-1.
Returns a relative Path that is a subsequence of the name elements of this path. The beginIndex and endIndex parameters specify the subsequence of name elements. The name that is closest to the root in the directory hierarchy has index 0. The name that is farthest from the root has index count-1. The returned Path object has the name elements that begin at beginIndex and extend to the element at index endIndex-1.
Tests if this path starts with the given path. This path starts with the given path if this path's root component starts with the root component of the given path, and this path starts with the same name elements as the given path. If the given path has more name elements than this path then false is returned. Whether or not the root component of this path starts with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not start with the given path. If the given path is associated with a different FileSystem to this path then false is returned.
"Tests if this path starts with a Path, constructed by converting the given path string, in exactly the manner specified by the startsWith(Path) method. On UNIX for example, the path ""foo/bar"" starts with ""foo"" and ""foo/bar"". It does not start with ""f"" or ""fo""."
Tests if this path ends with the given path. If the given path has N elements, and no root component, and this path has N or more elements, then this path ends with the given path if the last N elements of each path, starting at the element farthest from the root, are equal. If the given path has a root component then this path ends with the given path if the root component of this path ends with the root component of the given path, and the corresponding elements of both paths are equal. Whether or not the root component of this path ends with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not end with the given path. If the given path is associated with a different FileSystem to this path then false is returned.
"Tests if this path ends with a Path, constructed by converting the given path string, in exactly the manner specified by the endsWith(Path) method. On UNIX for example, the path ""foo/bar"" ends with ""foo/bar"" and ""bar"". It does not end with ""r"" or ""/bar"". Note that trailing separators are not taken into account, and so invoking this method on the Path""foo/bar"" with the String ""bar/"" returns true."
"Returns a path that is this path with redundant name elements eliminated. The precise definition of this method is implementation dependent but in general it derives from this path, a path that does not contain redundant name elements. In many file systems, the ""."" and "".."" are special names used to indicate the current directory and parent directory. In such file systems all occurrences of ""."" are considered redundant. If a "".."" is preceded by a non-"".."" name then both names are considered redundant (the process to identify such names is repeated until it is no longer applicable). This method does not access the file system; the path may not locate a file that exists. Eliminating "".."" and a preceding name from a path may result in the path that locates a different file than the original path. This can arise when the preceding name is a symbolic link."
Resolve the given path against this path. If the other parameter is an absolute path then this method trivially returns other. If other is an empty path then this method trivially returns this path. Otherwise this method considers this path to be a directory and resolves the given path against this path. In the simplest case, the given path does not have a root component, in which case this method joins the given path to this path and returns a resulting path that ends with the given path. Where the given path has a root component then resolution is highly implementation dependent and therefore unspecified.
"Converts a given path string to a Path and resolves it against this Path in exactly the manner specified by the resolve method. For example, suppose that the name separator is ""/"" and a path represents ""foo/bar"", then invoking this method with the path string ""gus"" will result in the Path ""foo/bar/gus""."
"Resolves the given path against this path's parent path. This is useful where a file name needs to be replaced with another file name. For example, suppose that the name separator is ""/"" and a path represents ""dir1/dir2/foo"", then invoking this method with the Path ""bar"" will result in the Path ""dir1/dir2/bar"". If this path does not have a parent path, or other is absolute, then this method returns other. If other is an empty path then this method returns this path's parent, or where this path doesn't have a parent, the empty path."
Converts a given path string to a Path and resolves it against this path's parent path in exactly the manner specified by the resolveSibling method.
"Constructs a relative path between this path and a given path. Relativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is ""/a/b"" and the given path is ""/a/b/c/d"" then the resulting relative path would be ""c/d"". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned. For any two normalized paths p and q, where q does not have a root component, p.relativize(p.resolve(q)).equals(q) When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is ""/a/b"" and the given path is ""/a/x"" then the resulting relative path may be ""../x"". If ""b"" is a symbolic link then is implementation dependent if ""a/b/../x"" would locate the same file as ""/a/x""."
Returns a URI to represent this path. This method constructs an absolute URI with a scheme equal to the URI scheme that identifies the provider. The exact form of the scheme specific part is highly provider dependent. In the case of the default provider, the URI is hierarchical with a path component that is absolute. The query and fragment components are undefined. Whether the authority component is defined or not is implementation dependent. There is no guarantee that the URI may be used to construct a java.io.File. In particular, if this path represents a Universal Naming Convention (UNC) path, then the UNC server name may be encoded in the authority component of the resulting URI. In the case of the default provider, and the file exists, and it can be determined that the file is a directory, then the resulting URI will end with a slash. The default provider provides a similar round-trip guarantee to the File class. For a given Path p it is guaranteed that Paths.get(p.toUri()).equals(p .toAbsolutePath()) so long as the original Path, the URI, and the new Path are all created in (possibly different invocations of) the same Java virtual machine. Whether other providers make any guarantees is provider specific and therefore unspecified. When a file system is constructed to access the contents of a file as a file system then it is highly implementation specific if the returned URI represents the given path in the file system or it represents a compound URI that encodes the URI of the enclosing file system. A format for compound URIs is not defined in this release; such a scheme may be added in a future release.
Returns a Path object representing the absolute path of this path. If this path is already absolute then this method simply returns this path. Otherwise, this method resolves the path in an implementation dependent manner, typically by resolving the path against a file system default directory. Depending on the implementation, this method may throw an I/O error if the file system is not accessible.
"Returns the real path of an existing file. The precise definition of this method is implementation dependent but in general it derives from this path, an absolute path that locates the same file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed. If this path is relative then its absolute path is first obtained, as if by invoking the toAbsolutePath method. The options array may be used to indicate how symbolic links are handled. By default, symbolic links are resolved to their final target. If the option NOFOLLOW_LINKS is present then this method does not resolve symbolic links. Some implementations allow special names such as "".."" to refer to the parent directory. When deriving the real path, and a "".."" (or equivalent) is preceded by a non-"".."" name then an implementation will typically cause both names to be removed. When not resolving symbolic links and the preceding name is a symbolic link then the names are only removed if it guaranteed that the resulting path will locate the same file as this path."
Returns a File object representing this path. Where this Path is associated with the default provider, then this method is equivalent to returning a File object constructed with the String representation of this path. If this path was created by invoking the File toPath method then there is no guarantee that the File object returned by this method is equal to the original File.
Registers the file located by this path with a watch service. In this release, this path locates a directory that exists. The directory is registered with the watch service so that entries in the directory can be watched. The events parameter is the events to register and may contain the following events: ENTRY_CREATE - entry created or moved into the directory ENTRY_DELETE - entry deleted or moved out of the directory ENTRY_MODIFY - entry in directory was modified The context for these events is the relative path between the directory located by this path, and the path that locates the directory entry that is created, deleted, or modified. The set of events may include additional implementation specific event that are not defined by the enum StandardWatchEventKinds The modifiers parameter specifies modifiers that qualify how the directory is registered. This release does not define any standard modifiers. It may contain implementation specific modifiers. Where a file is registered with a watch service by means of a symbolic link then it is implementation specific if the watch continues to depend on the existence of the symbolic link after it is registered.
Registers the file located by this path with a watch service. An invocation of this method behaves in exactly the same way as the invocation watchable.register(watcher, events, new WatchEvent.Modifier[0]); Usage Example: Suppose we wish to register a directory for entry create, delete, and modify events: Path dir = ... WatchService watcher = ... WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
Returns an iterator over the name elements of this path. The first element returned by the iterator represents the name element that is closest to the root in the directory hierarchy, the second element is the next closest, and so on. The last element returned is the name of the file or directory denoted by this path. The root component, if present, is not returned by the iterator.
Compares two abstract paths lexicographically. The ordering defined by this method is provider specific, and in the case of the default provider, platform specific. This method does not access the file system and neither file is required to exist. This method may not be used to compare paths that are associated with different file system providers.
Tests this path for equality with the given object. If the given object is not a Path, or is a Path associated with a different FileSystem, then this method returns false. Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the isSameFile method may be used to check if two paths locate the same file. This method satisfies the general contract of the Object.equals method.
Computes a hash code for this path. The hash code is based upon the components of the path, and satisfies the general contract of the Object.hashCode method.
Returns the string representation of this path. If this path was created by converting a path string using the getPath method then the path string returned by this method may differ from the original String used to create the path. The returned path string uses the default name separator to separate names in the path.
Tells if given path matches this matcher's pattern.
"Converts a path string, or a sequence of strings that when joined form a path string, to a Path. If more does not specify any elements then the value of the first parameter is the path string to convert. If more specifies one or more elements then each non-empty string, including first, is considered to be a sequence of name elements (see Path) and is joined to form a path string. The details as to how the Strings are joined is provider specific but typically they will be joined using the name-separator as the separator. For example, if the name separator is ""/"" and getPath(""/foo"",""bar"",""gus"") is invoked, then the path string ""/foo/bar/gus"" is converted to a Path. A Path representing an empty path is returned if first is the empty string and more does not contain any non-empty strings. The Path is obtained by invoking the getPath method of the default FileSystem. Note that while this method is very convenient, using it will imply an assumed reference to the default FileSystem and limit the utility of the calling code. Hence it should not be used in library code intended for flexible reuse. A more flexible alternative is to use an existing Path instance as an anchor, such as: Path dir = ... Path path = dir.resolve(""file"");"
"Converts the given URI to a Path object. This method iterates over the installed providers to locate the provider that is identified by the URI scheme of the given URI. URI schemes are compared without regard to case. If the provider is found then its getPath method is invoked to convert the URI. In the case of the default provider, identified by the URI scheme ""file"", the given URI has a non-empty path component, and undefined query and fragment components. Whether the authority component may be present is platform specific. The returned Path is associated with the default file system. The default provider provides a similar round-trip guarantee to the File class. For a given Path p it is guaranteed that Paths.get(p.toUri()).equals( p.toAbsolutePath()) so long as the original Path, the URI, and the new Path are all created in (possibly different invocations of) the same Java virtual machine. Whether other providers make any guarantees is provider specific and therefore unspecified."
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Constructs an instance of this class.
Opens the directory identified by the given path, returning a SecureDirectoryStream to iterate over the entries in the directory. This method works in exactly the manner specified by the newDirectoryStream method for the case that the path parameter is an absolute path. When the parameter is a relative path then the directory to open is relative to this open directory. The NOFOLLOW_LINKS option may be used to ensure that this method fails if the file is a symbolic link. The new directory stream, once created, is not dependent upon the directory stream used to create it. Closing this directory stream has no effect upon newly created directory stream.
Opens or creates a file in this directory, returning a seekable byte channel to access the file. This method works in exactly the manner specified by the Files.newByteChannel method for the case that the path parameter is an absolute path. When the parameter is a relative path then the file to open or create is relative to this open directory. In addition to the options defined by the Files.newByteChannel method, the NOFOLLOW_LINKS option may be used to ensure that this method fails if the file is a symbolic link. The channel, once created, is not dependent upon the directory stream used to create it. Closing this directory stream has no effect upon the channel.
Deletes a file. Unlike the delete() method, this method does not first examine the file to determine if the file is a directory. Whether a directory is deleted by this method is system dependent and therefore not specified. If the file is a symbolic link, then the link itself, not the final target of the link, is deleted. When the parameter is a relative path then the file to delete is relative to this open directory.
Deletes a directory. Unlike the delete() method, this method does not first examine the file to determine if the file is a directory. Whether non-directories are deleted by this method is system dependent and therefore not specified. When the parameter is a relative path then the directory to delete is relative to this open directory.
Move a file from this directory to another directory. This method works in a similar manner to move method when the ATOMIC_MOVE option is specified. That is, this method moves a file as an atomic file system operation. If the srcpath parameter is an absolute path then it locates the source file. If the parameter is a relative path then it is located relative to this open directory. If the targetpath parameter is absolute then it locates the target file (the targetdir parameter is ignored). If the parameter is a relative path it is located relative to the open directory identified by the targetdir parameter. In all cases, if the target file exists then it is implementation specific if it is replaced or this method fails.
Returns a new file attribute view to access the file attributes of this directory. The resulting file attribute view can be used to read or update the attributes of this (open) directory. The type parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a BasicFileAttributeView always returns an instance of that class that is bound to this open directory. The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is closed, then all methods to read or update attributes will throw ClosedDirectoryStreamException.
Returns a new file attribute view to access the file attributes of a file in this directory. The resulting file attribute view can be used to read or update the attributes of file in this directory. The type parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a BasicFileAttributeView always returns an instance of that class that is bound to the file in the directory. The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream closed, then all methods to read or update attributes will throw ClosedDirectoryStreamException. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.
Initializes a new instance of this class.
Invoked for a directory before entries in the directory are visited. Unless overridden, this method returns CONTINUE.
Invoked for a file in a directory. Unless overridden, this method returns CONTINUE.
Invoked for a file that could not be visited. Unless overridden, this method re-throws the I/O exception that prevented the file from being visited.
Invoked for a directory after entries in the directory, and all of their descendants, have been visited. Unless overridden, this method returns CONTINUE if the directory iteration completes without an I/O exception; otherwise this method re-throws the I/O exception that caused the iteration of the directory to terminate prematurely.
Replace an existing file if it exists.
Copy attributes to the new file.
Move the file as an atomic file system operation.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (StandardCopyOption c : StandardCopyOption.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Open for read access.
Open for write access.
If the file is opened for WRITE access then bytes will be written to the end of the file rather than the beginning. If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.
If the file already exists and it is opened for WRITE access, then its length is truncated to 0. This option is ignored if the file is opened only for READ access.
Create a new file if it does not exist. This option is ignored if the CREATE_NEW option is also set. The check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations.
Create a new file, failing if the file already exists. The check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations.
Delete on close. When this option is present then the implementation makes a best effort attempt to delete the file when closed by the appropriate close method. If the close method is not invoked then a best effort attempt is made to delete the file when the Java virtual machine terminates (either normally, as defined by the Java Language Specification, or where possible, abnormally). This option is primarily intended for use with work files that are used solely by a single instance of the Java virtual machine. This option is not recommended for use when opening files that are open concurrently by other entities. Many of the details as to when and how the file is deleted are implementation specific and therefore not specified. In particular, an implementation may be unable to guarantee that it deletes the expected file when replaced by an attacker while the file is open. Consequently, security sensitive applications should take care when using this option. For security reasons, this option may imply the LinkOption.NOFOLLOW_LINKS option. In other words, if the option is present when opening an existing file that is a symbolic link then it may fail (by throwing IOException).
Sparse file. When used with the CREATE_NEW option then this option provides a hint that the new file will be sparse. The option is ignored when the file system does not support the creation of sparse files.
Requires that every update to the file's content or metadata be written synchronously to the underlying storage device.
Requires that every update to the file's content be written synchronously to the underlying storage device.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (StandardOpenOption c : StandardOpenOption.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
A special event to indicate that events may have been lost or discarded. The context for this event is implementation specific and may be null. The event count may be greater than 1.
Directory entry created. When a directory is registered for this event then the WatchKey is queued when it is observed that an entry is created in the directory or renamed into the directory. The event count for this event is always 1.
Directory entry deleted. When a directory is registered for this event then the WatchKey is queued when it is observed that an entry is deleted or renamed out of the directory. The event count for this event is always 1.
Directory entry modified. When a directory is registered for this event then the WatchKey is queued when it is observed that an entry in the directory has been modified. The event count for this event is 1 or greater.
Registers an object with a watch service. If the file system object identified by this object is currently registered with the watch service then the watch key, representing that registration, is returned after changing the event set or modifiers to those specified by the events and modifiers parameters. Changing the event set does not cause pending events for the object to be discarded. Objects are automatically registered for the OVERFLOW event. This event is not required to be present in the array of events. Otherwise the file system object has not yet been registered with the given watch service, so it is registered and the resulting new key is returned. Implementations of this interface should specify the events they support.
Registers an object with a watch service. An invocation of this method behaves in exactly the same way as the invocation watchable.register(watcher, events, new WatchEvent.Modifier[0]);
Returns the event kind.
Returns the event count. If the event count is greater than 1 then this is a repeated event.
Returns the context for the event. In the case of ENTRY_CREATE, ENTRY_DELETE, and ENTRY_MODIFY events the context is a Path that is the relative path between the directory registered with the watch service, and the entry that is created, deleted, or modified.
Returns the name of the event kind.
Returns the type of the context value.
Returns the name of the modifier.
Tells whether or not this watch key is valid. A watch key is valid upon creation and remains until it is cancelled, or its watch service is closed.
Retrieves and removes all pending events for this watch key, returning a List of the events that were retrieved. Note that this method does not wait if there are no events pending.
Resets this watch key. If this watch key has been cancelled or this watch key is already in the ready state then invoking this method has no effect. Otherwise if there are pending events for the object then this watch key is immediately re-queued to the watch service. If there are no pending events then the watch key is put into the ready state and will remain in that state until an event is detected or the watch key is cancelled.
Cancels the registration with the watch service. Upon return the watch key will be invalid. If the watch key is enqueued, waiting to be retrieved from the watch service, then it will remain in the queue until it is removed. Pending events, if any, remain pending and may be retrieved by invoking the pollEvents method after the key is cancelled. If this watch key has already been cancelled then invoking this method has no effect. Once cancelled, a watch key remains forever invalid.
Returns the object for which this watch key was created. This method will continue to return the object even after the key is cancelled. As the WatchService is intended to map directly on to the native file event notification facility (where available) then many of details on how registered objects are watched is highly implementation specific. When watching a directory for changes for example, and the directory is moved or renamed in the file system, there is no guarantee that the watch key will be cancelled and so the object returned by this method may no longer be a valid path to the directory.
Closes this watch service. If a thread is currently blocked in the take or poll methods waiting for a key to be queued then it immediately receives a ClosedWatchServiceException. Any valid keys associated with this watch service are invalidated. After a watch service is closed, any further attempt to invoke operations upon it will throw ClosedWatchServiceException. If this watch service is already closed then invoking this method has no effect.
Retrieves and removes the next watch key, or null if none are present.
Retrieves and removes the next watch key, waiting if necessary up to the specified wait time if none are yet present.
Retrieves and removes next watch key, waiting if none are yet present.
Constructs an AclEntry from the components of this builder. The type and who components are required to have been set in order to construct an AclEntry.
Sets the type component of this builder.
Sets the principal component of this builder.
Sets the permissions component of this builder. On return, the permissions component of this builder is a copy of the given set.
Sets the permissions component of this builder. On return, the permissions component of this builder is a copy of the permissions in the given array.
Sets the flags component of this builder. On return, the flags component of this builder is a copy of the given set.
Sets the flags component of this builder. On return, the flags component of this builder is a copy of the flags in the given array.
Constructs a new builder. The initial value of the type and who components is null. The initial value of the permissions and flags components is the empty set.
Constructs a new builder with the components of an existing ACL entry.
Returns the ACL entry type.
Returns the principal component.
Returns a copy of the permissions component. The returned set is a modifiable copy of the permissions.
Returns a copy of the flags component. The returned set is a modifiable copy of the flags.
Compares the specified object with this ACL entry for equality. If the given object is not an AclEntry then this method immediately returns false. For two ACL entries to be considered equals requires that they are both the same type, their who components are equal, their permissions components are equal, and their flags components are equal. This method satisfies the general contract of the Object.equals method.
Returns the hash-code value for this ACL entry. This method satisfies the general contract of the Object.hashCode() method.
Returns the string representation of this ACL entry.
Can be placed on a directory and indicates that the ACL entry should be added to each new non-directory file created.
Can be placed on a directory and indicates that the ACL entry should be added to each new directory created.
Can be placed on a directory to indicate that the ACL entry should not be placed on the newly created directory which is inheritable by subdirectories of the created directory.
Can be placed on a directory but does not apply to the directory, only to newly created files/directories as specified by the FILE_INHERIT and DIRECTORY_INHERIT flags.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (AclEntryFlag c : AclEntryFlag.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Permission to read the data of the file.
Permission to modify the file's data.
Permission to append data to a file.
Permission to read the named attributes of a file. RFC 3530: Network File System (NFS) version 4 Protocol defines named attributes as opaque files associated with a file in the file system.
Permission to write the named attributes of a file. RFC 3530: Network File System (NFS) version 4 Protocol defines named attributes as opaque files associated with a file in the file system.
Permission to execute a file.
Permission to delete a file or directory within a directory.
The ability to read (non-acl) file attributes.
The ability to write (non-acl) file attributes.
Permission to delete the file.
Permission to read the ACL attribute.
Permission to write the ACL attribute.
Permission to change the owner.
Permission to access file locally at the server with synchronous reads and writes.
Permission to list the entries of a directory (equal to READ_DATA)
Permission to add a new file to a directory (equal to WRITE_DATA)
Permission to create a subdirectory to a directory (equal to APPEND_DATA)
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (AclEntryPermission c : AclEntryPermission.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Explicitly grants access to a file or directory.
Explicitly denies access to a file or directory.
Log, in a system dependent way, the access specified in the permissions component of the ACL entry.
Generate an alarm, in a system dependent way, the access specified in the permissions component of the ACL entry.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (AclEntryType c : AclEntryType.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
"Returns the name of the attribute view. Attribute views of this type have the name ""acl""."
Reads the access control list. When the file system uses an ACL model that differs from the NFSv4 defined ACL model, then this method returns an ACL that is the translation of the ACL to the NFSv4 ACL model. The returned list is modifiable so as to facilitate changes to the existing ACL. The setAcl method is used to update the file's ACL attribute.
Updates (replace) the access control list. Where the file system supports Access Control Lists, and it uses an ACL model that differs from the NFSv4 defined ACL model, then this method must translate the ACL to the model supported by the file system. This method should reject (by throwing IOException) any attempt to write an ACL that would appear to make the file more secure than would be the case if the ACL were updated. Where an implementation does not support a mapping of AclEntryType.AUDIT or AclEntryType.ALARM entries, then this method ignores these entries when writing the ACL. If an ACL entry contains a user-principal that is not associated with the same provider as this attribute view then ProviderMismatchException is thrown. Additional validation, if any, is implementation dependent. If the file system supports other security related file attributes (such as a file access-permissions for example), the updating the access control list may also cause these security related attributes to be updated.
Returns the name of the attribute view.
Returns the time of last modification. If the file system implementation does not support a time stamp to indicate the time of last modification then this method returns an implementation specific default value, typically a FileTime representing the epoch (1970-01-01T00:00:00Z).
Returns the time of last access. If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the last-modified-time or a FileTime representing the epoch (1970-01-01T00:00:00Z).
Returns the creation time. The creation time is the time that the file was created. If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the last-modified-time or a FileTime representing the epoch (1970-01-01T00:00:00Z).
Tells whether the file is a regular file with opaque content.
Tells whether the file is a directory.
Tells whether the file is a symbolic link.
Tells whether the file is something other than a regular file, directory, or symbolic link.
Returns the size of the file (in bytes). The size may differ from the actual size on the file system due to compression, support for sparse files, or other reasons. The size of files that are not regular files is implementation specific and therefore unspecified.
Returns an object that uniquely identifies the given file, or null if a file key is not available. On some platforms or file systems it is possible to use an identifier, or a combination of identifiers to uniquely identify a file. Such identifiers are important for operations such as file tree traversal in file systems that support symbolic links or file systems that allow a file to be an entry in more than one directory. On UNIX file systems, for example, the device ID and inode are commonly used for such purposes. The file key returned by this method can only be guaranteed to be unique if the file system and files remain static. Whether a file system re-uses identifiers after a file is deleted is implementation dependent and therefore unspecified. File keys returned by this method can be compared for equality and are suitable for use in collections. If the file system and files remain static, and two files are the same with non-null file keys, then their file keys are equal.
"Returns the name of the attribute view. Attribute views of this type have the name ""basic""."
Reads the basic file attributes as a bulk operation. It is implementation specific if all file attributes are read as an atomic operation with respect to other file system operations.
Updates any or all of the file's last modified time, last access time, and create time attributes. This method updates the file's timestamp attributes. The values are converted to the epoch and precision supported by the file system. Converting from finer to coarser granularities result in precision loss. The behavior of this method when attempting to set a timestamp that is not supported or to a value that is outside the range supported by the underlying file store is not defined. It may or not fail by throwing an IOException. If any of the lastModifiedTime, lastAccessTime, or createTime parameters has the value null then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the lastModifiedTime, lastAccessTime and createTime parameters are null then this method has no effect. Usage Example: Suppose we want to change a file's last access time. Path path = ... FileTime time = ... Files.getFileAttributeView(path, BasicFileAttributeView.class).setTimes(null, time, null);
Returns the value of the read-only attribute. This attribute is often used as a simple access control mechanism to prevent files from being deleted or updated. Whether the file system or platform does any enforcement to prevent read-only files from being updated is implementation specific.
Returns the value of the hidden attribute. This attribute is often used to indicate if the file is visible to users.
Returns the value of the archive attribute. This attribute is typically used by backup programs.
Returns the value of the system attribute. This attribute is often used to indicate that the file is a component of the operating system.
"Returns the name of the attribute view. Attribute views of this type have the name ""dos""."
Reads the basic file attributes as a bulk operation. It is implementation specific if all file attributes are read as an atomic operation with respect to other file system operations.
Updates the value of the read-only attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.
Updates the value of the hidden attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.
Updates the value of the system attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.
Updates the value of the archive attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.
Returns the attribute name.
Returns the attribute value.
"Returns the name of the attribute view. Attribute views of this type have the name ""owner""."
Read the file owner. It it implementation specific if the file owner can be a group.
Updates the file owner. It it implementation specific if the file owner can be a group. To ensure consistent and correct behavior across platforms it is recommended that this method should only be used to set the file owner to a user principal that is not a group.
Returns a FileTime representing a value at the given unit of granularity.
Returns a FileTime representing the given value in milliseconds.
Returns a FileTime representing the same point of time value on the time-line as the provided Instant object.
Returns the value at the given unit of granularity. Conversion from a coarser granularity that would numerically overflow saturate to Long.MIN_VALUE if negative or Long.MAX_VALUE if positive.
Returns the value in milliseconds. Conversion from a coarser granularity that would numerically overflow saturate to Long.MIN_VALUE if negative or Long.MAX_VALUE if positive.
Converts this FileTime object to an Instant. The conversion creates an Instant that represents the same point on the time-line as this FileTime. FileTime can store points on the time-line further in the future and further in the past than Instant. Conversion from such further time points saturates to Instant.MIN if earlier than Instant.MIN or Instant.MAX if later than Instant.MAX.
Tests this FileTime for equality with the given object. The result is true if and only if the argument is not null and is a FileTime that represents the same time. This method satisfies the general contract of the Object.equals method.
Computes a hash code for this file time. The hash code is based upon the value represented, and satisfies the general contract of the Object.hashCode() method.
Compares the value of two FileTime objects for order.
"Returns the string representation of this FileTime. The string is returned in the ISO 8601 format: YYYY-MM-DDThh:mm:ss[.s+]Z where ""[.s+]"" represents a dot followed by one of more digits for the decimal fraction of a second. It is only present when the decimal fraction of a second is not zero. For example, FileTime.fromMillis(1234567890000L).toString() yields ""2009-02-13T23:31:30Z"", and FileTime.fromMillis(1234567890123L).toString() yields ""2009-02-13T23:31:30.123Z"". A FileTime is primarily intended to represent the value of a file's time stamp. Where used to represent extreme values, where the year is less than ""0001"" or greater than ""9999"" then this method deviates from ISO 8601 in the same manner as the XML Schema language. That is, the year may be expanded to more than four digits and may be negative-signed. If more than four digits then leading zeros are not present. The year before ""0001"" is ""-0001""."
Returns the owner of the file.
Returns the group owner of the file.
Returns the permissions of the file. The file permissions are returned as a set of PosixFilePermission elements. The returned set is a copy of the file permissions and is modifiable. This allows the result to be modified and passed to the setPermissions method to update the file's permissions.
"Returns the name of the attribute view. Attribute views of this type have the name ""posix""."
Reads the basic file attributes as a bulk operation. It is implementation specific if all file attributes are read as an atomic operation with respect to other file system operations.
Updates the file permissions.
Updates the file group-owner.
Read permission, owner.
Write permission, owner.
Execute/search permission, owner.
Read permission, group.
Write permission, group.
Execute/search permission, group.
Read permission, others.
Write permission, others.
Execute/search permission, others.
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (PosixFilePermission c : PosixFilePermission.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Returns the String representation of a set of permissions. It is guaranteed that the returned String can be parsed by the fromString(java.lang.String) method. If the set contains null or elements that are not of type PosixFilePermission then these elements are ignored.
"Returns the set of permissions corresponding to a given String representation. The perms parameter is a String representing the permissions. It has 9 characters that are interpreted as three sets of three. The first set refers to the owner's permissions; the next to the group permissions and the last to others. Within each set, the first character is 'r' to indicate permission to read, the second character is 'w' to indicate permission to write, and the third character is 'x' for execute permission. Where a permission is not set then the corresponding character is set to '-'. Usage Example: Suppose we require the set of permissions that indicate the owner has read, write, and execute permissions, the group has read and execute permissions and others have none. Set<PosixFilePermission> perms = PosixFilePermissions.fromString(""rwxr-x---"");"
Creates a FileAttribute, encapsulating a copy of the given file permissions, suitable for passing to the createFile or createDirectory methods.
"Returns the name of this attribute view. Attribute views of this type have the name ""user""."
Returns a list containing the names of the user-defined attributes.
Returns the size of the value of a user-defined attribute.
"Read the value of a user-defined attribute into a buffer. This method reads the value of the attribute into the given buffer as a sequence of bytes, failing if the number of bytes remaining in the buffer is insufficient to read the complete attribute value. The number of bytes transferred into the buffer is n, where n is the size of the attribute value. The first byte in the sequence is at index p and the last byte is at index p + n - 1, where p is the buffer's position. Upon return the buffer's position will be equal to p + n; its limit will not have changed. Usage Example: Suppose we want to read a file's MIME type that is stored as a user-defined attribute with the name ""user.mimetype"". UserDefinedFileAttributeView view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class); String name = ""user.mimetype""; ByteBuffer buf = ByteBuffer.allocate(view.size(name)); view.read(name, buf); buf.flip(); String value = Charset.defaultCharset().decode(buf).toString();"
"Writes the value of a user-defined attribute from a buffer. This method writes the value of the attribute from a given buffer as a sequence of bytes. The size of the value to transfer is r, where r is the number of bytes remaining in the buffer, that is src.remaining(). The sequence of bytes is transferred from the buffer starting at index p, where p is the buffer's position. Upon return, the buffer's position will be equal to p + n, where n is the number of bytes transferred; its limit will not have changed. If an attribute of the given name already exists then its value is replaced. If the attribute does not exist then it is created. If it implementation specific if a test to check for the existence of the attribute and the creation of attribute are atomic with respect to other file system activities. Where there is insufficient space to store the attribute, or the attribute name or value exceed an implementation specific maximum size then an IOException is thrown. Usage Example: Suppose we want to write a file's MIME type as a user-defined attribute: UserDefinedFileAttributeView view = FIles.getFileAttributeView(path, UserDefinedFileAttributeView.class); view.write(""user.mimetype"", Charset.defaultCharset().encode(""text/html""));"
Deletes a user-defined attribute.
Initializes a new instance of this class.
Lookup a user principal by name.
Lookup a group principal by group name. Where an implementation does not support any notion of group then this method always throws UserPrincipalNotFoundException. Where the namespace for user accounts and groups is the same, then this method is identical to invoking lookupPrincipalByName.
Constructs an instance of this class.
Returns the user principal name if this exception was created with the user principal name that was not found, otherwise null.
Initializes a new instance of this class. During construction a provider may safely access files associated with the default provider but care needs to be taken to avoid circular loading of other installed providers. If circular loading of installed providers is detected then an unspecified error is thrown.
Returns a list of the installed file system providers. The first invocation of this method causes the default provider to be initialized (if not already initialized) and loads any other installed providers as described by the FileSystems class.
Returns the URI scheme that identifies this provider.
Constructs a new FileSystem object identified by a URI. This method is invoked by the FileSystems.newFileSystem(URI,Map) method to open a new file system identified by a URI. The uri parameter is an absolute, hierarchical URI, with a scheme equal (without regard to case) to the scheme supported by this provider. The exact form of the URI is highly provider dependent. The env parameter is a map of provider specific properties to configure the file system. This method throws FileSystemAlreadyExistsException if the file system already exists because it was previously created by an invocation of this method. Once a file system is closed it is provider-dependent if the provider allows a new file system to be created with the same URI as a file system it previously created.
"Returns an existing FileSystem created by this provider. This method returns a reference to a FileSystem that was created by invoking the newFileSystem(URI,Map) method. File systems created the newFileSystem(Path,Map) method are not returned by this method. The file system is identified by its URI. Its exact form is highly provider dependent. In the case of the default provider the URI's path component is ""/"" and the authority, query and fragment components are undefined (Undefined components are represented by null). Once a file system created by this provider is closed it is provider-dependent if this method returns a reference to the closed file system or throws FileSystemNotFoundException. If the provider allows a new file system to be created with the same URI as a file system it previously created then this method throws the exception if invoked after the file system is closed (and before a new instance is created by the newFileSystem method). If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the default file system, no permission check is required."
"Return a Path object by converting the given URI. The resulting Path is associated with a FileSystem that already exists or is constructed automatically. The exact form of the URI is file system provider dependent. In the case of the default provider, the URI scheme is ""file"" and the given URI has a non-empty path component, and undefined query, and fragment components. The resulting Path is associated with the default default FileSystem. If a security manager is installed then a provider implementation may require to check a permission. In the case of the default file system, no permission check is required."
Constructs a new FileSystem to access the contents of a file as a file system. This method is intended for specialized providers of pseudo file systems where the contents of one or more files is treated as a file system. The env parameter is a map of provider specific properties to configure the file system. If this provider does not support the creation of such file systems or if the provider does not recognize the file type of the given file then it throws UnsupportedOperationException. The default implementation of this method throws UnsupportedOperationException.
Opens a file, returning an input stream to read from the file. This method works in exactly the manner specified by the Files.newInputStream(java.nio.file.Path, java.nio.file.OpenOption...) method. The default implementation of this method opens a channel to the file as if by invoking the newByteChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) method and constructs a stream that reads bytes from the channel. This method should be overridden where appropriate.
Opens or creates a file, returning an output stream that may be used to write bytes to the file. This method works in exactly the manner specified by the Files.newOutputStream(java.nio.file.Path, java.nio.file.OpenOption...) method. The default implementation of this method opens a channel to the file as if by invoking the newByteChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) method and constructs a stream that writes bytes to the channel. This method should be overridden where appropriate.
Opens or creates a file for reading and/or writing, returning a file channel to access the file. This method works in exactly the manner specified by the FileChannel.open method. A provider that does not support all the features required to construct a file channel throws UnsupportedOperationException. The default provider is required to support the creation of file channels. When not overridden, the default implementation throws UnsupportedOperationException.
Opens or creates a file for reading and/or writing, returning an asynchronous file channel to access the file. This method works in exactly the manner specified by the AsynchronousFileChannel.open method. A provider that does not support all the features required to construct an asynchronous file channel throws UnsupportedOperationException. The default provider is required to support the creation of asynchronous file channels. When not overridden, the default implementation of this method throws UnsupportedOperationException.
Opens or creates a file, returning a seekable byte channel to access the file. This method works in exactly the manner specified by the Files.newByteChannel(Path,Set,FileAttribute[]) method.
Opens a directory, returning a DirectoryStream to iterate over the entries in the directory. This method works in exactly the manner specified by the Files.newDirectoryStream(java.nio.file.Path, java.nio.file.DirectoryStream.Filter) method.
Creates a new directory. This method works in exactly the manner specified by the Files.createDirectory(java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) method.
Creates a symbolic link to a target. This method works in exactly the manner specified by the Files.createSymbolicLink(java.nio.file.Path, java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) method. The default implementation of this method throws UnsupportedOperationException.
Creates a new link (directory entry) for an existing file. This method works in exactly the manner specified by the Files.createLink(java.nio.file.Path, java.nio.file.Path) method. The default implementation of this method throws UnsupportedOperationException.
Deletes a file. This method works in exactly the manner specified by the Files.delete(java.nio.file.Path) method.
Deletes a file if it exists. This method works in exactly the manner specified by the Files.deleteIfExists(java.nio.file.Path) method. The default implementation of this method simply invokes delete(java.nio.file.Path) ignoring the NoSuchFileException when the file does not exist. It may be overridden where appropriate.
Reads the target of a symbolic link. This method works in exactly the manner specified by the Files.readSymbolicLink(java.nio.file.Path) method. The default implementation of this method throws UnsupportedOperationException.
Copy a file to a target file. This method works in exactly the manner specified by the Files.copy(Path,Path,CopyOption[]) method except that both the source and target paths must be associated with this provider.
Move or rename a file to a target file. This method works in exactly the manner specified by the Files.move(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...) method except that both the source and target paths must be associated with this provider.
Tests if two paths locate the same file. This method works in exactly the manner specified by the Files.isSameFile(java.nio.file.Path, java.nio.file.Path) method.
Tells whether or not a file is considered hidden. This method works in exactly the manner specified by the Files.isHidden(java.nio.file.Path) method. This method is invoked by the isHidden method.
Returns the FileStore representing the file store where a file is located. This method works in exactly the manner specified by the Files.getFileStore(java.nio.file.Path) method.
Checks the existence, and optionally the accessibility, of a file. This method may be used by the isReadable, isWritable and isExecutable methods to check the accessibility of a file. This method checks the existence of a file and that this Java virtual machine has appropriate privileges that would allow it access the file according to all of access modes specified in the modes parameter as follows: Value Description READ Checks that the file exists and that the Java virtual machine has permission to read the file. WRITE Checks that the file exists and that the Java virtual machine has permission to write to the file, EXECUTE Checks that the file exists and that the Java virtual machine has permission to execute the file. The semantics may differ when checking access to a directory. For example, on UNIX systems, checking for EXECUTE access checks that the Java virtual machine has permission to search the directory in order to access file or subdirectories. If the modes parameter is of length zero, then the existence of the file is checked. This method follows symbolic links if the file referenced by this object is a symbolic link. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. To determine the effective access to a file may require access to several attributes and so in some implementations this method may not be atomic with respect to other file system operations.
Returns a file attribute view of a given type. This method works in exactly the manner specified by the Files.getFileAttributeView(java.nio.file.Path, java.lang.Class<V>, java.nio.file.LinkOption...) method.
Reads a file's attributes as a bulk operation. This method works in exactly the manner specified by the Files.readAttributes(Path,Class,LinkOption[]) method.
Reads a set of file attributes as a bulk operation. This method works in exactly the manner specified by the Files.readAttributes(Path,String,LinkOption[]) method.
Sets the value of a file attribute. This method works in exactly the manner specified by the Files.setAttribute(java.nio.file.Path, java.lang.String, java.lang.Object, java.nio.file.LinkOption...) method.
Initializes a new instance of this class.
Probes the given file to guess its content type. The means by which this method determines the file type is highly implementation specific. It may simply examine the file name, it may use a file attribute, or it may examines bytes in the file. The probe result is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies. The string must be parsable according to the grammar in the RFC 2045.
Constructs an AccessException with the specified detail message.
Constructs an AccessException with the specified detail message and nested exception.
Constructs an AlreadyBoundException with no specified detail message.
Constructs an AlreadyBoundException with the specified detail message.
Constructs a ConnectException with the specified detail message.
Constructs a ConnectException with the specified detail message and nested exception.
Constructs a ConnectIOException with the specified detail message.
Constructs a ConnectIOException with the specified detail message and nested exception.
Constructs a MarshalException with the specified detail message.
Constructs a MarshalException with the specified detail message and nested exception.
Creates a new MarshalledObject that contains the serialized representation of the current state of the supplied object. The object is serialized with the semantics used for marshaling parameters for RMI calls.
Returns a new copy of the contained marshalledobject. The internal representation is deserialized with the semantics used for unmarshaling parameters for RMI calls.
Return a hash code for this MarshalledObject.
Compares this MarshalledObject to another object. Returns true if and only if the argument refers to a MarshalledObject that contains exactly the same serialized representation of an object as this one does. The comparison ignores any class codebase annotation, meaning that two objects are equivalent if they have the same serialized representation except for the codebase of each class in the serialized representation.
Returns a reference, a stub, for the remote object associated with the specified name.
Binds the specified name to a remote object.
Destroys the binding for the specified name that is associated with a remote object.
Rebinds the specified name to a new remote object. Any existing binding for the name is replaced.
Returns an array of the names bound in the registry. The names are URL-formatted (without the scheme component) strings. The array contains a snapshot of the names present in the registry at the time of the call.
Constructs a NoSuchObjectException with the specified detail message.
Constructs a NotBoundException with no specified detail message.
Constructs a NotBoundException with the specified detail message.
The cause of the remote exception. This field predates the general-purpose exception chaining facility. The Throwable.getCause() method is now the preferred means of obtaining this information.
Constructs a RemoteException.
Constructs a RemoteException with the specified detail message.
Constructs a RemoteException with the specified detail message and cause. This constructor sets the detail field to the specified Throwable.
Returns the detail message, including the message from the cause, if any, of this exception.
Returns the cause of this exception. This method returns the value of the detail field.
Construct an RMISecurityException with a detail message.
Construct an RMISecurityException with a detail message.
Constructs a new RMISecurityManager.
Constructs a ServerError with the specified detail message and nested error.
Constructs a ServerException with the specified detail message.
Constructs a ServerException with the specified detail message and nested exception.
Constructs a ServerRuntimeException with the specified detail message and nested exception.
Constructs a StubNotFoundException with the specified detail message.
Constructs a StubNotFoundException with the specified detail message and nested exception.
Constructs an UnexpectedException with the specified detail message.
Constructs a UnexpectedException with the specified detail message and nested exception.
Constructs an UnknownHostException with the specified detail message.
Constructs an UnknownHostException with the specified detail message and nested exception.
Constructs an UnmarshalException with the specified detail message.
Constructs an UnmarshalException with the specified detail message and nested exception.
Constructs an activatable remote object by registering an activation descriptor (with the specified location, data, and restart mode) for this object, and exporting the object with the specified port. Note: Using the Activatable constructors that both register and export an activatable remote object is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic. Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly. This method invokes the exportObject method with this object, and the specified location, data, restart mode, and port. Subsequent calls to getID() will return the activation identifier returned from the call to exportObject.
Constructs an activatable remote object by registering an activation descriptor (with the specified location, data, and restart mode) for this object, and exporting the object with the specified port, and specified client and server socket factories. Note: Using the Activatable constructors that both register and export an activatable remote object is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic. Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly. This method invokes the exportObject method with this object, and the specified location, data, restart mode, port, and client and server socket factories. Subsequent calls to getID() will return the activation identifier returned from the call to exportObject.
"Constructor used to activate/export the object on a specified port. An ""activatable"" remote object must have a constructor that takes two arguments: the object's activation identifier (ActivationID), and the object's initialization data (a MarshalledObject). A concrete subclass of this class must call this constructor when it is activated via the two parameter constructor described above. As a side-effect of construction, the remote object is ""exported"" to the RMI runtime (on the specified port) and is available to accept incoming calls from clients."
"Constructor used to activate/export the object on a specified port. An ""activatable"" remote object must have a constructor that takes two arguments: the object's activation identifier (ActivationID), and the object's initialization data (a MarshalledObject). A concrete subclass of this class must call this constructor when it is activated via the two parameter constructor described above. As a side-effect of construction, the remote object is ""exported"" to the RMI runtime (on the specified port) and is available to accept incoming calls from clients."
Returns the object's activation identifier. The method is protected so that only subclasses can obtain an object's identifier.
Register an object descriptor for an activatable remote object so that is can be activated on demand.
"Informs the system that the object with the corresponding activation id is currently inactive. If the object is currently active, the object is ""unexported"" from the RMI runtime (only if there are no pending or in-progress calls) so the that it can no longer receive incoming calls. This call informs this VM's ActivationGroup that the object is inactive, that, in turn, informs its ActivationMonitor. If this call completes successfully, a subsequent activate request to the activator will cause the object to reactivate. The operation may still succeed if the object is considered active but has already unexported itself."
Revokes previous registration for the activation descriptor associated with id. An object can no longer be activated via that id.
Registers an activation descriptor (with the specified location, data, and restart mode) for the specified object, and exports that object with the specified port. Note: Using this method (as well as the Activatable constructors that both register and export an activatable remote object) is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic. Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly. This method invokes the exportObject method with the specified object, location, data, restart mode, and port, and null for both client and server socket factories, and then returns the resulting activation identifier.
Registers an activation descriptor (with the specified location, data, and restart mode) for the specified object, and exports that object with the specified port, and the specified client and server socket factories. Note: Using this method (as well as the Activatable constructors that both register and export an activatable remote object) is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic. Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly. This method first registers an activation descriptor for the specified object as follows. It obtains the activation system by invoking the method ActivationGroup.getSystem. This method then obtains an ActivationID for the object by invoking the activation system's registerObject method with an ActivationDesc constructed with the specified object's class name, and the specified location, data, and restart mode. If an exception occurs obtaining the activation system or registering the activation descriptor, that exception is thrown to the caller. Next, this method exports the object by invoking the exportObject method with the specified remote object, the activation identifier obtained from registration, the specified port, and the specified client and server socket factories. If an exception occurs exporting the object, this method attempts to unregister the activation identifier (obtained from registration) by invoking the activation system's unregisterObject method with the activation identifier. If an exception occurs unregistering the identifier, that exception is ignored, and the original exception that occurred exporting the object is thrown to the caller. Finally, this method invokes the activeObject method on the activation group in this VM with the activation identifier and the specified remote object, and returns the activation identifier to the caller.
"Export the activatable remote object to the RMI runtime to make the object available to receive incoming calls. The object is exported on an anonymous port, if port is zero. During activation, this exportObject method should be invoked explicitly by an ""activatable"" object, that does not extend the Activatable class. There is no need for objects that do extend the Activatable class to invoke this method directly because the object is exported during construction."
"Export the activatable remote object to the RMI runtime to make the object available to receive incoming calls. The object is exported on an anonymous port, if port is zero. During activation, this exportObject method should be invoked explicitly by an ""activatable"" object, that does not extend the Activatable class. There is no need for objects that do extend the Activatable class to invoke this method directly because the object is exported during construction."
Remove the remote object, obj, from the RMI runtime. If successful, the object can no longer accept incoming RMI calls. If the force parameter is true, the object is forcibly unexported even if there are pending calls to the remote object or the remote object still has calls in progress. If the force parameter is false, the object is only unexported if there are no pending or in progress calls to the object.
Constructs an ActivateFailedException with the specified detail message.
Constructs an ActivateFailedException with the specified detail message and nested exception.
Constructs an object descriptor for an object whose class name is className, that can be loaded from the code location and whose initialization information is data. If this form of the constructor is used, the groupID defaults to the current id for ActivationGroup for this VM. All objects with the same ActivationGroupID are activated in the same VM. Note that objects specified by a descriptor created with this constructor will only be activated on demand (by default, the restart mode is false). If an activatable object requires restart services, use one of the ActivationDesc constructors that takes a boolean parameter, restart. This constructor will throw ActivationException if there is no current activation group for this VM. To create an ActivationGroup use the ActivationGroup.createGroup method.
Constructs an object descriptor for an object whose class name is className, that can be loaded from the code location and whose initialization information is data. If this form of the constructor is used, the groupID defaults to the current id for ActivationGroup for this VM. All objects with the same ActivationGroupID are activated in the same VM. This constructor will throw ActivationException if there is no current activation group for this VM. To create an ActivationGroup use the ActivationGroup.createGroup method.
Constructs an object descriptor for an object whose class name is className that can be loaded from the code location and whose initialization information is data. All objects with the same groupID are activated in the same Java VM. Note that objects specified by a descriptor created with this constructor will only be activated on demand (by default, the restart mode is false). If an activatable object requires restart services, use one of the ActivationDesc constructors that takes a boolean parameter, restart.
Constructs an object descriptor for an object whose class name is className that can be loaded from the code location and whose initialization information is data. All objects with the same groupID are activated in the same Java VM.
Returns the group identifier for the object specified by this descriptor. A group provides a way to aggregate objects into a single Java virtual machine. RMI creates/activates objects with the same groupID in the same virtual machine.
Returns the class name for the object specified by this descriptor.
Returns the code location for the object specified by this descriptor.
"Returns a ""marshalled object"" containing intialization/activation data for the object specified by this descriptor."
"Returns the ""restart"" mode of the object associated with this activation descriptor."
Compares two activation descriptors for content equality.
Return the same hashCode for similar ActivationDescs.
The cause of the activation exception. This field predates the general-purpose exception chaining facility. The Throwable.getCause() method is now the preferred means of obtaining this information.
Constructs an ActivationException.
Constructs an ActivationException with the specified detail message.
Constructs an ActivationException with the specified detail message and cause. This constructor sets the detail field to the specified Throwable.
Returns the detail message, including the message from the cause, if any, of this exception.
Returns the cause of this exception. This method returns the value of the detail field.
Constructs an activation group with the given activation group identifier. The group is exported as a java.rmi.server.UnicastRemoteObject.
The group's inactiveObject method is called indirectly via a call to the Activatable.inactive method. A remote object implementation must call Activatable's inactive method when that object deactivates (the object deems that it is no longer active). If the object does not call Activatable.inactive when it deactivates, the object will never be garbage collected since the group keeps strong references to the objects it creates. The group's inactiveObject method unexports the remote object from the RMI runtime so that the object can no longer receive incoming RMI calls. An object will only be unexported if the object has no pending or executing calls. The subclass of ActivationGroup must override this method and unexport the object. After removing the object from the RMI runtime, the group must inform its ActivationMonitor (via the monitor's inactiveObject method) that the remote object is not currently active so that the remote object will be re-activated by the activator upon a subsequent activation request. This method simply informs the group's monitor that the object is inactive. It is up to the concrete subclass of ActivationGroup to fulfill the additional requirement of unexporting the object.
The group's activeObject method is called when an object is exported (either by Activatable object construction or an explicit call to Activatable.exportObject. The group must inform its ActivationMonitor that the object is active (via the monitor's activeObject method) if the group hasn't already done so.
Create and set the activation group for the current VM. The activation group can only be set if it is not currently set. An activation group is set using the createGroup method when the Activator initiates the re-creation of an activation group in order to carry out incoming activate requests. A group must first be registered with the ActivationSystem before it can be created via this method. The group class specified by the ActivationGroupDesc must be a concrete subclass of ActivationGroup and have a public constructor that takes two arguments: the ActivationGroupID for the group and the MarshalledObject containing the group's initialization data (obtained from the ActivationGroupDesc. If the group class name specified in the ActivationGroupDesc is null, then this method will behave as if the group descriptor contained the name of the default activation group implementation class. Note that if your application creates its own custom activation group, a security manager must be set for that group. Otherwise objects cannot be activated in the group. SecurityManager is set by default. If a security manager is already set in the group VM, this method first calls the security manager's checkSetFactory method. This could result in a SecurityException. If your application needs to set a different security manager, you must ensure that the policy file specified by the group's ActivationGroupDesc grants the group the necessary permissions to set a new security manager. (Note: This will be necessary if your group downloads and sets a security manager). After the group is created, the ActivationSystem is informed that the group is active by calling the activeGroup method which returns the ActivationMonitor for the group. The application need not call activeGroup independently since it is taken care of by this method. Once a group is created, subsequent calls to the currentGroupID method will return the identifier for this group until the group becomes inactive.
Returns the current activation group's identifier. Returns null if no group is currently active for this VM.
"Set the activation system for the VM. The activation system can only be set it if no group is currently active. If the activation system is not set via this call, then the getSystem method attempts to obtain a reference to the ActivationSystem by looking up the name ""java.rmi.activation.ActivationSystem"" in the Activator's registry. By default, the port number used to look up the activation system is defined by ActivationSystem.SYSTEM_PORT. This port can be overridden by setting the property java.rmi.activation.port. If there is a security manager, this method first calls the security manager's checkSetFactory method. This could result in a SecurityException."
"Returns the activation system for the VM. The activation system may be set by the setSystem method. If the activation system is not set via the setSystem method, then the getSystem method attempts to obtain a reference to the ActivationSystem by looking up the name ""java.rmi.activation.ActivationSystem"" in the Activator's registry. By default, the port number used to look up the activation system is defined by ActivationSystem.SYSTEM_PORT. This port can be overridden by setting the property java.rmi.activation.port."
This protected method is necessary for subclasses to make the activeObject callback to the group's monitor. The call is simply forwarded to the group's ActivationMonitor.
This protected method is necessary for subclasses to make the inactiveGroup callback to the group's monitor. The call is simply forwarded to the group's ActivationMonitor. Also, the current group for the VM is set to null.
Create a CommandEnvironment with all the necessary information.
Fetch the configured path-qualified java command name.
Fetch the configured java command options.
Compares two command environments for content equality.
Return identical values for similar CommandEnvironments.
Constructs a group descriptor that uses the system defaults for group implementation and code location. Properties specify Java environment overrides (which will override system properties in the group implementation's VM). The command environment can control the exact command/options used in starting the child VM, or can be null to accept rmid's default. This constructor will create an ActivationGroupDesc with a null group class name, which indicates the system's default ActivationGroup implementation.
Specifies an alternate group implementation and execution environment to be used for the group.
Returns the group's class name (possibly null). A null group class name indicates the system's default ActivationGroup implementation.
Returns the group's code location.
Returns the group's initialization data.
Returns the group's property-override list.
Returns the group's command-environment control object.
Compares two activation group descriptors for content equality.
Produce identical numbers for similar ActivationGroupDescs.
Constructs a unique group id.
Returns the group's activation system.
Returns a hashcode for the group's identifier. Two group identifiers that refer to the same remote group will have the same hash code.
Compares two group identifiers for content equality. Returns true if both of the following conditions are true: 1) the unique identifiers are equivalent (by content), and 2) the activation system specified in each refers to the same remote object.
Constructs a stub for the ActivationGroup class. It invokes the superclass RemoteStub(RemoteRef) constructor with its argument, ref.
Stub method for ActivationGroup.newInstance. Invokes the invoke method on this instance's RemoteObject.ref field, with this as the first argument, a two-element Object[] as the second argument (with id as the first element and desc as the second element), and -5274445189091581345L as the third argument, and returns the result. If that invocation throws a RuntimeException, RemoteException, or an ActivationException, then that exception is thrown to the caller. If that invocation throws any other java.lang.Exception, then a java.rmi.UnexpectedException is thrown to the caller with the original exception as the cause.
The constructor for ActivationID takes a single argument, activator, that specifies a remote reference to the activator responsible for activating the object associated with this identifier. An instance of ActivationID is globally unique.
Activate the object for this id.
Returns a hashcode for the activation id. Two identifiers that refer to the same remote object will have the same hash code.
Compares two activation ids for content equality. Returns true if both of the following conditions are true: 1) the unique identifiers equivalent (by content), and 2) the activator specified in each identifier refers to the same remote object.
"The activator calls an instantiator's newInstance method in order to recreate in that group an object with the activation identifier, id, and descriptor, desc. The instantiator is responsible for: determining the class for the object using the descriptor's getClassName method, loading the class from the code location obtained from the descriptor (using the getLocation method), creating an instance of the class by invoking the special ""activation"" constructor of the object's class that takes two arguments: the object's ActivationID, and the MarshalledObject containing object specific initialization data, and returning a MarshalledObject containing the stub for the remote object it created"
An activation group calls its monitor's inactiveObject method when an object in its group becomes inactive (deactivates). An activation group discovers that an object (that it participated in activating) in its VM is no longer active, via calls to the activation group's inactiveObject method. The inactiveObject call informs the ActivationMonitor that the remote object reference it holds for the object with the activation identifier, id, is no longer valid. The monitor considers the reference associated with id as a stale reference. Since the reference is considered stale, a subsequent activate call for the same activation identifier results in re-activating the remote object.
"Informs that an object is now active. An ActivationGroup informs its monitor if an object in its group becomes active by other means than being activated directly (i.e., the object is registered and ""activated"" itself)."
Informs that the group is now inactive. The group will be recreated upon a subsequent request to activate an object within the group. A group becomes inactive when all objects in the group report that they are inactive.
The port to lookup the activation system.
The registerObject method is used to register an activation descriptor, desc, and obtain an activation identifier for a activatable remote object. The ActivationSystem creates an ActivationID (a activation identifier) for the object specified by the descriptor, desc, and records, in stable storage, the activation descriptor and its associated identifier for later use. When the Activator receives an activate request for a specific identifier, it looks up the activation descriptor (registered previously) for the specified identifier and uses that information to activate the object.
Remove the activation id and associated descriptor previously registered with the ActivationSystem; the object can no longer be activated via the object's activation id.
Register the activation group. An activation group must be registered with the ActivationSystem before objects can be registered within that group.
Callback to inform activation system that group is now active. This call is made internally by the ActivationGroup.createGroup method to inform the ActivationSystem that the group is now active.
Remove the activation group. An activation group makes this call back to inform the activator that the group should be removed (destroyed). If this call completes successfully, objects can no longer be registered or activated within the group. All information of the group and its associated objects is removed from the system.
Shutdown the activation system. Destroys all groups spawned by the activation daemon and exits the activation daemon.
Set the activation descriptor, desc for the object with the activation identifier, id. The change will take effect upon subsequent activation of the object.
Set the activation group descriptor, desc for the object with the activation group identifier, id. The change will take effect upon subsequent activation of the group.
Returns the activation descriptor, for the object with the activation identifier, id.
Returns the activation group descriptor, for the group with the activation group identifier, id.
"Activate the object associated with the activation identifier, id. If the activator knows the object to be active already, and force is false , the stub with a ""live"" reference is returned immediately to the caller; otherwise, if the activator does not know that corresponding the remote object is active, the activator uses the activation descriptor information (previously registered) to determine the group (VM) in which the object should be activated. If an ActivationInstantiator corresponding to the object's group descriptor already exists, the activator invokes the activation group's newInstance method passing it the object's id and descriptor. If the activation group for the object's group descriptor does not yet exist, the activator starts an ActivationInstantiator executing (by spawning a child process, for example). When the activator receives the activation group's call back (via the ActivationSystem's activeGroup method) specifying the activation group's reference, the activator can then invoke that activation instantiator's newInstance method to forward each pending activation request to the activation group and return the result (a marshalled remote object reference, a stub) to the caller. Note that the activator receives a ""marshalled"" object instead of a Remote object so that the activator does not need to load the code for that object, or participate in distributed garbage collection for that object. If the activator kept a strong reference to the remote object, the activator would then prevent the object from being garbage collected under the normal distributed garbage collection mechanism."
Constructs an UnknownGroupException with the specified detail message.
Constructs an UnknownObjectException with the specified detail message.
The dirty call requests leases for the remote object references associated with the object identifiers contained in the array 'ids'. The 'lease' contains a client's unique VM identifier (VMID) and a requested lease period. For each remote object exported in the local VM, the garbage collector maintains a reference list-a list of clients that hold references to it. If the lease is granted, the garbage collector adds the client's VMID to the reference list for each remote object indicated in 'ids'. The 'sequenceNum' parameter is a sequence number that is used to detect and discard late calls to the garbage collector. The sequence number should always increase for each subsequent call to the garbage collector. Some clients are unable to generate a VMID, since a VMID is a universally unique identifier that contains a host address which some clients are unable to obtain due to security restrictions. In this case, a client can use a VMID of null, and the distributed garbage collector will assign a VMID for the client. The dirty call returns a Lease object that contains the VMID used and the lease period granted for the remote references (a server may decide to grant a smaller lease period than the client requests). A client must use the VMID the garbage collector uses in order to make corresponding clean calls when the client drops remote object references. A client VM need only make one initial dirty call for each remote reference referenced in the VM (even if it has multiple references to the same remote object). The client must also make a dirty call to renew leases on remote references before such leases expire. When the client no longer has any references to a specific remote object, it must schedule a clean call for the object ID associated with the reference.
The clean call removes the 'vmid' from the reference list of each remote object indicated in 'id's. The sequence number is used to detect late clean calls. If the argument 'strong' is true, then the clean call is a result of a failed dirty call, thus the sequence number for the client 'vmid' needs to be remembered.
Constructs a lease with a specific VMID and lease duration. The vmid may be null.
Returns the client VMID associated with the lease.
Returns the lease duration.
Create a new VMID. Each new VMID returned from this constructor is unique for all Java virtual machines under the following conditions: a) the conditions for uniqueness for objects of the class java.rmi.server.UID are satisfied, and b) an address can be obtained for this host that is unique and constant for the lifetime of this object.
Return true if an accurate address can be determined for this host. If false, reliable VMID cannot be generated from this host
Compute hash code for this VMID.
Compare this VMID to another, and return true if they are the same identifier.
Return string representation of this VMID.
Returns a reference to the the remote object Registry for the local host on the default registry port of 1099.
Returns a reference to the the remote object Registry for the local host on the specified port.
Returns a reference to the remote object Registry on the specified host on the default registry port of 1099. If host is null, the local host is used.
Returns a reference to the remote object Registry on the specified host and port. If host is null, the local host is used.
Returns a locally created remote reference to the remote object Registry on the specified host and port. Communication with this remote registry will use the supplied RMIClientSocketFactory csf to create Socket connections to the registry on the remote host and port.
Creates and exports a Registry instance on the local host that accepts requests on the specified port. The Registry instance is exported as if the static UnicastRemoteObject.exportObject method is invoked, passing the Registry instance and the specified port as arguments, except that the Registry instance is exported with a well-known object identifier, an ObjID instance constructed with the value ObjID.REGISTRY_ID.
Creates and exports a Registry instance on the local host that uses custom socket factories for communication with that instance. The registry that is created listens for incoming requests on the given port using a ServerSocket created from the supplied RMIServerSocketFactory. The Registry instance is exported as if the static UnicastRemoteObject.exportObject method is invoked, passing the Registry instance, the specified port, the specified RMIClientSocketFactory, and the specified RMIServerSocketFactory as arguments, except that the Registry instance is exported with a well-known object identifier, an ObjID instance constructed with the value ObjID.REGISTRY_ID.
Well known port for registry.
Returns the remote reference bound to the specified name in this registry.
Binds a remote reference to the specified name in this registry.
Removes the binding for the specified name in this registry.
Replaces the binding for the specified name in this registry with the supplied remote reference. If there is an existing binding for the specified name, it is discarded.
Returns an array of the names bound in this registry. The array will contain a snapshot of the names bound in this registry at the time of the given invocation of this method.
"Returns a ""stub"" for contacting a remote registry on the specified host and port."
Constructs and exports a Registry on the specified port. The port must be non-zero.
Constructs an ExportException with the specified detail message.
Constructs an ExportException with the specified detail message and nested exception.
package of system LoaderHandler implementation.
Loads a class from the location specified by the java.rmi.server.codebase property.
Loads a class from a URL.
Returns the security context of the given class loader.
log level constant (no logging).
log level constant (brief logging).
log level constant (verbose logging).
"Return the LogStream identified by the given name. If a log corresponding to ""name"" does not exist, a log using the default stream is created."
Return the current default stream for new logs.
Set the default stream for new logs.
Return the current stream to which output from this log is sent.
Set the stream to which output from this log is sent.
Write a byte of data to the stream. If it is not a newline, then the byte is appended to the internal buffer. If it is a newline, then the currently buffered line is sent to the log's output stream, prefixed with the appropriate logging information.
Write a subarray of bytes. Pass each through write byte method.
Return log name as string representation.
Convert a string name of a logging level to its internal integer representation.
Object number for well-known ObjID of the registry.
Object number for well-known ObjID of the activator.
Object number for well-known ObjID of the distributed garbage collector.
"Generates a unique object identifier. If the system property java.rmi.server.randomIDs is defined to equal the string ""true"" (case insensitive), then this constructor will use a cryptographically strong random number generator to choose the object number of the returned ObjID."
"Creates a ""well-known"" object identifier. An ObjID created via this constructor will not clash with any ObjIDs generated via the no-arg constructor."
Marshals a binary representation of this ObjID to an ObjectOutput instance. Specifically, this method first invokes the given stream's DataOutput.writeLong(long) method with this object identifier's object number, and then it writes its address space identifier by invoking its UID.write(DataOutput) method with the stream.
Constructs and returns a new ObjID instance by unmarshalling a binary representation from an ObjectInput instance. Specifically, this method first invokes the given stream's DataInput.readLong() method to read an object number, then it invokes UID.read(DataInput) with the stream to read an address space identifier, and then it creates and returns a new ObjID instance that contains the object number and address space identifier that were read from the stream.
Returns the hash code value for this object identifier, the object number.
Compares the specified object with this ObjID for equality. This method returns true if and only if the specified object is an ObjID instance with the same object number and address space identifier as this one.
Returns a string representation of this object identifier.
Creates a new Operation object.
Returns the name of the method.
Returns the string representation of the operation.
Return the output stream the stub/skeleton should put arguments/results into.
Release the output stream; in some transports this would release the stream.
Get the InputStream that the stub/skeleton should get results/arguments from.
Release the input stream. This would allow some transports to release the channel early.
Returns an output stream (may put out header information relating to the success of the call). Should only succeed once per remote call.
Do whatever it takes to execute the call.
Allow cleanup after the remote call has completed.
The object's remote reference.
Creates a remote object.
Creates a remote object, initialized with the specified remote reference.
Returns the remote reference for the remote object. Note: The object returned from this method may be an instance of an implementation-specific class. The RemoteObject class ensures serialization portability of its instances' remote references through the behavior of its custom writeObject and readObject methods. An instance of RemoteRef should not be serialized outside of its RemoteObject wrapper instance or the result may be unportable.
Returns the stub for the remote object obj passed as a parameter. This operation is only valid after the object has been exported.
Returns a hashcode for a remote object. Two remote object stubs that refer to the same remote object will have the same hash code (in order to support remote objects as keys in hash tables).
Compares two remote objects for equality. Returns a boolean that indicates whether this remote object is equivalent to the specified Object. This method is used when a remote object is stored in a hashtable. If the specified Object is not itself an instance of RemoteObject, then this method delegates by returning the result of invoking the equals method of its parameter with this remote object as the argument.
Returns a String that represents the value of this remote object.
Creates a new RemoteObjectInvocationHandler constructed with the specified RemoteRef.
"Processes a method invocation made on the encapsulating proxy instance, proxy, and returns the result. RemoteObjectInvocationHandler implements this method as follows: If method is one of the following methods, it is processed as described below: Object.hashCode: Returns the hash code value for the proxy. Object.equals: Returns true if the argument (args[0]) is an instance of a dynamic proxy class and this invocation handler is equal to the invocation handler of that argument, and returns false otherwise. Object.toString: Returns a string representation of the proxy. Otherwise, a remote call is made as follows: If proxy is not an instance of the interface Remote, then an IllegalArgumentException is thrown. Otherwise, the invoke method is invoked on this invocation handler's RemoteRef, passing proxy, method, args, and the method hash (defined in section 8.3 of the ""Java Remote Method Invocation (RMI) Specification"") for method, and the result is returned. If an exception is thrown by RemoteRef.invoke and that exception is a checked exception that is not assignable to any exception in the throws clause of the method implemented by the proxy's class, then that exception is wrapped in an UnexpectedException and the wrapped exception is thrown. Otherwise, the exception thrown by invoke is thrown by this method. The semantics of this method are unspecified if the arguments could not have been produced by an instance of some valid dynamic proxy class containing this invocation handler."
indicate compatibility with JDK 1.1.x version of class.
Initialize the server package prefix: assumes that the implementation of server ref classes (e.g., UnicastRef, UnicastServerRef) are located in the package defined by the prefix.
Invoke a method. This form of delegating method invocation to the reference allows the reference to take care of setting up the connection to the remote host, marshaling some representation for the method and parameters, then communicating the method invocation to the remote host. This method either returns the result of a method invocation on the remote object which resides on the remote host or throws a RemoteException if the call failed or an application-level exception if the remote invocation throws an exception.
Creates an appropriate call object for a new remote method invocation on this object. Passing operation array and index, allows the stubs generator to assign the operation indexes and interpret them. The remote reference may need the operation to encode in the call.
"Executes the remote call. Invoke will raise any ""user"" exceptions which should pass through and not be caught by the stub. If any exception is raised during the remote invocation, invoke should take care of cleaning up the connection before raising the ""user"" or remote exception."
Allows the remote reference to clean up (or reuse) the connection. Done should only be called if the invoke returns successfully (non-exceptionally) to the stub.
Returns the class name of the ref type to be serialized onto the stream 'out'.
Returns a hashcode for a remote object. Two remote object stubs that refer to the same remote object will have the same hash code (in order to support remote objects as keys in hash tables).
Compares two remote objects for equality. Returns a boolean that indicates whether this remote object is equivalent to the specified Object. This method is used when a remote object is stored in a hashtable.
Returns a String that represents the reference of this remote object.
Constructs a RemoteServer.
Constructs a RemoteServer with the given reference type.
Returns a string representation of the client host for the remote method invocation being processed in the current thread.
"Log RMI calls to the output stream out. If out is null, call logging is turned off. If there is a security manager, its checkPermission method will be invoked with a java.util.logging.LoggingPermission(""control"") permission; this could result in a SecurityException."
Returns stream for the RMI call log.
Constructs a RemoteStub.
Constructs a RemoteStub with the specified remote reference.
Throws UnsupportedOperationException.
Loads the class with the specified name. This method delegates to loadClass(String,String), passing null as the first argument and name as the second argument.
Loads a class from a codebase URL. If codebase is null, then this method will behave the same as loadClass(String,String) with a null codebase and the given class name. This method delegates to the RMIClassLoaderSpi.loadClass(String,String,ClassLoader) method of the provider instance, passing the result of invoking URL.toString() on the given URL (or null if codebase is null) as the first argument, name as the second argument, and null as the third argument.
Loads a class from a codebase URL path. This method delegates to the RMIClassLoaderSpi.loadClass(String,String,ClassLoader) method of the provider instance, passing codebase as the first argument, name as the second argument, and null as the third argument.
Loads a class from a codebase URL path, optionally using the supplied loader. This method should be used when the caller would like to make available to the provider implementation an additional contextual class loader to consider, such as the loader of a caller on the stack. Typically, a provider implementation will attempt to resolve the named class using the given defaultLoader, if specified, before attempting to resolve the class from the codebase URL path. This method delegates to the RMIClassLoaderSpi.loadClass(String,String,ClassLoader) method of the provider instance, passing codebase as the first argument, name as the second argument, and defaultLoader as the third argument.
Loads a dynamic proxy class (see Proxy) that implements a set of interfaces with the given names from a codebase URL path. The interfaces will be resolved similar to classes loaded via the loadClass(String,String) method using the given codebase. This method delegates to the RMIClassLoaderSpi.loadProxyClass(String,String[],ClassLoader) method of the provider instance, passing codebase as the first argument, interfaces as the second argument, and defaultLoader as the third argument.
"Returns a class loader that loads classes from the given codebase URL path. The class loader returned is the class loader that the loadClass(String,String) method would use to load classes for the same codebase argument. This method delegates to the RMIClassLoaderSpi.getClassLoader(String) method of the provider instance, passing codebase as the argument. If there is a security manger, its checkPermission method will be invoked with a RuntimePermission(""getClassLoader"") permission; this could result in a SecurityException. The provider implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path."
Returns the annotation string (representing a location for the class definition) that RMI will use to annotate the class descriptor when marshalling objects of the given class. This method delegates to the RMIClassLoaderSpi.getClassAnnotation(Class) method of the provider instance, passing cl as the argument.
"Returns the canonical instance of the default provider for the service provider interface RMIClassLoaderSpi. If the system property java.rmi.server.RMIClassLoaderSpi is not defined, then the RMIClassLoader static methods loadClass(URL,String) loadClass(String,String) loadClass(String,String,ClassLoader) loadProxyClass(String,String[],ClassLoader) getClassLoader(String) getClassAnnotation(Class) will use the canonical instance of the default provider as the service provider instance. If there is a security manager, its checkPermission method will be invoked with a RuntimePermission(""setFactory"") permission; this could result in a SecurityException. The default service provider instance implements RMIClassLoaderSpi as follows: The getClassAnnotation method returns a String representing the codebase URL path that a remote party should use to download the definition for the specified class. The format of the returned string is a path of URLs separated by spaces. The codebase string returned depends on the defining class loader of the specified class: If the class loader is the system class loader (see ClassLoader.getSystemClassLoader()), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by null), then the value of the java.rmi.server.codebase property (or possibly an earlier cached value) is returned, or null is returned if that property is not set. Otherwise, if the class loader is an instance of URLClassLoader, then the returned string is a space-separated list of the external forms of the URLs returned by invoking the getURLs methods of the loader. If the URLClassLoader was created by this provider to service an invocation of its loadClass or loadProxyClass methods, then no permissions are required to get the associated codebase string. If it is an arbitrary other URLClassLoader instance, then if there is a security manager, its checkPermission method will be invoked once for each URL returned by the getURLs method, with the permission returned by invoking openConnection().getPermission() on each URL; if any of those invocations throws a SecurityException or an IOException, then the value of the java.rmi.server.codebase property (or possibly an earlier cached value) is returned, or null is returned if that property is not set. Finally, if the class loader is not an instance of URLClassLoader, then the value of the java.rmi.server.codebase property (or possibly an earlier cached value) is returned, or null is returned if that property is not set. For the implementations of the methods described below, which all take a String parameter named codebase that is a space-separated list of URLs, each invocation has an associated codebase loader that is identified using the codebase argument in conjunction with the current thread's context class loader (see Thread.getContextClassLoader()). When there is a security manager, this provider maintains an internal table of class loader instances (which are at least instances of URLClassLoader) keyed by the pair of their parent class loader and their codebase URL path (an ordered list of URLs). If the codebase argument is null, the codebase URL path is the value of the system property java.rmi.server.codebase or possibly an earlier cached value. For a given codebase URL path passed as the codebase argument to an invocation of one of the below methods in a given context, the codebase loader is the loader in the table with the specified codebase URL path and the current thread's context class loader as its parent. If no such loader exists, then one is created and added to the table. The table does not maintain strong references to its contained loaders, in order to allow them and their defined classes to be garbage collected when not otherwise reachable. In order to prevent arbitrary untrusted code from being implicitly loaded into a virtual machine with no security manager, if there is no security manager set, the codebase loader is just the current thread's context class loader (the supplied codebase URL path is ignored, so remote class loading is disabled). The getClassLoader method returns the codebase loader for the specified codebase URL path. If there is a security manager, then if the calling context does not have permission to connect to all of the URLs in the codebase URL path, a SecurityException will be thrown. The loadClass method attempts to load the class with the specified name as follows: If the defaultLoader argument is non-null, it first attempts to load the class with the specified name using the defaultLoader, such as by evaluating Class.forName(name, false, defaultLoader) If the class is successfully loaded from the defaultLoader, that class is returned. If an exception other than ClassNotFoundException is thrown, that exception is thrown to the caller. Next, the loadClass method attempts to load the class with the specified name using the codebase loader for the specified codebase URL path. If there is a security manager, then the calling context must have permission to connect to all of the URLs in the codebase URL path; otherwise, the current thread's context class loader will be used instead of the codebase loader. The loadProxyClass method attempts to return a dynamic proxy class with the named interface as follows: If the defaultLoader argument is non-null and all of the named interfaces can be resolved through that loader, then, if all of the resolved interfaces are public, then it first attempts to obtain a dynamic proxy class (using Proxy.getProxyClass) for the resolved interfaces defined in the codebase loader; if that attempt throws an IllegalArgumentException, it then attempts to obtain a dynamic proxy class for the resolved interfaces defined in the defaultLoader. If both attempts throw IllegalArgumentException, then this method throws a ClassNotFoundException. If any other exception is thrown, that exception is thrown to the caller. if all of the non-public resolved interfaces are defined in the same class loader, then it attempts to obtain a dynamic proxy class for the resolved interfaces defined in that loader. otherwise, a LinkageError is thrown (because a class that implements all of the specified interfaces cannot be defined in any loader). Otherwise, if all of the named interfaces can be resolved through the codebase loader, then, if all of the resolved interfaces are public, then it attempts to obtain a dynamic proxy class for the resolved interfaces in the codebase loader. If the attempt throws an IllegalArgumentException, then this method throws a ClassNotFoundException. if all of the non-public resolved interfaces are defined in the same class loader, then it attempts to obtain a dynamic proxy class for the resolved interfaces defined in that loader. otherwise, a LinkageError is thrown (because a class that implements all of the specified interfaces cannot be defined in any loader). Otherwise, a ClassNotFoundException is thrown for one of the named interfaces that could not be resolved."
Returns the security context of the given class loader.
Provides the implementation for RMIClassLoader.loadClass(URL,String), RMIClassLoader.loadClass(String,String), and RMIClassLoader.loadClass(String,String,ClassLoader). Loads a class from a codebase URL path, optionally using the supplied loader. Typically, a provider implementation will attempt to resolve the named class using the given defaultLoader, if specified, before attempting to resolve the class from the codebase URL path. An implementation of this method must either return a class with the given name or throw an exception.
Provides the implementation for RMIClassLoader.loadProxyClass(String,String[],ClassLoader). Loads a dynamic proxy class (see Proxy that implements a set of interfaces with the given names from a codebase URL path, optionally using the supplied loader. An implementation of this method must either return a proxy class that implements the named interfaces or throw an exception.
"Provides the implementation for RMIClassLoader.getClassLoader(String). Returns a class loader that loads classes from the given codebase URL path. If there is a security manger, its checkPermission method will be invoked with a RuntimePermission(""getClassLoader"") permission; this could result in a SecurityException. The implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path."
Provides the implementation for RMIClassLoader.getClassAnnotation(Class). Returns the annotation string (representing a location for the class definition) that RMI will use to annotate the class descriptor when marshalling objects of the given class.
Create a client socket connected to the specified host and port.
The failure callback is invoked when the RMI runtime is unable to create a ServerSocket via the RMISocketFactory. An RMIFailureHandler is registered via a call to RMISocketFacotry.setFailureHandler. If no failure handler is installed, the default behavior is to attempt to re-create the ServerSocket.
Create a server socket on the specified port (port 0 indicates an anonymous port).
Constructs an RMISocketFactory.
Creates a client socket connected to the specified host and port.
Create a server socket on the specified port (port 0 indicates an anonymous port).
Set the global socket factory from which RMI gets sockets (if the remote object is not associated with a specific client and/or server socket factory). The RMI socket factory can only be set once. Note: The RMISocketFactory may only be set if the current security manager allows setting a socket factory; if disallowed, a SecurityException will be thrown.
Returns the socket factory set by the setSocketFactory method. Returns null if no socket factory has been set.
Returns a reference to the default socket factory used by this RMI implementation. This will be the factory used by the RMI runtime when getSocketFactory returns null.
Sets the failure handler to be called by the RMI runtime if server socket creation fails. By default, if no failure handler is installed and server socket creation fails, the RMI runtime does attempt to recreate the server socket. If there is a security manager, this method first calls the security manager's checkSetFactory method to ensure the operation is allowed. This could result in a SecurityException.
Returns the handler for socket creation failure set by the setFailureHandler method.
The cause of the exception. This field predates the general-purpose exception chaining facility. The Throwable.getCause() method is now the preferred means of obtaining this information.
Constructs a ServerCloneException with the specified detail message.
Constructs a ServerCloneException with the specified detail message and cause.
Returns the detail message, including the message from the cause, if any, of this exception.
Returns the cause of this exception. This method returns the value of the detail field.
Constructs an ServerNotActiveException with no specified detail message.
Constructs an ServerNotActiveException with the specified detail message.
indicate compatibility with JDK 1.1.x version of class.
Creates a client stub object for the supplied Remote object. If the call completes successfully, the remote object should be able to accept incoming calls from clients.
Returns the hostname of the current client. When called from a thread actively handling a remote method invocation the hostname of the client is returned.
Unmarshals arguments, calls the actual remote object implementation, and marshals the return value or any exception.
Returns the operations supported by the skeleton.
Constructs a new SkeletonMismatchException with a specified detail message.
Constructs a SkeletonNotFoundException with the specified detail message.
Constructs a SkeletonNotFoundException with the specified detail message and nested exception.
Constructs an SocketSecurityException with the specified detail message.
Constructs an SocketSecurityException with the specified detail message and nested exception.
Generates a UID that is unique over time with respect to the host that it was generated on.
"Creates a ""well-known"" UID. There are 216 possible such well-known ids. A UID created via this constructor will not clash with any UIDs generated via the no-arg constructor."
Returns the hash code value for this UID.
Compares the specified object with this UID for equality. This method returns true if and only if the specified object is a UID instance with the same unique, time, and count values as this one.
Returns a string representation of this UID.
Marshals a binary representation of this UID to a DataOutput instance. Specifically, this method first invokes the given stream's DataOutput.writeInt(int) method with this UID's unique value, then it invokes the stream's DataOutput.writeLong(long) method with this UID's time value, and then it invokes the stream's DataOutput.writeShort(int) method with this UID's count value.
Constructs and returns a new UID instance by unmarshalling a binary representation from an DataInput instance. Specifically, this method first invokes the given stream's DataInput.readInt() method to read a unique value, then it invoke's the stream's DataInput.readLong() method to read a time value, then it invoke's the stream's DataInput.readShort() method to read a count value, and then it creates and returns a new UID instance that contains the unique, time, and count values that were read from the stream.
Creates and exports a new UnicastRemoteObject object using an anonymous port. The object is exported with a server socket created using the RMISocketFactory class.
Creates and exports a new UnicastRemoteObject object using the particular supplied port. The object is exported with a server socket created using the RMISocketFactory class.
Creates and exports a new UnicastRemoteObject object using the particular supplied port and socket factories. Either socket factory may be null, in which case the corresponding client or server socket creation method of RMISocketFactory is used instead.
Returns a clone of the remote object that is distinct from the original.
Exports the remote object to make it available to receive incoming calls using an anonymous port. This method will always return a statically generated stub. The object is exported with a server socket created using the RMISocketFactory class.
Exports the remote object to make it available to receive incoming calls, using the particular supplied port. The object is exported with a server socket created using the RMISocketFactory class.
Exports the remote object to make it available to receive incoming calls, using a transport specified by the given socket factory. Either socket factory may be null, in which case the corresponding client or server socket creation method of RMISocketFactory is used instead.
Removes the remote object, obj, from the RMI runtime. If successful, the object can no longer accept incoming RMI calls. If the force parameter is true, the object is forcibly unexported even if there are pending calls to the remote object or the remote object still has calls in progress. If the force parameter is false, the object is only unexported if there are no pending or in progress calls to the object.
Called by the RMI runtime sometime after the runtime determines that the reference list, the list of clients referencing the remote object, becomes empty.
Create an AccessControlContext with the given array of ProtectionDomains. Context must not be null. Duplicate domains will be removed from the context.
Create a new AccessControlContext with the given AccessControlContext and DomainCombiner. This constructor associates the provided DomainCombiner with the provided AccessControlContext.
Get the DomainCombiner associated with this AccessControlContext.
Determines whether the access request indicated by the specified permission should be allowed or denied, based on the security policy currently in effect, and the context in this object. The request is allowed only if every ProtectionDomain in the context implies the permission. Otherwise the request is denied. This method quietly returns if the access request is permitted, or throws a suitable AccessControlException otherwise.
Checks two AccessControlContext objects for equality. Checks that obj is an AccessControlContext and has the same set of ProtectionDomains as this context.
Returns the hash code value for this context. The hash code is computed by exclusive or-ing the hash code of all the protection domains in the context together.
Constructs an AccessControlException with the specified, detailed message.
Constructs an AccessControlException with the specified, detailed message, and the requested permission that caused the exception.
Gets the Permission object associated with this exception, or null if there was no corresponding Permission object.
Performs the specified PrivilegedAction with privileges enabled. The action is performed with all of the permissions possessed by the caller's protection domain. If the action's run method throws an (unchecked) exception, it will propagate through this method. Note that any DomainCombiner associated with the current AccessControlContext will be ignored while the action is performed.
Performs the specified PrivilegedAction with privileges enabled. The action is performed with all of the permissions possessed by the caller's protection domain. If the action's run method throws an (unchecked) exception, it will propagate through this method. This method preserves the current AccessControlContext's DomainCombiner (which may be null) while the action is performed.
"Performs the specified PrivilegedAction with privileges enabled and restricted by the specified AccessControlContext. The action is performed with the intersection of the permissions possessed by the caller's protection domain, and those possessed by the domains represented by the specified AccessControlContext. If the action's run method throws an (unchecked) exception, it will propagate through this method. If a security manager is installed and the specified AccessControlContext was not created by system code and the caller's ProtectionDomain has not been granted the ""createAccessControlContext"" SecurityPermission, then the action is performed with no permissions."
"Performs the specified PrivilegedAction with privileges enabled and restricted by the specified AccessControlContext and with a privilege scope limited by specified Permission arguments. The action is performed with the intersection of the permissions possessed by the caller's protection domain, and those possessed by the domains represented by the specified AccessControlContext. If the action's run method throws an (unchecked) exception, it will propagate through this method. If a security manager is installed and the specified AccessControlContext was not created by system code and the caller's ProtectionDomain has not been granted the ""createAccessControlContext"" SecurityPermission, then the action is performed with no permissions."
"Performs the specified PrivilegedAction with privileges enabled and restricted by the specified AccessControlContext and with a privilege scope limited by specified Permission arguments. The action is performed with the intersection of the permissions possessed by the caller's protection domain, and those possessed by the domains represented by the specified AccessControlContext. If the action's run method throws an (unchecked) exception, it will propagate through this method. This method preserves the current AccessControlContext's DomainCombiner (which may be null) while the action is performed. If a security manager is installed and the specified AccessControlContext was not created by system code and the caller's ProtectionDomain has not been granted the ""createAccessControlContext"" SecurityPermission, then the action is performed with no permissions."
Performs the specified PrivilegedExceptionAction with privileges enabled. The action is performed with all of the permissions possessed by the caller's protection domain. If the action's run method throws an unchecked exception, it will propagate through this method. Note that any DomainCombiner associated with the current AccessControlContext will be ignored while the action is performed.
Performs the specified PrivilegedExceptionAction with privileges enabled. The action is performed with all of the permissions possessed by the caller's protection domain. If the action's run method throws an unchecked exception, it will propagate through this method. This method preserves the current AccessControlContext's DomainCombiner (which may be null) while the action is performed.
"Performs the specified PrivilegedExceptionAction with privileges enabled and restricted by the specified AccessControlContext. The action is performed with the intersection of the permissions possessed by the caller's protection domain, and those possessed by the domains represented by the specified AccessControlContext. If the action's run method throws an unchecked exception, it will propagate through this method. If a security manager is installed and the specified AccessControlContext was not created by system code and the caller's ProtectionDomain has not been granted the ""createAccessControlContext"" SecurityPermission, then the action is performed with no permissions."
"Performs the specified PrivilegedExceptionAction with privileges enabled and restricted by the specified AccessControlContext and with a privilege scope limited by specified Permission arguments. The action is performed with the intersection of the permissions possessed by the caller's protection domain, and those possessed by the domains represented by the specified AccessControlContext. If the action's run method throws an (unchecked) exception, it will propagate through this method. If a security manager is installed and the specified AccessControlContext was not created by system code and the caller's ProtectionDomain has not been granted the ""createAccessControlContext"" SecurityPermission, then the action is performed with no permissions."
"Performs the specified PrivilegedExceptionAction with privileges enabled and restricted by the specified AccessControlContext and with a privilege scope limited by specified Permission arguments. The action is performed with the intersection of the permissions possessed by the caller's protection domain, and those possessed by the domains represented by the specified AccessControlContext. If the action's run method throws an (unchecked) exception, it will propagate through this method. This method preserves the current AccessControlContext's DomainCombiner (which may be null) while the action is performed. If a security manager is installed and the specified AccessControlContext was not created by system code and the caller's ProtectionDomain has not been granted the ""createAccessControlContext"" SecurityPermission, then the action is performed with no permissions."
"This method takes a ""snapshot"" of the current calling context, which includes the current Thread's inherited AccessControlContext and any limited privilege scope, and places it in an AccessControlContext object. This context may then be checked at a later point, possibly in another thread."
Determines whether the access request indicated by the specified permission should be allowed or denied, based on the current AccessControlContext and security policy. This method quietly returns if the access request is permitted, or throws an AccessControlException otherwise. The getPermission method of the AccessControlException returns the perm Permission object instance.
Determines whether an algorithm is granted permission for the specified cryptographic primitives.
Determines whether a key is granted permission for the specified cryptographic primitives. This method is usually used to check key size and key usage.
Determines whether an algorithm and the corresponding key are granted permission for the specified cryptographic primitives.
Creates an AlgorithmParameterGenerator object.
Returns the standard name of the algorithm this parameter generator is associated with.
Returns an AlgorithmParameterGenerator object for generating a set of parameters to be used with the specified algorithm. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new AlgorithmParameterGenerator object encapsulating the AlgorithmParameterGeneratorSpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the Security.getProviders() method.
Returns an AlgorithmParameterGenerator object for generating a set of parameters to be used with the specified algorithm. A new AlgorithmParameterGenerator object encapsulating the AlgorithmParameterGeneratorSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the Security.getProviders() method.
Returns an AlgorithmParameterGenerator object for generating a set of parameters to be used with the specified algorithm. A new AlgorithmParameterGenerator object encapsulating the AlgorithmParameterGeneratorSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.
Returns the provider of this algorithm parameter generator object.
Initializes this parameter generator for a certain size. To create the parameters, the SecureRandom implementation of the highest-priority installed provider is used as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness is used.)
Initializes this parameter generator for a certain size and source of randomness.
Initializes this parameter generator with a set of algorithm-specific parameter generation values. To generate the parameters, the SecureRandom implementation of the highest-priority installed provider is used as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness is used.)
Initializes this parameter generator with a set of algorithm-specific parameter generation values.
Generates the parameters.
Initializes this parameter generator for a certain size and source of randomness.
Initializes this parameter generator with a set of algorithm-specific parameter generation values.
Generates the parameters.
Creates an AlgorithmParameters object.
Returns the name of the algorithm associated with this parameter object.
Returns a parameter object for the specified algorithm. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new AlgorithmParameters object encapsulating the AlgorithmParametersSpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the Security.getProviders() method. The returned parameter object must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.
Returns a parameter object for the specified algorithm. A new AlgorithmParameters object encapsulating the AlgorithmParametersSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the Security.getProviders() method. The returned parameter object must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.
Returns a parameter object for the specified algorithm. A new AlgorithmParameters object encapsulating the AlgorithmParametersSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list. The returned parameter object must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.
Returns the provider of this parameter object.
Initializes this parameter object using the parameters specified in paramSpec.
Imports the specified parameters and decodes them according to the primary decoding format for parameters. The primary decoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.
Imports the parameters from params and decodes them according to the specified decoding scheme. If format is null, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for these parameters exists.
Returns a (transparent) specification of this parameter object. paramSpec identifies the specification class in which the parameters should be returned. It could, for example, be DSAParameterSpec.class, to indicate that the parameters should be returned in an instance of the DSAParameterSpec class.
Returns the parameters in their primary encoding format. The primary encoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.
Returns the parameters encoded in the specified scheme. If format is null, the primary encoding format for parameters is used. The primary encoding format is ASN.1, if an ASN.1 specification for these parameters exists.
Returns a formatted string describing the parameters.
Initializes this parameters object using the parameters specified in paramSpec.
Imports the specified parameters and decodes them according to the primary decoding format for parameters. The primary decoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.
Imports the parameters from params and decodes them according to the specified decoding format. If format is null, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for these parameters exists.
Returns a (transparent) specification of this parameters object. paramSpec identifies the specification class in which the parameters should be returned. It could, for example, be DSAParameterSpec.class, to indicate that the parameters should be returned in an instance of the DSAParameterSpec class.
Returns the parameters in their primary encoding format. The primary encoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.
Returns the parameters encoded in the specified format. If format is null, the primary encoding format for parameters is used. The primary encoding format is ASN.1, if an ASN.1 specification for these parameters exists.
Returns a formatted string describing the parameters.
Creates a new AllPermission object.
Creates a new AllPermission object. This constructor exists for use by the Policy object to instantiate new Permission objects.
"Checks if the specified permission is ""implied"" by this object. This method always returns true."
Checks two AllPermission objects for equality. Two AllPermission objects are always equal.
Returns the hash code value for this object.
Returns the canonical string representation of the actions.
Returns a new PermissionCollection object for storing AllPermission objects.
Constructs a provider with the specified name, version number, and information.
Log in to this provider. The provider relies on a CallbackHandler to obtain authentication information from the caller (a PIN, for example). If the caller passes a null handler to this method, the provider uses the handler set in the setCallbackHandler method. If no handler was set in that method, the provider queries the auth.login.defaultCallbackHandler security property for the fully qualified class name of a default handler implementation. If the security property is not set, the provider is assumed to have alternative means for obtaining authentication information.
Log out from this provider.
Set a CallbackHandler. The provider uses this handler if one is not passed to the login method. The provider also uses this handler if it invokes login on behalf of callers. In either case if a handler is not set via this method, the provider queries the auth.login.defaultCallbackHandler security property for the fully qualified class name of a default handler implementation. If the security property is not set, the provider is assumed to have alternative means for obtaining authentication information.
"Creates a new BasicPermission with the specified name. Name is the symbolic name of the permission, such as ""setFactory"", ""print.queueJob"", or ""topLevelWindow"", etc."
Creates a new BasicPermission object with the specified name. The name is the symbolic name of the BasicPermission, and the actions String is currently unused.
"Checks if the specified permission is ""implied"" by this object. More specifically, this method returns true if: p's class is the same as this object's class, and p's name equals or (in the case of wildcards) is implied by this object's name. For example, ""a.b.*"" implies ""a.b.c""."
Checks two BasicPermission objects for equality. Checks that obj's class is the same as this object's class and has the same name as this object.
Returns the hash code value for this object. The hash code used is the hash code of the name, that is, getName().hashCode(), where getName is from the Permission superclass.
"Returns the canonical string representation of the actions, which currently is the empty string """", since there are no actions for a BasicPermission."
Returns a new PermissionCollection object for storing BasicPermission objects. BasicPermission objects must be stored in a manner that allows them to be inserted in any order, but that also enables the PermissionCollection implies method to be implemented in an efficient (and consistent) manner.
Returns the guarantor of the certificate, that is, the principal guaranteeing that the public key associated with this certificate is that of the principal associated with this certificate. For X.509 certificates, the guarantor will typically be a Certificate Authority (such as the United States Postal Service or Verisign, Inc.).
Returns the principal of the principal-key pair being guaranteed by the guarantor.
Returns the key of the principal-key pair being guaranteed by the guarantor.
Encodes the certificate to an output stream in a format that can be decoded by the decode method.
Decodes a certificate from an input stream. The format should be that returned by getFormat and produced by encode.
"Returns the name of the coding format. This is used as a hint to find an appropriate parser. It could be ""X.509"", ""PGP"", etc. This is the format produced and understood by the encode and decode methods."
Returns a string that represents the contents of the certificate.
Constructs a CodeSigner object.
Returns the signer's certificate path.
Returns the signature timestamp.
Returns the hash code value for this code signer. The hash code is generated using the signer's certificate path and the timestamp, if present.
Tests for equality between the specified object and this code signer. Two code signers are considered equal if their signer certificate paths are equal and if their timestamps are equal, if present in both.
Returns a string describing this code signer.
Constructs a CodeSource and associates it with the specified location and set of certificates.
Constructs a CodeSource and associates it with the specified location and set of code signers.
Returns the hash code value for this object.
Tests for equality between the specified object and this object. Two CodeSource objects are considered equal if their locations are of identical value and if their signer certificate chains are of identical value. It is not required that the certificate chains be in the same order.
Returns the location associated with this CodeSource.
Returns the certificates associated with this CodeSource. If this CodeSource object was created using the CodeSource(URL url, CodeSigner[] signers) constructor then its certificate chains are extracted and used to create an array of Certificate objects. Each signer certificate is followed by its supporting certificate chain (which may be empty). Each signer certificate and its supporting certificate chain is ordered bottom-to-top (i.e., with the signer certificate first and the (root) certificate authority last).
Returns the code signers associated with this CodeSource. If this CodeSource object was created using the CodeSource(URL url, java.security.cert.Certificate[] certs) constructor then its certificate chains are extracted and used to create an array of CodeSigner objects. Note that only X.509 certificates are examined - all other certificate types are ignored.
"Returns true if this CodeSource object ""implies"" the specified CodeSource. More specifically, this method makes the following checks. If any fail, it returns false. If they all succeed, it returns true. codesource must not be null. If this object's certificates are not null, then all of this object's certificates must be present in codesource's certificates. If this object's location (getLocation()) is not null, then the following checks are made against this object's location and codesource's: codesource's location must not be null. If this object's location equals codesource's location, then return true. This object's protocol (getLocation().getProtocol()) must be equal to codesource's protocol, ignoring case. If this object's host (getLocation().getHost()) is not null, then the SocketPermission constructed with this object's host must imply the SocketPermission constructed with codesource's host. If this object's port (getLocation().getPort()) is not equal to -1 (that is, if a port is specified), it must equal codesource's port or default port (codesource.getLocation().getDefaultPort()). If this object's file (getLocation().getFile()) doesn't equal codesource's file, then the following checks are made: If this object's file ends with ""/-"", then codesource's file must start with this object's file (exclusive the trailing ""-""). If this object's file ends with a ""/*"", then codesource's file must start with this object's file and must not have any further ""/"" separators. If this object's file doesn't end with a ""/"", then codesource's file must match this object's file with a '/' appended. If this object's reference (getLocation().getRef()) is not null, it must equal codesource's reference. For example, the codesource objects with the following locations and null certificates all imply the codesource with the location ""http://java.sun.com/classes/foo.jar"" and null certificates: http: http://*.sun.com/classes/* http://java.sun.com/classes/- http://java.sun.com/classes/foo.jar Note that if this CodeSource has a null location and a null certificate chain, then it implies every other CodeSource."
Returns a string describing this CodeSource, telling its URL and certificates.
Hash function
Cryptographic random number generator
Symmetric primitive: block cipher
Symmetric primitive: stream cipher
Symmetric primitive: message authentication code
Symmetric primitive: key wrap
Asymmetric primitive: public key encryption
Asymmetric primitive: signature scheme
Asymmetric primitive: key encapsulation mechanism
Asymmetric primitive: key agreement and key distribution
Returns an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (CryptoPrimitive c : CryptoPrimitive.values()) System.out.println(c);
Returns the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
Constructs a DigestException with no detail message. (A detail message is a String that describes this particular exception.)
Constructs a DigestException with the specified detail message. (A detail message is a String that describes this particular exception.)
Creates a DigestException with the specified detail message and cause.
Creates a DigestException with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause).
The message digest associated with this stream.
Creates a digest input stream, using the specified input stream and message digest.
Returns the message digest associated with this stream.
Associates the specified message digest with this stream.
Reads a byte, and updates the message digest (if the digest function is on). That is, this method reads a byte from the input stream, blocking until the byte is actually read. If the digest function is on (see on), this method will then call update on the message digest associated with this stream, passing it the byte read.
Reads into a byte array, and updates the message digest (if the digest function is on). That is, this method reads up to len bytes from the input stream into the array b, starting at offset off. This method blocks until the data is actually read. If the digest function is on (see on), this method will then call update on the message digest associated with this stream, passing it the data.
Turns the digest function on or off. The default is on. When it is on, a call to one of the read methods results in an update on the message digest. But when it is off, the message digest is not updated.
Prints a string representation of this digest input stream and its associated message digest object.
The message digest associated with this stream.
Creates a digest output stream, using the specified output stream and message digest.
Returns the message digest associated with this stream.
Associates the specified message digest with this stream.
Updates the message digest (if the digest function is on) using the specified byte, and in any case writes the byte to the output stream. That is, if the digest function is on (see on), this method calls update on the message digest associated with this stream, passing it the byte b. This method then writes the byte to the output stream, blocking until the byte is actually written.
Updates the message digest (if the digest function is on) using the specified subarray, and in any case writes the subarray to the output stream. That is, if the digest function is on (see on), this method calls update on the message digest associated with this stream, passing it the subarray specifications. This method then writes the subarray bytes to the output stream, blocking until the bytes are actually written.
Turns the digest function on or off. The default is on. When it is on, a call to one of the write methods results in an update on the message digest. But when it is off, the message digest is not updated.
Prints a string representation of this digest output stream and its associated message digest object.
Modify or update the provided ProtectionDomains. ProtectionDomains may be added to or removed from the given ProtectionDomains. The ProtectionDomains may be re-ordered. Individual ProtectionDomains may be modified (with a new set of Permissions, for example).
Constructs a DomainLoadStoreParameter for a keystore domain with the parameters used to protect keystore data.
Gets the identifier for the domain configuration data.
Gets the keystore protection parameters for keystores in this domain.
Gets the keystore protection parameters for this domain. Keystore domains do not support a protection parameter.
Constructs a GeneralSecurityException with no detail message.
Constructs a GeneralSecurityException with the specified detail message. A detail message is a String that describes this particular exception.
Creates a GeneralSecurityException with the specified detail message and cause.
Creates a GeneralSecurityException with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause).
Determines whether or not to allow access to the guarded object object. Returns silently if access is allowed. Otherwise, throws a SecurityException.
Constructs a GuardedObject using the specified object and guard. If the Guard object is null, then no restrictions will be placed on who can access the object.
Retrieves the guarded object, or throws an exception if access to the guarded object is denied by the guard.
Constructor for serialization only.
Constructs an identity with the specified name and scope.
Constructs an identity with the specified name and no scope.
Returns this identity's name.
Returns this identity's scope.
Returns this identity's public key.
"Sets this identity's public key. The old key and all of this identity's certificates are removed by this operation. First, if there is a security manager, its checkSecurityAccess method is called with ""setIdentityPublicKey"" as its argument to see if it's ok to set the public key."
"Specifies a general information string for this identity. First, if there is a security manager, its checkSecurityAccess method is called with ""setIdentityInfo"" as its argument to see if it's ok to specify the information string."
Returns general information previously specified for this identity.
"Adds a certificate for this identity. If the identity has a public key, the public key in the certificate must be the same, and if the identity does not have a public key, the identity's public key is set to be that specified in the certificate. First, if there is a security manager, its checkSecurityAccess method is called with ""addIdentityCertificate"" as its argument to see if it's ok to add a certificate."
"Removes a certificate from this identity. First, if there is a security manager, its checkSecurityAccess method is called with ""removeIdentityCertificate"" as its argument to see if it's ok to remove a certificate."
Returns a copy of all the certificates for this identity.
Tests for equality between the specified object and this identity. This first tests to see if the entities actually refer to the same object, in which case it returns true. Next, it checks to see if the entities have the same name and the same scope. If they do, the method returns true. Otherwise, it calls identityEquals, which subclasses should override.
Tests for equality between the specified identity and this identity. This method should be overriden by subclasses to test for equality. The default behavior is to return true if the names and public keys are equal.
"Returns a short string describing this identity, telling its name and its scope (if any). First, if there is a security manager, its checkSecurityAccess method is called with ""printIdentity"" as its argument to see if it's ok to return the string."
"Returns a string representation of this identity, with optionally more details than that provided by the toString method without any arguments. First, if there is a security manager, its checkSecurityAccess method is called with ""printIdentity"" as its argument to see if it's ok to return the string."
Returns a hashcode for this identity.
This constructor is used for serialization only and should not be used by subclasses.
Constructs a new identity scope with the specified name.
Constructs a new identity scope with the specified name and scope.
Returns the system's identity scope.
"Sets the system's identity scope. First, if there is a security manager, its checkSecurityAccess method is called with ""setSystemScope"" as its argument to see if it's ok to set the identity scope."
Returns the number of identities within this identity scope.
Returns the identity in this scope with the specified name (if any).
Retrieves the identity whose name is the same as that of the specified principal. (Note: Identity implements Principal.)
Retrieves the identity with the specified public key.
Adds an identity to this identity scope.
Removes an identity from this identity scope.
Returns an enumeration of all identities in this identity scope.
Returns a string representation of this identity scope, including its name, its scope name, and the number of identities in this identity scope.
Constructs an InvalidAlgorithmParameterException with no detail message. A detail message is a String that describes this particular exception.
Constructs an InvalidAlgorithmParameterException with the specified detail message. A detail message is a String that describes this particular exception.
Creates a InvalidAlgorithmParameterException with the specified detail message and cause.
Creates a InvalidAlgorithmParameterException with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause).
Constructs an InvalidKeyException with no detail message. A detail message is a String that describes this particular exception.
Constructs an InvalidKeyException with the specified detail message. A detail message is a String that describes this particular exception.
Creates a InvalidKeyException with the specified detail message and cause.
Creates a InvalidKeyException with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause).
Constructs an InvalidParameterException with no detail message. A detail message is a String that describes this particular exception.
Constructs an InvalidParameterException with the specified detail message. A detail message is a String that describes this particular exception.
The class fingerprint that is set to indicate serialization compatibility with a previous version of the class.
"Returns the standard algorithm name for this key. For example, ""DSA"" would indicate that this key is a DSA key. See Appendix A in the Java Cryptography Architecture API Specification & Reference for information about standard algorithm names."
"Returns the name of the primary encoding format of this key, or null if this key does not support encoding. The primary encoding format is named in terms of the appropriate ASN.1 data format, if an ASN.1 specification for this key exists. For example, the name of the ASN.1 data format for public keys is SubjectPublicKeyInfo, as defined by the X.509 standard; in this case, the returned format is ""X.509"". Similarly, the name of the ASN.1 data format for private keys is PrivateKeyInfo, as defined by the PKCS #8 standard; in this case, the returned format is ""PKCS#8""."
Returns the key in its primary encoding format, or null if this key does not support encoding.
Constructs a KeyException with no detail message. A detail message is a String that describes this particular exception.
Constructs a KeyException with the specified detail message. A detail message is a String that describes this particular exception.
Creates a KeyException with the specified detail message and cause.
Creates a KeyException with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause).
Creates a KeyFactory object.
Returns a KeyFactory object that converts public/private keys of the specified algorithm. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyFactory object encapsulating the KeyFactorySpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the Security.getProviders() method.
Returns a KeyFactory object that converts public/private keys of the specified algorithm. A new KeyFactory object encapsulating the KeyFactorySpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the Security.getProviders() method.
Returns a KeyFactory object that converts public/private keys of the specified algorithm. A new KeyFactory object encapsulating the KeyFactorySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.
Returns the provider of this key factory object.
Gets the name of the algorithm associated with this KeyFactory.
Generates a public key object from the provided key specification (key material).
Generates a private key object from the provided key specification (key material).
Returns a specification (key material) of the given key object. keySpec identifies the specification class in which the key material should be returned. It could, for example, be DSAPublicKeySpec.class, to indicate that the key material should be returned in an instance of the DSAPublicKeySpec class.
Translates a key object, whose provider may be unknown or potentially untrusted, into a corresponding key object of this key factory.
Generates a public key object from the provided key specification (key material).
Generates a private key object from the provided key specification (key material).
Returns a specification (key material) of the given key object. keySpec identifies the specification class in which the key material should be returned. It could, for example, be DSAPublicKeySpec.class, to indicate that the key material should be returned in an instance of the DSAPublicKeySpec class.
Translates a key object, whose provider may be unknown or potentially untrusted, into a corresponding key object of this key factory.
Constructs a KeyManagementException with no detail message. A detail message is a String that describes this particular exception.
Constructs a KeyManagementException with the specified detail message. A detail message is a String that describes this particular exception.
Creates a KeyManagementException with the specified detail message and cause.
Creates a KeyManagementException with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause).
Constructs a key pair from the given public key and private key. Note that this constructor only stores references to the public and private key components in the generated key pair. This is safe, because Key objects are immutable.
